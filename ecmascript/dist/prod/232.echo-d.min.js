"use strict";(Object("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).webpackChunkechoD=Object("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).webpackChunkechoD||[]).push([[232],{232:(e,t,s)=>{s.d(t,{World:()=>qe});const i=22,r=4194303,n=511;class a extends Error{constructor(e){super(`Internal error: ${e}. Please report a bug!`)}}class o extends Error{}const h=new TextEncoder,c=new TextDecoder;function d(e){throw new o(`Component is not writable; use entity.write(${e.type.name}) to acquire a writable version`)}function l(e,t){if(e.__invalid)throw new o(`Component instance for ${t.type.name} is no longer valid, as you already bound it to another entity`)}class u{defaultValue;shared;constructor(e,t=!0){this.defaultValue=e,this.shared=t}get internallyIndexed(){return!1}static boolean;static uint8;static int8;static uint16;static int16;static uint32;static int32;static float32;static float64;static vector;static staticString;static dynamicString;static object;static weakObject;static ref;static backrefs}class f extends u{NumberArray;constructor(e){super(0),this.NumberArray=e}defineElastic(e,t){const s=`component.${e.type.id}.field.${t.seq}`;let i;t.updateBuffer=()=>{e.dispatcher.buffers.register(s,e.capacity,this.NumberArray,(e=>{i=e}))},t.updateBuffer(),Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),i[e.writableIndex]},set(t){l(this,e),i[e.writableIndex]=t}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),i[e.readonlyIndex]},set(t){d(e)}})}defineFixed(e,t){const s=`component.${e.type.id}.field.${t.seq}`,i=e.dispatcher.buffers.register(s,e.capacity,this.NumberArray);Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),i[e.writableIndex]},set(t){l(this,e),i[e.writableIndex]=t}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),i[e.readonlyIndex]},set(t){d(e)}})}}class p extends u{type;Class;stride;elementNames;constructor(e,t,s){super(new Array("number"==typeof t?t:t.length).fill(0)),this.type=e,this.Class=s,"number"==typeof t?this.stride=t:(this.stride=t.length,this.elementNames=t)}get internallyIndexed(){return!0}defineElastic(e,t){const s=this.stride,i=this.elementNames,r=`component.${e.type.id}.field.${t.seq}`;let n;t.updateBuffer=()=>{e.dispatcher.buffers.register(r,e.capacity*s,this.type.NumberArray,(e=>{n=e}))},t.updateBuffer();const a=this.Class?new this.Class:{},h=this.Class?new this.Class:{};Object.defineProperty(a,"length",{value:s}),Object.defineProperty(h,"length",{value:s}),Object.defineProperty(a,"__becsyComponent",{value:void 0,writable:!0}),Object.defineProperty(h,"__becsyComponent",{value:void 0,writable:!0});let c=Object.create(a);Object.seal(c);let u=Object.create(h);Object.seal(u);for(let t=0;t<this.stride;t++)Object.defineProperty(a,`${t}`,{enumerable:!0,get(){return l(this.__becsyComponent,e),n[e.writableIndex*s+t]},set(i){l(this.__becsyComponent,e),n[e.writableIndex*s+t]=i}}),Object.defineProperty(h,`${t}`,{enumerable:!0,get(){return l(this.__becsyComponent,e),n[e.readonlyIndex*s+t]},set(t){d(e)}}),this.elementNames?.[t]&&(Object.defineProperty(a,this.elementNames[t],{enumerable:!0,get(){return l(this.__becsyComponent,e),n[e.writableIndex*s+t]},set(i){l(this.__becsyComponent,e),n[e.writableIndex*s+t]=i}}),Object.defineProperty(h,this.elementNames[t],{enumerable:!0,get(){return l(this.__becsyComponent,e),n[e.readonlyIndex*s+t]},set(t){d(e)}}));Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),c=Object.create(a),c.__becsyComponent=this,Object.seal(c),c},set(r){if(l(this,e),r.length){if(r.length!==s)throw new o(`Value of length ${r.length} doesn't match vector of length ${s}`);for(let t=0;t<s;t++)n[e.writableIndex*s+t]=r[t]}else{if(!i)throw new o(`Value assigned to ${e.type.name}.${t.name} must be an array`);for(let a=0;a<s;a++){if("number"!=typeof r[i[a]])throw new o(`Value assigned to ${e.type.name}.${t.name} is missing element "${i[a]}`);n[e.writableIndex*s+a]=r[i[a]]}}}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),u=Object.create(h),u.__becsyComponent=this,Object.seal(u),u},set(t){d(e)}})}defineFixed(e,t){const s=this.stride,i=this.elementNames,r=`component.${e.type.id}.field.${t.seq}`,n=e.dispatcher.buffers.register(r,e.capacity*s,this.type.NumberArray),a=this.Class?new this.Class:{},h=this.Class?new this.Class:{};Object.defineProperty(a,"length",{value:s}),Object.defineProperty(h,"length",{value:s}),Object.defineProperty(a,"__becsyComponent",{value:void 0,writable:!0}),Object.defineProperty(h,"__becsyComponent",{value:void 0,writable:!0});let c=Object.create(a);Object.seal(c);let u=Object.create(h);Object.seal(u);for(let t=0;t<this.stride;t++)Object.defineProperty(a,`${t}`,{enumerable:!0,get(){return l(this.__becsyComponent,e),n[e.writableIndex*s+t]},set(i){l(this.__becsyComponent,e),n[e.writableIndex*s+t]=i}}),Object.defineProperty(h,`${t}`,{enumerable:!0,get(){return l(this.__becsyComponent,e),n[e.readonlyIndex*s+t]},set(t){d(e)}}),this.elementNames?.[t]&&(Object.defineProperty(a,this.elementNames[t],{enumerable:!0,get(){return l(this.__becsyComponent,e),n[e.writableIndex*s+t]},set(i){l(this.__becsyComponent,e),n[e.writableIndex*s+t]=i}}),Object.defineProperty(h,this.elementNames[t],{enumerable:!0,get(){return l(this.__becsyComponent,e),n[e.readonlyIndex*s+t]},set(t){d(e)}}));Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),c=Object.create(a),c.__becsyComponent=this,Object.seal(c),c},set(r){if(l(this,e),r.length){if(r.length!==s)throw new o(`Value of length ${r.length} doesn't match vector of length ${s}`);for(let t=0;t<s;t++)n[e.writableIndex*s+t]=r[t]}else{if(!i)throw new o(`Value assigned to ${e.type.name}.${t.name} must be an array`);for(let a=0;a<s;a++){if("number"!=typeof r[i[a]])throw new o(`Value assigned to ${e.type.name}.${t.name} is missing element "${i[a]}`);n[e.writableIndex*s+a]=r[i[a]]}}}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),u=Object.create(h),u.__becsyComponent=this,Object.seal(u),u},set(t){d(e)}})}}class m extends u{choices;choicesIndex=new Map;TypedArray;constructor(e){if(super(e[0]),this.choices=e,!e?.length)throw new o("No choices specified for Type.staticString");e.length<256?this.TypedArray=Uint8Array:e.length<65536?this.TypedArray=Uint16Array:this.TypedArray=Uint32Array;for(let t=0;t<e.length;t++)this.choicesIndex.set(e[t],t)}defineElastic(e,t){const s=`component.${e.type.id}.field.${t.seq}`;let i;const r=this.choices,n=this.choicesIndex;t.updateBuffer=()=>{e.dispatcher.buffers.register(s,e.capacity,this.TypedArray,(e=>{i=e}))},t.updateBuffer(),Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=i[e.writableIndex],s=r[t];if(void 0===s)throw new o(`Invalid static string index: ${t}`);return s},set(t){l(this,e);const s=n.get(t);if(void 0===s)throw new o(`Static string not in set: "${t}"`);i[e.writableIndex]=s}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=i[e.readonlyIndex],s=r[t];if(void 0===s)throw new o(`Invalid static string index: ${t}`);return s},set(t){d(e)}})}defineFixed(e,t){const s=`component.${e.type.id}.field.${t.seq}`,i=this.choices,r=this.choicesIndex,n=e.dispatcher.buffers.register(s,e.capacity,this.TypedArray);Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=n[e.writableIndex],s=i[t];if(void 0===s)throw new o(`Invalid static string index: ${t}`);return s},set(t){l(this,e);const s=r.get(t);if(void 0===s)throw new o(`Static string not in set: "${t}"`);n[e.writableIndex]=s}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=n[e.readonlyIndex],s=i[t];if(void 0===s)throw new o(`Invalid static string index: ${t}`);return s},set(t){d(e)}})}}class y extends u{maxUtf8Length;lengthsStride;bytesStride;constructor(e){super(""),this.maxUtf8Length=e+e%2,this.bytesStride=this.maxUtf8Length+2,this.lengthsStride=this.bytesStride/2}defineElastic(e,t){const s=`component.${e.type.id}.field.${t.seq}`;let i,r;const n=this.maxUtf8Length,a=this.lengthsStride,u=this.bytesStride;t.updateBuffer=()=>{const t=e.capacity*(this.maxUtf8Length+Uint16Array.BYTES_PER_ELEMENT);e.dispatcher.buffers.register(s,t,Uint8Array,(e=>{r=e,i=new Uint16Array(r.buffer)}))},t.updateBuffer(),Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=i[e.writableIndex*a];return c.decode(new Uint8Array(r.buffer,e.writableIndex*u+2,t))},set(t){l(this,e);const s=h.encode(t);if(s.byteLength>n)throw new o(`Dynamic string length > ${n} after encoding: ${t}`);i[e.writableIndex*a]=s.byteLength,r.set(s,e.writableIndex*u+2)}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=i[e.readonlyIndex*a];return c.decode(new Uint8Array(r.buffer,e.readonlyIndex*u+2,t))},set(t){d(e)}})}defineFixed(e,t){const s=`component.${e.type.id}.field.${t.seq}`,i=this.maxUtf8Length,r=this.lengthsStride,n=this.bytesStride,a=e.capacity*(this.maxUtf8Length+Uint16Array.BYTES_PER_ELEMENT),u=e.dispatcher.buffers.register(s,a,Uint8Array),f=new Uint16Array(u.buffer);Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=f[e.writableIndex*r];return c.decode(new Uint8Array(u.buffer,e.writableIndex*n+2,t))},set(t){l(this,e);const s=h.encode(t);if(s.byteLength>i)throw new o(`Dynamic string length > ${i} after encoding: ${t}`);f[e.writableIndex*r]=s.byteLength,u.set(s,e.writableIndex*n+2)}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=f[e.readonlyIndex*r];return c.decode(new Uint8Array(u.buffer,e.readonlyIndex*n+2,t))},set(t){d(e)}})}}const g=2**31,_=[];class w extends u{type;fieldName;trackDeletedBackrefs;constructor(e,t,s){super(_),this.type=e,this.fieldName=t,this.trackDeletedBackrefs=s}defineElastic(e,t){t.updateBuffer=()=>{};const s=this.fieldName?this.type?.__binding.fields.find((e=>e.name===this.fieldName)):void 0;if(this.fieldName&&!s)throw new o(`Backrefs field ${e.type.name}.${t.name} refers to an unknown field ${this.type.name}.${this.fieldName}`);if(s&&s.type!==u.ref)throw new o(`Backrefs field ${e.type.name}.${t.name} refers to a field ${this.type.name}.${this.fieldName} that is not a ref`);if(this.fieldName&&!this.type)throw new o(`Backrefs selector has field but no component in ${e.type.name}.${t.name}`);if(this.type&&!this.fieldName&&!this.type.__binding.refFields.length)throw new o(`Backrefs field ${e.type.name}.${t.name} refers to component ${this.type.name} that has no ref fields`);const i=this.trackDeletedBackrefs,r=e.dispatcher.indexer;r.registerSelector();const n=r.registerSelector(e.type,this.type,s?.seq,this.trackDeletedBackrefs);Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){if(l(this,e),!i&&e.dispatcher.registry.includeRecentlyDeleted)throw new o(`Backrefs field ${e.type.name}.${t.name} not configured to track recently deleted refs`);return r.getBackrefs(e.writableEntityId,n)},set(t){if(l(this,e),t!==_)throw new o("Backrefs properties are computed automatically, you cannot set them")}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){if(l(this,e),!i&&e.dispatcher.registry.includeRecentlyDeleted)throw new o(`Backrefs field ${e.type.name}.${t.name} not configured to track recently deleted refs`);return r.getBackrefs(e.readonlyEntityId,n)},set(t){if(l(this,e),t!==_)throw new o("Backrefs properties are computed automatically, you cannot set them")}})}defineFixed(e,t){this.defineElastic(e,t)}}u.boolean=new class extends u{constructor(){super(!1)}defineElastic(e,t){const s=`component.${e.type.id}.field.${t.seq}`;let i;t.updateBuffer=()=>{e.dispatcher.buffers.register(s,e.capacity,Uint8Array,(e=>{i=e}))},t.updateBuffer(),Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),Boolean(i[e.writableIndex])},set(t){l(this,e),i[e.writableIndex]=t?1:0}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),Boolean(i[e.readonlyIndex])},set(t){d(e)}})}defineFixed(e,t){const s=`component.${e.type.id}.field.${t.seq}`,i=e.dispatcher.buffers.register(s,e.capacity,Uint8Array);Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),Boolean(i[e.writableIndex])},set(t){l(this,e),i[e.writableIndex]=t?1:0}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),Boolean(i[e.readonlyIndex])},set(t){d(e)}})}},u.uint8=new f(Uint8Array),u.int8=new f(Int8Array),u.uint16=new f(Uint16Array),u.int16=new f(Int16Array),u.uint32=new f(Uint32Array),u.int32=new f(Int32Array),u.float32=new f(Float32Array),u.float64=new f(Float64Array),u.vector=(e,t,s)=>new p(e,t,s),u.staticString=e=>new m(e),u.dynamicString=e=>new y(e),u.ref=new class extends u{constructor(){super(void 0)}defineElastic(e,t){const s=`component.${e.type.id}.field.${t.seq}`;let i;const n=e.dispatcher.indexer,h=e.dispatcher.registry,c=h.pool;n.registerSelector(),t.updateBuffer=()=>{e.dispatcher.buffers.register(s,e.capacity,Int32Array,(e=>{i=e}),-1)},t.updateBuffer(),t.clearRef=(s,o,h)=>{if(h)throw new a("Ref fields have no internal index");if(-1===i[e.writableIndex])return;const c=0!=(i[e.writableIndex]&g);if(c&&!s)return;if(!c&&s)throw new a("Wrong ref stale state");const d=i[e.writableIndex]&r;void 0!==o&&d!==o||(s?i[e.writableIndex]=-1:i[e.writableIndex]|=g,n.trackRefChange(e.writableEntityId,e.type,t.seq,void 0,d,-1,!s,s))},Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=i[e.writableIndex];if(!(-1===t||t&g&&!h.includeRecentlyDeleted))return c.borrowTemporarily(t&r)},set(s){if(l(this,e),s&&!h.hasShape(s.__id,h.Alive,!1))throw new o("Referencing a deleted entity is not allowed");let a=i[e.writableIndex];-1!==a&&(a&=r);const c=-1!==a&&!!(i[e.writableIndex]&g),d=s?.__id??-1;(a!==d||c)&&(i[e.writableIndex]=d,n.trackRefChange(e.writableEntityId,e.type,t.seq,void 0,a,d,!c,!0))}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=i[e.readonlyIndex];if(!(-1===t||t&g&&!h.includeRecentlyDeleted))return c.borrowTemporarily(t&r)},set(t){d(e)}})}defineFixed(e,t){const s=`component.${e.type.id}.field.${t.seq}`,i=e.dispatcher.buffers.register(s,e.capacity,Int32Array,void 0,-1),n=e.dispatcher.indexer,h=e.dispatcher.registry,c=h.pool;n.registerSelector(),t.clearRef=(s,o,h)=>{if(h)throw new a("Ref fields have no internal index");if(-1===i[e.writableIndex])return;const c=0!=(i[e.writableIndex]&g);if(c&&!s)return;if(!c&&s)throw new a("Wrong ref stale state");const d=i[e.writableIndex]&r;void 0!==o&&d!==o||(s?i[e.writableIndex]=-1:i[e.writableIndex]|=g,n.trackRefChange(e.writableEntityId,e.type,t.seq,void 0,d,-1,!s,s))},Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=i[e.writableIndex];if(!(-1===t||t&g&&!h.includeRecentlyDeleted))return c.borrowTemporarily(t&r)},set(s){if(l(this,e),s&&!h.hasShape(s.__id,h.Alive,!1))throw new o("Referencing a deleted entity is not allowed");let a=i[e.writableIndex];-1!==a&&(a&=r);const c=-1!==a&&!!(i[e.writableIndex]&g),d=s?.__id??-1;(a!==d||c)&&(i[e.writableIndex]=d,n.trackRefChange(e.writableEntityId,e.type,t.seq,void 0,a,d,!c,!0))}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=i[e.readonlyIndex];if(!(-1===t||t&g&&!h.includeRecentlyDeleted))return c.borrowTemporarily(t&r)},set(t){d(e)}})}},u.backrefs=(e,t,s=!1)=>new w(e,t,s),u.object=new class extends u{constructor(){super(void 0,!1)}defineElastic(e,t){const s=[];t.updateBuffer=()=>{},Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),s[e.writableIndex]},set(t){l(this,e),s[e.writableIndex]=t}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),s[e.readonlyIndex]},set(t){d(e)}})}defineFixed(e,t){const s=new Array(e.capacity);t.updateBuffer=()=>{},Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),s[e.writableIndex]},set(t){l(this,e),s[e.writableIndex]=t}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){return l(this,e),s[e.readonlyIndex]},set(t){d(e)}})}},u.weakObject=new class extends u{finalizers;constructor(){super(void 0,!1)}defineElastic(e,t){const s=[];t.updateBuffer=()=>{};const i=this.initFinalizers(e);Object.defineProperty(e.writableMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=s[e.writableIndex];return null==t?t:t.deref()},set(t){if(l(this,e),null!=t){const r=new WeakRef(t);i?.register(t,{type:e.type,data:s,weakRef:r,id:e.writableEntityId,index:e.writableIndex}),t=r}s[e.writableIndex]=t}}),Object.defineProperty(e.readonlyMaster,t.name,{enumerable:!0,configurable:!0,get(){l(this,e);const t=s[e.readonlyIndex];return null==t?t:t.deref()},set(t){d(e)}})}defineFixed(e,t){this.defineElastic(e,t)}initFinalizers(e){if(!e.trackedWrites)return;if(this.finalizers)return this.finalizers;const t=e.dispatcher;return t.writeLog&&"undefined"!=typeof FinalizationRegistry?(this.finalizers=new FinalizationRegistry((({type:e,data:s,weakRef:i,id:r,index:n})=>{s[n]===i&&t.registry.trackWrite(r,e)})),this.finalizers):void 0}};class b{type;fields;dispatcher;capacity;storage;elastic;constructor(e,t,s,i,r,n,a){this.type=e,this.fields=t,this.dispatcher=i,this.capacity=r,this.storage=n,this.elastic=a,this.readonlyMaster=this.readonlyInstance=new e,this.writableMaster=this.writableInstance=new e,this.readonlyInstance=Object.create(this.readonlyMaster),this.readonlyInstance.__invalid=!this.elastic&&this.capacity>1,this.writableInstance=Object.create(this.writableMaster),this.writableInstance.__invalid=!this.elastic&&this.capacity>1,this.shapeOffset=s.offset,this.shapeMask=s.mask,this.shapeValue=s.value,this.refFields=t.filter((e=>e.type===u.ref)),this.trackedWrites=!1,this.writableEntityId=0,this.writableIndex=0,this.readonlyEntityId=0,this.readonlyIndex=0,this.initDefault=new Function("component",t.filter((e=>e.default!==_)).map((e=>`component.${e.name} = ${JSON.stringify(e.default)};`)).join("\n"));let o=[];o=t.filter((e=>e.default===_)).map((e=>`\n          if (${JSON.stringify(e.name)} in values) {\n            component.${e.name} = values.${e.name};\n          }\n        `)),this.init=new Function("component","values",t.filter((e=>e.default!==_)).map((e=>`\n          component.${e.name} = values.${e.name} === undefined ?\n            ${JSON.stringify(e.default)} : values.${e.name};\n        `)).concat(o).join("\n"))}resetWritableInstance(e,t){if(-1===t)throw new a(`Attempt to bind unacquired entity ${e} to ${this.type.name}`);return this.writableEntityId=e,this.writableIndex=t,(this.elastic||this.capacity>1)&&(this.writableInstance.__invalid=!0,this.writableInstance=Object.create(this.writableMaster)),this.writableInstance}resetReadonlyInstance(e,t){if(-1===t)throw new a(`Attempt to bind unacquired entity ${e} to ${this.type.name}`);return this.readonlyEntityId=e,this.readonlyIndex=t,(this.elastic||this.capacity>1)&&(this.readonlyInstance.__invalid=!0,this.readonlyInstance=Object.create(this.readonlyMaster)),this.readonlyInstance}}function x(e){if(!e.__binding)throw new o(`Component ${e.name} not defined; add to world defs`)}class E{maxEntities;binding;fields;constructor(e,t,s){this.maxEntities=e,this.binding=t,this.fields=s,this.growSpares(),this.growCapacity()}acquireIndex(e){let t=this.index[e];if(-1===t){if(this.spares[3]>0)t=this.spares[4+--this.spares[3]];else{if(this.spares[1]===this.spares[2]){if(!this.binding.elastic)throw new o(`Storage exhausted for component ${this.binding.type.name}; raise its capacity above ${this.binding.capacity}`);if(this.binding.capacity===this.maxEntities)throw new a(`Trying to grow storage index for component ${this.binding.type.name} beyond maxEntities`);this.binding.capacity=Math.min(this.maxEntities,2*this.binding.capacity),this.growCapacity()}t=this.spares[1]++}this.index[e]=t}return t}releaseIndex(e){if(-1===this.index[e])throw new a(`Index for entity ${e} in component ${this.binding.type.name} not allocated`);this.spares[3]===this.spares.length-4&&this.growSpares(),this.spares[4+this.spares[3]++]=this.index[e],this.index[e]=-1}growCapacity(){const e=this.binding.capacity;this.binding.dispatcher.stats.forComponent(this.binding.type).capacity=e;const t=this.ArrayType,s=t.BYTES_PER_ELEMENT!==this.spares?.[0];if(this.index&&!s||this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.index`,this.maxEntities,t,(e=>{this.index=e}),-1),s?this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.spares`,this.spares.length,t,this.updateSpares.bind(this)):this.spares[2]=e,this.binding.elastic)for(const e of this.fields)e.updateBuffer()}growSpares(){const e=this.spares?Math.min(this.maxEntities,2*(this.spares.length-4)):8;this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.spares`,4+e,this.ArrayType,this.updateSpares.bind(this))}updateSpares(e){e[2]=this.binding.capacity=Math.max(this.binding.capacity,e[2]),e[0]=this.ArrayType.BYTES_PER_ELEMENT,this.spares=e}get ArrayType(){const e=Math.max(this.spares?.[2]??0,this.binding.capacity);return e<128?Int8Array:e<32768?Int16Array:Int32Array}}class v{maxEntities;binding;fields;constructor(e,t,s){this.maxEntities=e,this.binding=t,this.fields=s,this.growCapacity()}findIndex(e){for(let t=0;t<this.index.length;t++)if(this.index[t]===e)return t;return-1}acquireIndex(e){let t;for(let s=0;s<this.index.length;s++){if(this.index[s]===e)return s;void 0===t&&-1===this.index[s]&&(t=s)}if(void 0===t){if(!this.binding.elastic)throw new o(`Storage exhausted for component ${this.binding.type.name}; raise its capacity above ${this.binding.capacity}`);if(this.binding.capacity===this.maxEntities)throw new a(`Trying to grow storage index for component ${this.binding.type.name} beyond maxEntities`);t=this.index.length,this.binding.capacity=Math.min(this.maxEntities,2*this.binding.capacity),this.growCapacity()}return this.index[t]=e,t}releaseIndex(e){for(let t=0;t<this.index.length;t++)if(this.index[t]===e)return void(this.index[t]=-1);throw new a(`Index for entity ${e} in component ${this.binding.type.name} not allocated`)}growCapacity(){const e=this.binding.capacity;if(this.binding.dispatcher.stats.forComponent(this.binding.type).capacity=e,this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.index`,e,Int32Array,this.updateIndex.bind(this),-1),this.binding.elastic)for(const e of this.fields)e.updateBuffer()}updateIndex(e){this.index=e,this.binding.capacity=this.index.length}}function k(e,t,s){if(x(e),void 0!==s)for(const t in s)if(!e.schema?.[t])throw new o(`Property ${t} not defined for component ${e.name}`);const i=e.__allocate(t);s?e.__binding.init(i,s):e.__binding.initDefault(i)}function C(e,t,s,i){const r=function(e){const t=e.schema,s=[];if(t){let i=0;for(const e in t){let r=t[e];(r instanceof u||"function"==typeof r)&&(r={type:r}),"function"==typeof r.type&&(r.type=r.type()),"default"in r||(r.default=r.type.defaultValue),s.push({name:e,seq:i++,type:r.type,default:r.default})}if(i>128)throw new o(`Component ${e.name} declares too many fields`)}return s}(t),n=r.length?t.options?.storage??i.defaultComponentStorage:"sparse",a="sparse"===n?i.maxEntities:Math.min(i.maxEntities,t.options?.capacity??0),h=t.options?.initialCapacity??8;if(void 0!==t.options?.capacity){if("sparse"===n)throw new o(`Component type ${t.name} cannot combine custom capacity with sparse storage`);if(t.options.capacity<=0)throw new o(`Component type ${t.name} capacity option must be great than zero: got ${a}`);if(void 0!==t.options.initialCapacity)throw new o(`Component type ${t.name} cannot have both capacity and initialCapacity options`)}if(t.options?.restrictedToMainThread&&r.every((e=>e.type.shared)))throw new o(`Component type ${t.name} is restrictedToMainThread but has no thread-exclusive fields`);if(t.__bind)throw new o(`Component type ${t.name} is already in use in another world`);t.id=e;const c=new b(t,r,s,i,a||h,n,!a);t.__binding=c}function S(e){const t=e.__binding;for(const e of t.fields)t.elastic?e.type.defineElastic(t,e):e.type.defineFixed(t,e);switch(t.storage){case"sparse":t.dispatcher.stats.forComponent(e).capacity=t.capacity,e.__bind=(e,s)=>s?t.resetWritableInstance(e,e):t.resetReadonlyInstance(e,e),e.__allocate=e=>t.resetWritableInstance(e,e);break;case"packed":{const s=new E(t.dispatcher.maxEntities,t,t.fields);e.__bind=(e,i)=>i?t.resetWritableInstance(e,s.index[e]):t.resetReadonlyInstance(e,s.index[e]),e.__allocate=e=>t.resetWritableInstance(e,s.acquireIndex(e)),e.__free=e=>{s.releaseIndex(e)};break}case"compact":{const s=new v(t.dispatcher.maxEntities,t,t.fields);e.__bind=(e,i)=>i?t.resetWritableInstance(e,s.findIndex(e)):t.resetReadonlyInstance(e,s.findIndex(e)),e.__allocate=e=>t.resetWritableInstance(e,s.acquireIndex(e)),e.__free=e=>{s.releaseIndex(e)};break}default:throw new o(`Invalid storage type "${t.storage}`)}}function I(e){delete e.id,delete e.__binding,delete e.__bind,delete e.__allocate,delete e.__free}function R(e){if(e.options||(e.options={}),e.options.storage&&"compact"!==e.options.storage)throw new o(`Component ${e.name} ${e.options.storage} storage is incompatible with singletons`);if(e.options.capacity&&1!==e.options.capacity)throw new o(`Component ${e.name} capacity of ${e.options.capacity} is incompatible with singletons`);if(e.options.initialCapacity)throw new o(`Component ${e.name} initial capacity of ${e.options.initialCapacity} is incompatible with singletons`);e.options.storage="compact",e.options.capacity=1}class P{__registry;constructor(e){this.__registry=e,this.__id=void 0,this.__sortKey=void 0,this.__valid=!0}get alive(){return this.__checkValid(),this.__registry.hasShape(this.__id,this.__registry.Alive,!1)}get ordinal(){return this.__registry.entityOrdinals[this.__id]}add(e,t){if(this.__checkValid(),this.__checkMask(e,"write"),!this.__registry.hasShape(this.__id,this.__registry.Alive,!1))throw new o("Entity has been deleted");if(this.__registry.hasShape(this.__id,e,!1))throw new o(`Entity already has a ${e.name} component`);this.__registry.setShape(this.__id,e),this.__registry.dispatcher.stats.forComponent(e).numEntities+=1,k(e,this.__id,t)}addAll(...e){this.__checkValid();{const t=new Set;for(const s of e)if("function"==typeof s&&s.enum){if(t.has(s.enum))throw new o("Can't add multiple components from the same enum");t.add(s.enum)}}for(let t=0;t<e.length;t++){const s=e[t];if("function"!=typeof s)throw new o(`Bad arguments to addAll: expected component type, got: ${s}`);let i=e[t+1];"function"==typeof i?i=void 0:t++,this.add(s,i)}}remove(e){if(this.__checkValid(),this.__checkMask(e,"write"),"function"==typeof e&&this.__checkHas(e,!1),"function"!=typeof e){const t=this.__registry.getEnumShape(this.__id,e,!1);if(!t)throw new o(`Entity doesn't have any components from ${e.name} enumeration`);e=t}this.__registry.clearShape(this.__id,e)}removeAll(...e){for(const t of e)this.remove(t)}has(e){return this.__checkValid(),this.__checkMask(e,"check"),"function"==typeof e?this.__registry.hasShape(this.__id,e,!0):!!this.__registry.getEnumShape(this.__id,e,!0)}hasSomeOf(...e){this.__checkValid();for(const t of e)if(this.has(t))return!0;return!1}hasAllOf(...e){this.__checkValid();for(const t of e)if(!this.has(t))return!1;return!0}hasAnyOtherThan(...e){this.__checkValid();const t=new Set(e);for(const e of this.__registry.types)if(this.__checkMask(e,"check"),!(t.has(e)||e.enum&&t.has(e.enum))&&this.__registry.hasShape(this.__id,e,!0))return!0;return!1}countHas(...e){this.__checkValid();let t=0;for(const s of e)this.has(s)&&(t+=1);return t}hasWhich(e){return this.__checkValid(),this.__checkMask(e,"check"),this.__registry.getEnumShape(this.__id,e,!0)}read(e){return this.__checkValid(),this.__checkMask(e,"read"),this.__checkHas(e,!0),e.__bind(this.__id,!1)}write(e){return this.__checkValid(),this.__checkMask(e,"write"),this.__checkHas(e,!0),e.__binding.trackedWrites&&this.__registry.trackWrite(this.__id,e),e.__bind(this.__id,!0)}delete(){this.__checkValid();const e=this.__registry.Alive;if(!this.__registry.hasShape(this.__id,e,!1))throw new o("Entity already deleted");for(const t of this.__registry.types)this.__registry.hasShape(this.__id,t,!1)&&(t!==e&&this.__checkMask(t,"write"),this.__registry.clearShape(this.__id,t));this.__registry.dispatcher.indexer.clearAllRefs(this.__id,!1)}hold(){return this.__checkValid(),this.__registry.holdEntity(this.__id)}isSame(e){return this.__checkValid(),this.__id===e.__id}__checkMask(e,t){$(e,this.__registry.executingSystem,t)}__checkHas(e,t){if(!this.__registry.hasShape(this.__id,e,t))throw new o(`Entity doesn't have a ${e.name} component`)}__checkValid(){if(!this.__valid)throw new o("Entity handle no longer valid")}}function $(e,t,s){x(e);const i=t?.accessMasks[s];if(!i)return;const r=e.__binding;if(0==((i[r.shapeOffset]??0)&r.shapeMask))throw new o(`System ${t.name} didn't mark component ${e.name} as ${s}able`)}function M(e,t){const s=t.__binding;return 0!=((e[s.shapeOffset]??0)&s.shapeMask)}function A(e,t,s=!1){x(t);const i=t.__binding.shapeOffset;if(i>=e.length){const t=e.length;e.length=i+1,e.fill(0,t,i)}e[i]|=s?t.__binding.shapeValue:t.__binding.shapeMask}const O=[];class T{maxEntries;configParamName;options;data;corral;staging;typeCounters;constructor(e,t,s,i={localProcessingAllowed:!1,sortedByComponentType:!1,numComponentTypes:0}){if(this.maxEntries=e,this.configParamName=t,this.options=i,s.register(`log.${t}.buffer`,e+2,Uint32Array,(e=>{this.data=e})),s.register(`log.${t}.corral`,e+2,Uint32Array,(e=>{this.corral=e})),i.sortedByComponentType){if(void 0===i.numComponentTypes)throw new a(`numComponentTypes required when ${this.configParamName} is sortedByComponentType`);s.register(`log.${t}.staging`,e+2,Uint32Array,(e=>{this.staging=e})),this.typeCounters=new Uint32Array(this.options.numComponentTypes)}}push(e,t){const s=this.corral[0];if(s>=this.maxEntries&&this.throwCapacityExceeded(),!s||this.corral[s]!==e){if(this.corral[s+2]=e,this.corral[0]+=1,!!t!=!!this.options.sortedByComponentType)throw new a(`Pushing value ${t?"with":"without"} type to log ${this.configParamName} `+(this.options.sortedByComponentType?"":"not ")+"sorted by component type");t&&(this.typeCounters[t.id]+=1)}}commit(e){if(!e&&this.options.localProcessingAllowed)throw new a(`Cannot use blind commit when local processing is allowed in log ${this.configParamName}`);return!this.corral[0]||(!e||e.generation===this.data[1]&&e.index===this.data[0]&&e.corralGeneration===this.corral[1]&&e.corralIndex===this.corral[0])&&(this.copyToData(this.staging?this.sortCorral():this.corral),this.corral[0]=0,this.corral[1]+=1,e&&(e.index=this.data[0],e.generation=this.data[1]),!0)}sortCorral(){let e=2,t=-1,s=0,r=0;for(let n=0;n<this.typeCounters.length;n++){const a=this.typeCounters[n];a&&(r+=1,-1===t?(t=n,s=a):t>=0&&(t=-2),1===a?(this.typeCounters[n]=e,e+=1):(this.typeCounters[n]=e+1,this.staging[e]=a|n<<i|2**31,e+=a+1))}if(t>=0)return s>1&&(this.corral[0]===this.maxEntries&&this.throwCapacityExceeded(),this.corral[this.corral[0]+2]=this.corral[2],this.corral[2]=this.corral[0]|t<<i|2**31,this.corral[0]+=1),this.typeCounters.fill(0),this.corral;this.corral[0]+r>this.maxEntries&&this.throwCapacityExceeded();const n=this.corral[0]+2;for(let e=2;e<n;e++){const t=this.corral[e],s=t>>>i;this.staging[this.typeCounters[s]++]=t}return this.staging[0]=e-2,this.typeCounters.fill(0),this.staging}copyToData(e){let t=this.data[0];const s=e[0],i=Math.min(s,this.maxEntries-t);for(this.data.set(e.subarray(2,i+2),t+2),i<s&&this.data.set(e.subarray(i+2,s+2),2),t+=s;t>=this.maxEntries;)t-=this.maxEntries,this.data[1]+=1;this.data[0]=t}createPointer(e){return e?(e.index=this.data[0],e.generation=this.data[1],e.corralIndex=this.corral[0],e.corralGeneration=this.corral[1],e):{index:this.data[0],generation:this.data[1],corralIndex:this.corral[0],corralGeneration:this.corral[1]}}copyPointer(e){return{index:e.index,generation:e.generation,corralIndex:e.corralIndex,corralGeneration:e.corralGeneration}}hasUpdatesSince(e){return this.checkPointer(e),!(e.index===this.data[0]&&e.generation===this.data[1]&&(e.corralGeneration===this.corral[1]?e.corralIndex===this.corral[0]:0===this.corral[0]))}processSince(e,t){this.checkPointers(e,t);let s=O;const i=t?.index??this.data[0],r=t?.generation??this.data[1];if(e.generation===r)if(e.index<i)s=[this.data,e.index+2,i+2,!1],e.index=i;else{const t=this.corral[0],i=this.corral[1];(e.corralGeneration===i?e.corralIndex<t:t)&&(s=[this.corral,e.corralIndex+2,t+2,!0],e.corralIndex=t,e.corralGeneration=i)}else s=[this.data,e.index+2,this.data.length,!1],e.index=0,e.generation=r;return s}processAndCommitSince(e){const t=this.processSince(e);return t[0]?t:this.commit(e)?O:this.processSince(e)}countSince(e,t){if(this.checkPointers(e,t),this.corral[0])throw new a(`Should commit log ${this.configParamName} before counting`);const s=e.index,i=e.generation,r=t?.index??this.data[0],n=t?.generation??this.data[1];return e.index=r,e.generation=n,s===r&&i===n?0:s<r?r-s:this.maxEntries-(s-r)}checkPointers(e,t){if(this.checkPointer(e),t&&(this.checkPointer(t),e.index>t.index&&e.generation>=t.generation))throw new a(`Start pointer exceeds end pointer in log ${this.configParamName}`)}checkPointer(e){const t=this.data[0];let s=e.generation;if(e.index===t?s+1<this.data[1]&&this.throwCapacityExceeded():(e.index>t&&(s+=1),s!==this.data[1]&&this.throwCapacityExceeded()),e.corralGeneration>this.corral[1])throw new a(`Pointer corral generation older than corral in log ${this.configParamName}`);if(e.corralGeneration===this.corral[1]&&e.corralIndex>this.corral[0])throw new a(`Pointer past end of corral area in log ${this.configParamName}`)}throwCapacityExceeded(){throw new o(`Log capacity exceeded, please raise ${this.configParamName} above ${this.maxEntries}`)}}class L{size;bytes;constructor(e){this.size=e,this.bytes=new Uint32Array(Math.ceil(e/32))}get(e){if(e<0||e>=this.size)throw new a(`Bit index out of bounds: ${e}`);return 0!=(this.bytes[e>>>5]&1<<(31&e))}set(e){if(e<0||e>=this.size)throw new a(`Bit index out of bounds: ${e}`);this.bytes[e>>>5]|=1<<(31&e)}unset(e){if(e<0||e>=this.size)throw new a(`Bit index out of bounds: ${e}`);this.bytes[e>>>5]&=~(1<<(31&e))}clear(){this.bytes.fill(0)}}class B{pool;orderBy;entities=[];maxOrderKey=-1/0;sorted=!0;constructor(e,t){this.pool=e,this.orderBy=t}add(e){const t=this.pool.borrowTemporarily(e);if(this.orderBy){const e=this.orderBy(t);e>=this.maxOrderKey?this.maxOrderKey=e:this.sorted=!1}this.entities.push(t)}clear(){this.entities.length&&(this.entities.length=0),this.maxOrderKey=-1/0,this.sorted=!0}sort(){if(this.sorted)return;const e=this.orderBy;for(const t of this.entities)t.__sortKey=e(t);this.entities.sort(((e,t)=>e.__sortKey<t.__sortKey?-1:e.__sortKey>t.__sortKey?1:0)),this.sorted=!0}}class N{pool;orderBy;entities=[];lookupTable;maxOrderKey=-1/0;sorted=!0;constructor(e,t,s){this.pool=e,this.orderBy=t,this.lookupTable=new Int32Array(s),this.lookupTable.fill(-1)}add(e){const t=this.pool.borrow(e);if(this.orderBy){const e=this.orderBy(t);e>=this.maxOrderKey?this.maxOrderKey=e:this.sorted=!1}const s=this.entities.push(t)-1;this.lookupTable[e]=s}remove(e){const t=this.lookupTable[e];if(t<0)throw new a("Entity not in list");this.pool.return(e),this.lookupTable[e]=-1;const s=this.entities.pop();t<this.entities.length&&(this.entities[t]=s,this.lookupTable[s.__id]=t,this.orderBy&&(this.sorted=!1))}has(e){return this.lookupTable[e]>=0}clear(){for(const e of this.entities)this.pool.return(e.__id);this.entities=[],this.lookupTable.fill(-1),this.maxOrderKey=-1/0,this.sorted=!0}sort(){if(this.sorted)return;const e=this.orderBy;for(const t of this.entities)t.__sortKey=e(t);this.entities.sort(((e,t)=>e.__sortKey<t.__sortKey?-1:e.__sortKey>t.__sortKey?1:0));for(let e=0;e<this.entities.length;e++)this.lookupTable[this.entities[e].__id]=e;this.sorted=!0}}var F;!function(e){e[e.current=1]="current",e[e.added=2]="added",e[e.removed=4]="removed",e[e.changed=8]="changed",e[e.addedOrChanged=16]="addedOrChanged",e[e.changedOrRemoved=32]="changedOrRemoved",e[e.addedChangedOrRemoved=64]="addedChangedOrRemoved"}(F||(F={}));const D=F.added|F.removed|F.changed|F.addedOrChanged|F.changedOrRemoved|F.addedChangedOrRemoved,j=F.changed|F.addedOrChanged|F.changedOrRemoved|F.addedChangedOrRemoved,V=F.added|F.removed|F.addedOrChanged|F.changedOrRemoved|F.addedChangedOrRemoved;class U{system;results={};flavors=0;withMask;withValues;withAnyRecords;withoutMask;withoutEnumTypes;trackWritesMask;orderBy;hasTransientResults;hasChangedResults;hasShapeResults;hasMatchTracking;currentEntities;processedEntities;changedEntities;constructor(e,t){this.system=t,e.__results=this.results,e.__systemName=t.name}complete(){const e=this.system.dispatcher;this.hasTransientResults=Boolean(this.flavors&D),this.hasChangedResults=Boolean(this.flavors&j),this.hasShapeResults=Boolean(this.flavors&V),this.hasMatchTracking=Boolean(this.withAnyRecords?.some((e=>e.lastMatches)));{if(this.withMask&&this.withoutMask){const e=Math.min(this.withMask.length,this.withoutMask.length);for(let t=0;t<e;t++)if(0!=(this.withMask[t]&this.withoutMask[t]))throw new o("Query must not list a component type in both `with` and `without` clauses")}if(this.withAnyRecords&&this.withoutMask)for(const{mask:e}of this.withAnyRecords){const t=Math.min(e.length,this.withoutMask.length);for(let s=0;s<t;s++)if(0!=(e[s]&this.withoutMask[s]))throw new o("Query must not list a component type in both `withAny` and `without` clauses")}const e=!!this.trackWritesMask||this.withAnyRecords?.some((e=>e.lastMatches));if(this.hasChangedResults&&!e)throw new o("Query for changed entities must track at least one component");if(!this.hasChangedResults&&e)throw new o("You can only track components if you have a query for changed entities")}this.flavors&F.current?this.results.current=new N(e.registry.pool,this.orderBy,e.maxEntities):this.currentEntities=new L(e.maxEntities),this.processedEntities=new L(e.maxEntities),this.hasTransientResults&&this.allocateTransientResultLists(),this.flavors&&this.system.shapeQueries.push(this),this.hasChangedResults&&(this.changedEntities=new L(e.maxEntities),this.system.writeQueries.push(this))}allocateTransientResultLists(){this.flavors&F.added&&this.allocateResult("added"),this.flavors&F.removed&&this.allocateResult("removed"),this.flavors&F.changed&&this.allocateResult("changed"),this.flavors&F.addedOrChanged&&this.allocateResult("addedOrChanged"),this.flavors&F.changedOrRemoved&&this.allocateResult("changedOrRemoved"),this.flavors&F.addedChangedOrRemoved&&this.allocateResult("addedChangedOrRemoved")}allocateResult(e){const t=this.system.dispatcher;this.results[e]=new B(t.registry.pool,this.orderBy)}clearTransientResults(){this.hasTransientResults&&(this.results.added?.clear(),this.results.removed?.clear(),this.results.changed?.clear(),this.results.addedOrChanged?.clear(),this.results.changedOrRemoved?.clear(),this.results.addedChangedOrRemoved?.clear(),this.changedEntities?.clear())}clearAllResults(){this.clearTransientResults(),this.results.current?.clear()}clearProcessedEntities(){this.processedEntities.clear()}handleShapeUpdate(e){if(this.processedEntities.get(e))return;this.processedEntities.set(e);const t=this.system.dispatcher.registry,s=this.results.current?.has(e)??this.currentEntities.get(e),i=t.matchShape(e,this.withMask,this.withValues,this.withAnyRecords,this.withoutMask,this.withoutEnumTypes);if(i&&!s)this.currentEntities?.set(e),this.changedEntities?.set(e),this.results.current?.add(e),this.results.added?.add(e),this.results.addedOrChanged?.add(e),this.results.addedChangedOrRemoved?.add(e);else if(!i&&s)this.currentEntities?.unset(e),this.changedEntities?.set(e),this.results.current?.remove(e),this.results.removed?.add(e),this.results.changedOrRemoved?.add(e),this.results.addedChangedOrRemoved?.add(e);else if(i&&s&&this.hasMatchTracking)for(const t of this.withAnyRecords)if(t.changed){this.changedEntities.set(e),this.results.changed?.add(e),this.results.addedOrChanged?.add(e),this.results.changedOrRemoved?.add(e),this.results.addedChangedOrRemoved?.add(e);break}}handleWrite(e,t,s){!this.changedEntities.get(e)&&(this.hasShapeResults?this.results.current?.has(e)??this.currentEntities.get(e):this.system.dispatcher.registry.matchShape(e,this.withMask,this.withValues,this.withAnyRecords,this.withoutMask,this.withoutEnumTypes))&&(this.trackWritesMask[t]??0)&s&&(this.changedEntities.set(e),this.results.changed?.add(e),this.results.addedOrChanged?.add(e),this.results.changedOrRemoved?.add(e),this.results.addedChangedOrRemoved?.add(e))}sort(){this.results.current?.sort(),this.results.added?.sort(),this.results.removed?.sort(),this.results.changed?.sort(),this.results.addedOrChanged?.sort(),this.results.changedOrRemoved?.sort(),this.results.addedChangedOrRemoved?.sort()}}class q{__callback;__userQuery;__query;__system;__lastTypes;__lastWasWithAny;constructor(e,t){this.__callback=e,this.__userQuery=t}__build(e){try{this.__system=e,this.__query=new U(this.__userQuery,e),this.__callback(this),!this.__query.withMask&&this.__query.flavors&&this.set("withMask",[this.__system.dispatcher.registry.Alive]),this.__query.complete()}catch(t){throw t.message=`Failed to build query in system ${e.name}: ${t.message}`,t}}get and(){return this}get but(){return this}get also(){return this}get current(){return this.__query.flavors|=F.current,this}get added(){return this.__query.flavors|=F.added,this}get removed(){return this.__query.flavors|=F.removed,this}get changed(){return this.__query.flavors|=F.changed,this}get addedOrChanged(){return this.__query.flavors|=F.addedOrChanged,this}get changedOrRemoved(){return this.__query.flavors|=F.changedOrRemoved,this}get addedChangedOrRemoved(){return this.__query.flavors|=F.addedChangedOrRemoved,this}orderBy(e){return this.__query.orderBy=e,this}with(...e){return this.set(this.__system.accessMasks.read,e),this.set("withMask"),this}withAny(...e){for(const t of e)if("function"==typeof t&&t.enum)throw new o(`Cannot use enum types in a withAny clause: ${t.name}`);this.set(this.__system.accessMasks.read,e),this.__query.withAnyRecords||(this.__query.withAnyRecords=[]);const t=[];return this.__query.withAnyRecords.push({mask:t,lastMatches:void 0,changed:!1}),this.set(t),this}without(...e){return this.set(this.__system.accessMasks.read,e),this.set("withoutMask"),this}using(...e){return this.__lastTypes=e,this}get usingAll(){return this.__lastTypes=this.__system.dispatcher.registry.types.slice(1),this}get trackWrites(){this.set("trackWritesMask");for(const e of this.__lastTypes)if("function"==typeof e)e.__binding.trackedWrites=!0;else for(const t of e.__types)t.__binding.trackedWrites=!0;return this}get trackMatches(){if(!this.__lastWasWithAny)throw new Error("You can only apply trackMatches to a withAny clause");return this.__query.withAnyRecords[this.__query.withAnyRecords.length-1].lastMatches=[],this}get read(){return this.set(this.__system.accessMasks.read),this}get create(){return this.set(this.__system.accessMasks.create),this}get update(){return this.set(this.__system.accessMasks.update),this}get write(){return this.set(this.__system.accessMasks.write),this.set(this.__system.accessMasks.read),this.set(this.__system.accessMasks.create),this.set(this.__system.accessMasks.update),this}set(e,t){if(!e)return;if(t)for(const e of t)x(e);if(t||(t=this.__lastTypes),!t)throw new a("No component type to apply query modifier to");this.__lastTypes=t,"string"==typeof e&&(this.__query[e]||(this.__query[e]=[]),e=this.__query[e]),this.__lastWasWithAny=this.__query.withAnyRecords?.some((t=>t.mask===e))??!1;const s=e===this.__system.accessMasks.read,i=e===this.__system.accessMasks.update,r=e===this.__system.accessMasks.create,n=e===this.__system.accessMasks.write,h=e===this.__query.withMask,c=e===this.__query.withoutMask,d=e===this.__query.withMask||e===this.__query.withoutMask||this.__lastWasWithAny,l=e===this.__query.trackWritesMask,u=s?this.__system.dispatcher.planner.readers:n||r||i?this.__system.dispatcher.planner.writers:void 0;for(const i of t){if(!M(this.__system.accessMasks.write,i)&&(s&&M(this.__system.accessMasks.create,i)||r&&M(this.__system.accessMasks.read,i)))throw new o(`Cannot combine create and read entitlements for component type ${i.name}; just use a write entitlement instead`);if(c&&"function"==typeof i&&i.enum?(this.__query.withoutEnumTypes=this.__query.withoutEnumTypes??[],this.__query.withoutEnumTypes.push(i)):(A(e,i),h&&(this.__query.withValues||(this.__query.withValues=[]),A(this.__query.withValues,i,!0))),s&&A(this.__system.accessMasks.check,i),"function"==typeof i)u&&u.get(i).add(this.__system),d&&this.categorize(this.__system.shapeQueriesByComponent,i),l&&this.categorize(this.__system.writeQueriesByComponent,i);else for(const e of i.__types)u&&u.get(e).add(this.__system),d&&this.categorize(this.__system.shapeQueriesByComponent,e),l&&this.categorize(this.__system.writeQueriesByComponent,e)}}categorize(e,t){const s=t.id;e[s]||(e[s]=[]),e[s].includes(this.__query)||e[s].push(this.__query)}}class W{__results;__systemName;get current(){return this.__checkList("current"),this.__results.current.entities}get added(){return this.__checkList("added"),this.__results.added.entities}get removed(){return this.__checkList("removed"),this.__results.removed.entities}get changed(){return this.__checkList("changed"),this.__results.changed.entities}get addedOrChanged(){return this.__checkList("addedOrChanged"),this.__results.addedOrChanged.entities}get changedOrRemoved(){return this.__checkList("changedOrRemoved"),this.__results.changedOrRemoved.entities}get addedChangedOrRemoved(){return this.__checkList("addedChangedOrRemoved"),this.__results.addedChangedOrRemoved.entities}__checkList(e){if(!this.__results[e])throw new o(`Query '${e}' not configured, please add .${e} to your query definition in system ${this.__systemName}`)}}const Q="undefined"!=typeof window&&void 0!==window.performance?performance.now.bind(performance):Date.now.bind(Date);class z{__callback;__schedule;__systems;__dispatcher;constructor(e,t){this.__callback=e,this.__schedule=t}__build(e,t){try{this.__systems=e,this.__dispatcher=e[0].dispatcher,this.__callback(this)}catch(e){throw e.message=`Failed to build schedule in ${t}: ${e.message}`,e}}get allSystems(){return this.__dispatcher.defaultGroup}get onMainThread(){return this.__checkNoLaneAssigned(),this.__dispatcher.planner.mainLane?.add(...this.__systems),this}get onOneThread(){return this.__checkNoLaneAssigned(),this.__dispatcher.planner.createLane().add(...this.__systems),this}get onManyThreads(){this.__checkNoLaneAssigned(),this.__dispatcher.planner.replicatedLane?.add(...this.__systems);for(const e of this.__systems)e.stateless=!0;return this}__checkNoLaneAssigned(){if(this.__systems.some((e=>e.lane)))throw new o("Threading semantics already specified")}before(...e){const t=new Set(this.__systems);for(const s of e)for(const e of this.__dispatcher.getSystems(s))if(!t.has(e))for(const t of this.__systems)this.__dispatcher.planner.graph.addEdge(t,e,5);return this}after(...e){const t=new Set(this.__systems);for(const s of e)for(const e of this.__dispatcher.getSystems(s))if(!t.has(e))for(const t of this.__systems)this.__dispatcher.planner.graph.addEdge(e,t,5);return this}inAnyOrderWith(...e){for(const t of e)for(const e of this.__dispatcher.getSystems(t))for(const t of this.__systems)this.__dispatcher.planner.graph.denyEdge(t,e,4);return this}beforeReadersOf(...e){for(const t of e)for(const e of this.__dispatcher.planner.readers.get(t))for(const t of this.__systems)this.__dispatcher.planner.graph.addEdge(t,e,3);return this}afterReadersOf(...e){for(const t of e)for(const e of this.__dispatcher.planner.readers.get(t))for(const t of this.__systems)this.__dispatcher.planner.graph.addEdge(e,t,3);return this}beforeWritersOf(...e){for(const t of e)for(const e of this.__dispatcher.planner.writers.get(t))for(const t of this.__systems)this.__dispatcher.planner.graph.addEdge(t,e,3);return this}afterWritersOf(...e){for(const t of e)for(const e of this.__dispatcher.planner.writers.get(t))for(const t of this.__systems)this.__dispatcher.planner.graph.addEdge(e,t,3);return this}inAnyOrderWithReadersOf(...e){for(const t of e)for(const e of this.__dispatcher.planner.readers.get(t))for(const t of this.__systems)this.__dispatcher.planner.graph.denyEdge(e,t,2);return this}inAnyOrderWithWritersOf(...e){for(const t of e)for(const e of this.__dispatcher.planner.writers.get(t))for(const t of this.__systems)this.__dispatcher.planner.graph.denyEdge(e,t,2);return this}}class G{}class K{__contents;__plan;__executed=!1;__systems;__scheduleBuilder;constructor(e){this.__contents=e}__collectSystems(e){if(!this.__systems){this.__systems=[];for(const t of this.__contents)t instanceof Function&&t.__system?this.__systems.push(e.systemsByClass.get(t)):t instanceof K&&this.__systems.push(...t.__collectSystems(e))}return this.__systems}__buildSchedule(){this.__scheduleBuilder?.__build(this.__systems,"a group"),this.__scheduleBuilder=null}schedule(e){if(null===this.__scheduleBuilder)throw new o("Attempt to define group schedule after world initialized");if(this.__scheduleBuilder)throw new o("Attempt to define multiple schedules in a group");return this.__scheduleBuilder=new z(e,new G),this}}class Y{dispatcher;groups;executing;time=Q()/1e3;delta;constructor(e,t){if(this.dispatcher=e,this.groups=t,0===t.length)throw new o("At least one system group needed");for(const s of t)if(!e.systemGroups.includes(s))throw new o("Some groups in the frame are not parts of the world defs")}async begin(){if(this.executing)throw new o("Frame already executing");this.executing=!0;const e=this.dispatcher.lastTime??this.time;this.time=Q()/1e3,this.delta=this.time-e,this.dispatcher.startFrame(this.time)}async end(){if(!this.executing)throw new o("Frame not executing");this.executing=!1;e:{for(const e of this.groups)if(!e.__executed)break e;for(const e of this.groups)e.__executed=!1;this.dispatcher.completeCycle()}await this.dispatcher.completeFrame()}execute(e,t,s){if(!this.groups.includes(e))throw new o("Group not included in this frame");if(!this.executing)throw new o("Frame not executing");return e.__plan.execute(t??this.time,s??this.delta)}}class H extends Error{canceled=!0;constructor(){super("Canceled")}}let J;class X{__generator;__fn;__supervisor;__cancellers=[];__blocker;__scope;__done=!1;__awaited=!1;__error;__value;__firstRun=!0;constructor(e,t,s){this.__generator=e,this.__fn=t,this.__supervisor=s}__checkCancelation(){if(!this.__done)for(const e of this.__cancellers)if(e()){this.cancel();break}}__step(){J=this;try{if(!this.__done&&(this.__blocker?.isReady()??1))try{let e;if(this.__blocker?.error)e=this.__generator.throw(this.__blocker.error);else if(this.__firstRun)try{e=this.__generator.next(this.__blocker?.value)}finally{this.__firstRun=!1,this.__supervisor.cancelMatching(this,this.__scope,this.__fn)}else e=this.__generator.next(this.__blocker?.value);e.done?(this.__done=!0,this.__value=e.value,this.__blocker=void 0):(this.__blocker=e.value,this.__blocker?.markAwaited?.())}catch(e){this.__done=!0,this.__error||(this.__error=e),this.__blocker=void 0}if(this.__error&&!(this.__awaited||this.__error instanceof H))throw this.__error}finally{J=void 0}}isReady(){return this.__done}get value(){return this.__value}get error(){return this.__error}markAwaited(){this.__awaited=!0}waitForFrames(e){if(e<=0)throw new o("Number of frames to wait for must be >0");return{isReady:()=>--e<=0}}waitForSeconds(e){const t=this.__supervisor.system,s=t.time+e;return{isReady:()=>t.time>=s}}waitUntil(e){return{isReady:e}}cancel(){return this.__blocker?.cancel?this.__blocker.cancel():(this.__error=new H,this.__done=!0),this}cancelIf(e){return this.__cancellers.push(e),this}scope(e){if(this.__scope)throw new o("Scope already set for this coroutine");if(this.__cancellers.length)throw new o("Scope must be set before any cancelation conditions");return this.__scope=e,this.cancelIf((()=>!e.alive)),this}cancelIfComponentMissing(e){if(!this.__scope)throw new o("Required scope not set for this coroutine");return this.cancelIf((()=>!this.__scope?.has(e))),this}cancelIfCoroutineStarted(e){return this.__supervisor.registerCancelIfStarted(this,this.__scope,e===Z.self?this.__fn:e),this}return(e){throw new o("Generator methods not available for coroutines")}throw(e){throw new o("Generator methods not available for coroutines")}next(...e){throw new o("Generator methods not available for coroutines")}[Symbol.iterator](){throw new o("Generator methods not available for coroutines")}}function Z(e,t,s){const i=s.value;return{value(...e){return this.start(i,...e)}}}function ee(){if(!J)throw new o("Cannot call co methods outside coroutine context")}Z.waitForFrames=function(e){return ee(),J.waitForFrames(e)},Z.waitForSeconds=function(e){return ee(),J.waitForSeconds(e)},Z.waitUntil=function(e){return ee(),J.waitUntil(e)},Z.cancel=function(){ee(),J.cancel()},Z.cancelIf=function(e){return ee(),J.cancelIf(e)},Z.scope=function(e){return ee(),J.scope(e)},Z.cancelIfComponentMissing=function(e){return ee(),J.cancelIfComponentMissing(e)},Z.cancelIfCoroutineStarted=function(e){return ee(),J.cancelIfCoroutineStarted(e)},Z.self=function*(){yield};class te{system;coroutines=[];mutuallyExclusiveCoroutines=new Map;constructor(e){this.system=e}start(e,...t){const s=new X(e.apply(this.system,t),e,this);return this.coroutines.push(s),s}execute(){let e=0;for(;e<this.coroutines.length;){const t=e;e=this.coroutines.length;for(let s=e-1;s>=t;s--)this.system.accessRecentlyDeletedData(!1),this.coroutines[s].__checkCancelation();for(let s=e-1;s>=t;s--){this.system.accessRecentlyDeletedData(!1);const t=this.coroutines[s];t.__step(),t.isReady()&&(this.coroutines.splice(s,1),e-=1)}}}registerCancelIfStarted(e,t,s){const i=(t?.__id??"")+(s?.name??"");this.mutuallyExclusiveCoroutines.has(i)||this.mutuallyExclusiveCoroutines.set(i,[]),this.mutuallyExclusiveCoroutines.get(i)?.push(e)}cancelMatching(e,t,s){this.cancelMatchingKey(e,""),this.cancelMatchingKey(e,s.name),t&&(this.cancelMatchingKey(e,""+t.__id),this.cancelMatchingKey(e,""+t.__id+s.name))}cancelMatchingKey(e,t){const s=this.mutuallyExclusiveCoroutines.get(t);if(s){let t=!1;for(const i of s)i===e?t=!0:i.cancel();s.length=0,t&&s.push(e)}}}var se;!function(e){e[e.RUNNING=0]="RUNNING",e[e.STOPPED=1]="STOPPED"}(se||(se={}));class ie{access;type;initialValues;constructor(e,t,s){this.access=e,this.type=t,this.initialValues=s}}class re{type;constructor(e){this.type=e}}class ne{static __system=!0;static group(...e){return new K(e)}__queryBuilders=[];__scheduleBuilder;__attachPlaceholders=[];__singletonPlaceholders=[];__supervisor=new te(this);__dispatcher;id;time;delta;get name(){return this.constructor.name}query(e){const t=new W,s=new q(e,t);if(!this.__queryBuilders)throw new o(`Attempt to create a new query after world initialized in system ${this.name}`);return this.__queryBuilders.push(s),t}schedule(e){if(null===this.__scheduleBuilder)throw new o(`Attempt to define schedule after world initialized in system ${this.name}`);if(this.__scheduleBuilder)throw new o(`Attempt to define multiple schedules in system ${this.name}`);const t=new G;return this.__scheduleBuilder=new z(e,t),t}attach(e){if(!this.__attachPlaceholders)throw new o(`Attempt to attach a system after world initialized in system ${this.name}`);const t=new re(e);return this.__attachPlaceholders.push(t),t}createEntity(...e){return this.__dispatcher.createEntity(e)}accessRecentlyDeletedData(e=!0){this.__dispatcher.registry.includeRecentlyDeleted=e}start(e,...t){return this.__supervisor.start(e,...t)}async prepare(){}initialize(){}execute(){}finalize(){}}Object.defineProperty(ne.prototype,"singleton",{get(){const e=this,t={read(t){if(!e.__singletonPlaceholders)throw new o(`Attempt to declare a singleton after world initialized in system ${e.name}`);R(t),e.query((e=>e.using(t).read));const s=new ie("read",t);return e.__singletonPlaceholders.push(s),s},write(t,s){if(!e.__singletonPlaceholders)throw new o(`Attempt to declare a singleton after world initialized in system ${e.name}`);R(t),e.query((e=>e.using(t).write));const i=new ie("write",t,s);return e.__singletonPlaceholders.push(i),i}};return Object.defineProperty(this,"singleton",{value:t,configurable:!0}),t}});class ae{system;dispatcher;get id(){return this.system.id}get name(){return this.system.name}toString(){return this.name}constructor(e,t){this.system=e,this.dispatcher=t,e.__dispatcher=t,this.accessMasks={read:[],update:[],create:[],write:[],check:[]},this.shapeQueries=[],this.shapeQueriesByComponent=[],this.writeQueries=[],this.writeQueriesByComponent=[],this.state=se.RUNNING,this.propsAssigned=!1,this.stateless=!1,this.weight=1,this.shapeLogPointer=t.shapeLog.createPointer(),this.stats=t.stats.forSystem(e.constructor),this.attachedSystems=this.system.__attachPlaceholders.map((e=>this.dispatcher.systemsByClass.get(e.type))),this.singletonComponentDefs=this.system.__singletonPlaceholders.flatMap((e=>e.initialValues?[e.type,e.initialValues]:[e.type])),this.singletonStandingWrites=this.system.__singletonPlaceholders.filter((e=>"write"===e.access)).map((e=>e.type))}assignProps(e){if(this.propsAssigned)throw new o(`System ${this.name} has multiple props assigned in world defs`);Object.assign(this.system,e),this.propsAssigned=!0}buildQueries(){for(const e of this.system.__queryBuilders)e.__build(this);this.system.__queryBuilders=null,this.hasNegativeQueries=!!this.shapeQueriesByComponent[this.dispatcher.registry.Alive.id],this.hasWriteQueries=!!this.writeQueries.length,this.hasTransientQueries=this.shapeQueries.some((e=>e.hasTransientResults))}buildSchedule(){const e=this.system.constructor.__staticScheduler;e&&this.system.schedule(e),this.system.__scheduleBuilder?.__build([this],`system ${this.name}`),this.system.__scheduleBuilder=null}finishConstructing(){this.writeLogPointer=this.dispatcher.writeLog?.createPointer(),this.singletonStandingWrites=this.singletonStandingWrites.filter((e=>e.__binding.trackedWrites))}replacePlaceholders(){const e=this.system;for(const t in this.system){const s=e[t];if(s instanceof re){const i=s.type,r=this.dispatcher.systemsByClass.get(i);if(!r)throw new o(`Attached system ${i.name} not defined in this world`);e[t]=r.system}else s instanceof ie&&(e[t]=this.dispatcher.singleton[s.access](s.type))}this.system.__attachPlaceholders=null,this.system.__singletonPlaceholders=null,this.dispatcher.singleton&&Object.defineProperty(this.system,"singleton",{value:this.dispatcher.singleton})}prepare(){return this.system.prepare()}initialize(){this.dispatcher.registry.executingSystem=this,this.system.initialize(),this.trackStandingWrites()}finalize(){this.dispatcher.registry.executingSystem=this,this.system.finalize(),this.trackStandingWrites()}execute(e,t){if(this.state!==se.RUNNING)return;let s,i,r,n;this.dispatcher.registry.executingSystem=this,this.system.time=e,this.system.delta=t,s=Q(),this.runQueries(),i=Q(),this.system.execute(),r=Q(),this.system.__supervisor.execute(),this.trackStandingWrites(),n=Q(),this.stats.lastQueryUpdateDuration=i-s,this.stats.lastExecutionDuration=r-i,this.stats.lastCoroutinesDuration=n-r}trackStandingWrites(){const e=this.dispatcher.singleton;for(const t of this.singletonStandingWrites)this.dispatcher.registry.trackWrite(e.__id,t)}runQueries(){const e=this.ranQueriesLastFrame;this.ranQueriesLastFrame=!1;const t=this.dispatcher.shapeLog.hasUpdatesSince(this.shapeLogPointer),s=this.hasWriteQueries&&this.dispatcher.writeLog.hasUpdatesSince(this.writeLogPointer);if(t||s||this.hasTransientQueries&&e){if(this.hasTransientQueries)for(const e of this.shapeQueries)e.clearTransientResults();if(t||s){this.ranQueriesLastFrame=!0,t&&this.__updateShapeQueries(),s&&this.__updateWriteQueries();for(const e of this.shapeQueries)e.sort()}}}__updateShapeQueries(){const e=this.dispatcher.shapeLog;if(!this.shapeQueries.length)return void e.createPointer(this.shapeLogPointer);for(const e of this.shapeQueries)e.clearProcessedEntities();let t,s,o,h,c=0;for(;[s,o,h]=e.processSince(this.shapeLogPointer),s;){c&&!t&&(o+=c,c=0);for(let e=o;e<h;e++){const o=s[e],d=o&r;if(!t){const s=o>>>i&n,r=o&2**31;if(t=this.shapeQueriesByComponent[s],r){if(c=d,!t){const t=Math.min(c,h-e);e+=t,c-=t}continue}if(!t)continue;c=1}if(o&2**31)throw new a("Trying to process run header as entry in shape log");for(let e=0;e<t.length;e++)t[e].handleShapeUpdate(d);0==--c&&(t=void 0)}}}__updateWriteQueries(){const e=this.dispatcher.writeLog;if(!this.writeQueries.length)return void e.createPointer(this.writeLogPointer);let t,s,o,h,c,d,l=0;for(;[h,c,d]=e.processSince(this.writeLogPointer),h;){l&&!t&&(c+=l,l=0);for(let e=c;e<d;e++){const c=h[e],u=c&r;if(!t){const r=c>>>i&n,a=c&2**31;if(s=r>>5,o=1<<(31&r),t=this.writeQueriesByComponent[r],a){if(l=u,!t){const t=Math.min(l,d-e);e+=t,l-=t}continue}if(!t)continue;l=1}if(c&2**31)throw new a("Trying to process run header as entry in write log");for(let e=0;e<t.length;e++)t[e].handleWrite(u,s,o);0==--l&&(t=void 0)}}}stop(){if(this.state!==se.STOPPED){this.state=se.STOPPED;for(const e of this.shapeQueries)e.clearAllResults()}}restart(){if(this.state===se.STOPPED){const e=this.dispatcher.registry,t=e.Alive;for(const e of this.shapeQueries)e.clearProcessedEntities();for(let s=0;s<this.dispatcher.maxEntities;s++)if(e.hasShape(s,t,!1))for(const e of this.shapeQueries)e.handleShapeUpdate(s);for(const e of this.shapeQueries)e.clearTransientResults(),e.sort();this.dispatcher.shapeLog.createPointer(this.shapeLogPointer),this.dispatcher.writeLog?.createPointer(this.writeLogPointer)}this.state=se.RUNNING}}class oe{name;__types;__binding;constructor(e,t){this.name=e,this.__types=Array.from(new Set(t))}}class he{maxItems;configParamName;data;constructor(e,t){this.maxItems=e,this.configParamName=t,this.data=new Uint32Array(new ArrayBuffer((e+2)*Uint32Array.BYTES_PER_ELEMENT))}get length(){return this.data[0]}take(){const e=--this.data[0];if(e<0)throw new RangeError(`Pool capacity exceeded, please raise ${this.configParamName} above ${this.maxItems}`);return this.data[e+2]}return(e){if(this.length>=this.maxItems)throw new a("Internal error, returned entity ID exceeded pool capacity");this.data[this.length+2]=e,this.data[0]+=1}mark(){this.data[1]=this.data[0]}peekSinceMark(e){const t=this.data[1]+e;if(t<this.data[0])return this.data[t+2]}refill(e){if(!e.length)return;const t=this.length,s=t+e.length;if(s>this.maxItems)throw new a("Internal error, returned entity ID exceeded pool capacity");this.data.set(e,t+2),this.data[0]=s}fillWithDescendingIntegers(e){const t=this.length+2;for(let s=this.data.length-1;s>=t;s--)this.data[s]=e++;this.data[0]=this.data.length-2}}class ce{maxItems;configParamName;data;constructor(e,t,s){this.maxItems=e,this.configParamName=t,s.register(`pool.${t}`,e+2,Uint32Array,(e=>{this.data=e}))}get length(){return this.data[0]}take(){const e=Atomics.sub(this.data,0,1);if(e<0)throw new RangeError(`Pool capacity exceeded, please raise ${this.configParamName} above ${this.maxItems}`);return this.data[e+2]}return(e){if(this.length>=this.maxItems)throw new a("Internal error, returned entity ID exceeded pool capacity");this.data[this.length+2]=e,this.data[0]+=1}mark(){this.data[1]=this.data[0]}peekSinceMark(e){const t=this.data[1]+e;if(t<this.data[0])return this.data[t+2]}refill(e){if(!e.length)return;const t=this.length,s=t+e.length;if(s>this.maxItems)throw new a("Internal error, returned entity ID exceeded pool capacity");this.data.set(e,t+2),this.data[0]=s}fillWithDescendingIntegers(e){const t=this.length+2;for(let s=this.data.length-1;s>=t;s--)this.data[s]=e++;this.data[0]=this.data.length-2}}class de{stride;array;constructor(e,t,s,i){this.stride=Math.ceil(t/32),i.register(e,s*this.stride,Uint32Array,(e=>{this.array=e}))}syncThreads(){}set(e,t){const s=t.__binding,i=e*this.stride+s.shapeOffset,r=s.shapeMask,n=s.shapeValue;this.array[i]&=~r,this.array[i]|=n}unset(e,t){const s=t.__binding,i=e*this.stride+s.shapeOffset,r=s.shapeMask;this.array[i]&=~r}isSet(e,t){const s=t.__binding,i=e*this.stride+s.shapeOffset,r=s.shapeMask,n=s.shapeValue;return(this.array[i]&r)===n}get(e,t){const s=t.__binding,i=e*this.stride+s.shapeOffset,r=s.shapeMask;return(this.array[i]&r)>>>s.shapeShift}clear(){this.array.fill(0)}match(e,t,s){if(t.length!==s.length)throw new a(`Mismatched mask and value lengths: ${t.length} vs ${s.length}`);const i=this.array,r=e*this.stride;for(let e=0;e<t.length;e++)if((i[r+e]&t[e])!==s[e])return!1;return!0}matchNot(e,t){const s=this.array,i=e*this.stride;for(let e=0;e<t.length;e++)if(0!=(s[i+e]&t[e]))return!1;return!0}matchAny(e,t){t.changed=!1;const s=t.mask,i=t.lastMatches[e]=t.lastMatches[e]||[],r=this.array,n=e*this.stride;let a=!1;for(let e=0;e<s.length;e++){const o=r[n+e]&s[e];0!==o&&(a=!0),o!==i[e]&&(t.changed=!0),i[e]=o}return a||delete t.lastMatches[e],a}}class le{stride;array;constructor(e,t,s,i){this.stride=Math.ceil(t/32),i.register(e,s*this.stride,Uint32Array,(e=>{this.array=e}))}syncThreads(){Atomics.load(this.array,0)}set(e,t){const s=t.__binding,i=e*this.stride+s.shapeOffset,r=s.shapeMask,n=s.shapeValue;r!==n&&Atomics.and(this.array,i,~r),Atomics.or(this.array,i,n)}unset(e,t){const s=t.__binding,i=e*this.stride+s.shapeOffset,r=s.shapeMask;Atomics.and(this.array,i,~r)}isSet(e,t){const s=t.__binding,i=e*this.stride+s.shapeOffset,r=s.shapeMask,n=s.shapeValue;return 0===t.id?(Atomics.load(this.array,i)&r)===n:(this.array[i]&r)===n}get(e,t){const s=t.__binding,i=e*this.stride+s.shapeOffset,r=s.shapeMask;return(this.array[i]&r)>>>s.shapeShift}clear(){this.array.fill(0)}match(e,t,s){if(t.length!==s.length)throw new a(`Mismatched mask and value lengths: ${t.length} vs ${s.length}`);const i=this.array,r=e*this.stride;for(let e=0;e<t.length;e++)if((i[r+e]&t[e])!==s[e])return!1;return!0}matchNot(e,t){const s=this.array,i=e*this.stride;for(let e=0;e<t.length;e++)if(0!=(s[i+e]&t[e]))return!1;return!0}matchAny(e,t){t.changed=!1;const s=t.mask,i=t.lastMatches[e]=t.lastMatches[e]||[],r=this.array,n=e*this.stride;for(let a=0;a<s.length;a++){const o=r[n+a]&s[a];if(0===o)return delete t.lastMatches[e],!1;o!==i[a]&&(t.changed=!0),i[a]=o}return!0}}const ue=[EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,AggregateError,o,a];class fe{registry;borrowed;borrowCounts;spares=[];temporarilyBorrowedIds=[];constructor(e,t){this.registry=e,this.borrowed=Array.from({length:t}),this.borrowCounts=new Int32Array(t)}borrow(e){this.borrowCounts[e]+=1;let t=this.borrowed[e];return t||(t=this.borrowed[e]=this.spares.pop()??new P(this.registry),t.__id=e),t}borrowTemporarily(e){const t=this.borrow(e);return this.temporarilyBorrowedIds.push(e),t}returnTemporaryBorrows(){for(const e of this.temporarilyBorrowedIds)this.return(e);this.temporarilyBorrowedIds.length=0}return(e){if(!this.borrowCounts[e])throw new a("Returning entity with no borrows");if(--this.borrowCounts[e]<=0){const t=this.borrowed[e];return this.borrowed[e]=void 0,void(t.__valid=!1)}}}class pe{types;enums;dispatcher;allocationItems;numShapeBits=0;shapes;staleShapes;removedShapes;entityIdPool;pool;heldEntities;validators;reshapedEntityIds=[];validateSystem;executingSystem;includeRecentlyDeleted=!1;hasNegativeQueries=!1;nextEntityOrdinal=0;entityOrdinals;removalLog;prevRemovalPointer;oldRemovalPointer;Alive=class{static __internal=!0};constructor(e,t,s,i,r){this.types=s,this.enums=i,this.dispatcher=r,this.allocationItems=this.prepareComponentTypesAndEnums();for(const e of this.allocationItems)this.numShapeBits+=e.size;const n=r.threaded?le:de;this.shapes=new n("registry.shapes",this.numShapeBits,e,r.buffers),this.staleShapes=new n("registry.staleShapes",this.numShapeBits,e,r.buffers),this.removedShapes=new n("registry.removedShapes",this.numShapeBits,e,r.buffers),this.entityIdPool=r.threaded?new ce(e,"maxEntities",r.buffers):new he(e,"maxEntities"),this.entityOrdinals=r.buffers.register("registry.entityOrdinals",e,Uint32Array,(e=>{this.entityOrdinals=e})),this.entityIdPool.fillWithDescendingIntegers(0),this.pool=new fe(this,e),this.heldEntities=[],this.validators=[],this.removalLog=new T(t,"maxLimboComponents",r.buffers),this.prevRemovalPointer=this.removalLog.createPointer(),this.oldRemovalPointer=this.removalLog.createPointer()}initializeComponentTypes(){let e=0,t=0;for(;this.allocationItems.length;){const s=e%32,i=this.removeBiggestNoLargerThan(32-s);if(!i){e+=32-s;continue}const r={offset:e>>>5,mask:(1<<i.size)-1<<s,value:1<<s};if(e+=i.size,i.typeOrEnum instanceof oe){const e=i.typeOrEnum;e.__binding={shapeOffset:r.offset,shapeMask:r.mask,shapeShift:s};for(const i of e.__types)C(t++,i,r,this.dispatcher),i.validate&&this.validators.push(i),r.value+=1<<s}else{const e=i.typeOrEnum;C(t++,e,r,this.dispatcher),e.validate&&this.validators.push(e)}}for(const e of this.types)S(e);{const e=this.Alive.__binding;if(0!==e.shapeOffset||1!==e.shapeMask||1!==e.shapeValue)throw new a("Alive component was not assigned first available shape mask")}}prepareComponentTypesAndEnums(){const e=[],t=new Set,s=new Set;let i=0;for(const e of this.types){if(e.name||Object.defineProperty(e,"name",{value:"Anonymous_"+i++}),!e.__internal){if(s.has(e.name))throw new o(`Multiple component types named ${e.name}; names must be unique`);s.add(e.name)}if(e.enum){if(!this.enums.includes(e.enum))throw new o(`Component type ${e.name} references an enum that's not in the world's defs`);e.enum.__types.includes(e)||e.enum.__types.push(e)}this.dispatcher.stats.forComponent(e)}for(const s of this.enums){if(s.__types.length>2**31)throw new o(`Too many types in enum: ${s.__types.length}`);e.push({typeOrEnum:s,size:Math.ceil(Math.log2(s.__types.length+1))});for(const e of s.__types){if(t.has(e))throw new o(`Component type ${e.name} is a member of more than one enum`);e.enum=s,t.add(e)}}for(const s of this.types)t.has(s)||e.push({typeOrEnum:s,size:1});return e.sort(((e,t)=>t.size-e.size)),this.types.unshift(this.Alive),e.unshift({typeOrEnum:this.Alive,size:1}),e}removeBiggestNoLargerThan(e){const t=this.allocationItems.findIndex((t=>t.size<=e));if(-1!==t)return this.allocationItems.splice(t,1)[0]}releaseComponentTypes(){for(const e of this.types)I(e);for(const e of this.enums)delete e.__binding}createEntity(e){const t=this.entityIdPool.take();this.entityOrdinals[t]=this.nextEntityOrdinal++,this.setShape(t,this.Alive);const s=this.pool.borrowTemporarily(t);return this.createComponents(t,e),this.dispatcher.stats.numEntities+=1,s}createComponents(e,t){for(let s=0;s<t.length;s++){const i=t[s];{if("function"!=typeof i)throw new o(`Bad arguments to createEntity: expected component type, got: ${i}`);x(i);const t=this.executingSystem?.accessMasks.create;if(t){const e=i.__binding;if(0==((t[e.shapeOffset]??0)&e.shapeMask))throw new o(`System ${this.executingSystem?.name} didn't mark component ${i.name} as createable`)}if(i.enum){if(this.getEnumShape(e,i.enum,!1))throw new o("Can't add multiple components from the same enum when creating entity: "+i.name)}else if(this.hasShape(e,i,!1))throw new o(`Duplicate ${i.name} component when creating entity`)}let r=t[s+1];"function"==typeof r?r=void 0:s++,this.setShape(e,i),this.dispatcher.stats.forComponent(i).numEntities+=1,k(i,e,r)}}flush(){const e=this.executingSystem;this.includeRecentlyDeleted=!1,this.validateShapes(e),this.executingSystem=void 0,this.pool.returnTemporaryBorrows(),this.removalLog.commit()}completeCycle(){this.processRemovalLog(),this.invalidateDeletedHeldEntities()}validateShapes(e){this.executingSystem=this.validateSystem;for(const t of this.reshapedEntityIds)for(const s of this.validators)try{s.validate(this.pool.borrowTemporarily(t))}catch(i){if(!ue.includes(i.constructor)){const r=e?` after system ${e.name} executed`:"",n=this.types.filter((e=>e!==this.Alive&&this.hasShape(t,e,!1))).map((e=>e.name)).join(", ")||"none";i.message=`An entity failed to satisfy ${s.name}.validate${r}: ${i.message} (components: ${n})`}throw i}this.reshapedEntityIds.length=0}processRemovalLog(){const e=this.dispatcher.indexer;this.removalLog.commit(),this.entityIdPool.mark();let t,s,a,o=0;for(this.dispatcher.stats.maxLimboComponents=this.removalLog.countSince(this.removalLog.copyPointer(this.oldRemovalPointer));[t,s,a]=this.removalLog.processSince(this.oldRemovalPointer,this.prevRemovalPointer),t;)for(let h=s;h<a;h++){const s=t[h],a=s&r,c=s>>>i&n,d=this.types[c];this.shapes.isSet(a,d)||this.removedShapes.isSet(a,d)||(this.staleShapes.unset(a,d),d===this.Alive?(e.clearAllRefs(a,!0),this.entityIdPool.return(a),o+=1):this.clearRefs(a,d,!0),d.__free?.(a),this.removedShapes.set(a,d))}this.dispatcher.stats.numEntities-=o,this.removedShapes.clear(),this.removalLog.createPointer(this.prevRemovalPointer)}invalidateDeletedHeldEntities(){let e,t=0;for(;void 0!==(e=this.entityIdPool.peekSinceMark(t++));){const t=this.heldEntities[e];t&&(t.__valid=!1,delete this.heldEntities[e])}}holdEntity(e){let t;return t=this.heldEntities[e],t||(t=new P(this),t.__id=e,this.heldEntities[e]=t),t}hasShape(e,t,s){return!!this.shapes.isSet(e,t)||!!(s&&this.includeRecentlyDeleted&&this.staleShapes.isSet(e,t))}getEnumShape(e,t,s){let i=this.shapes.get(e,t);if(0===i&&s&&this.includeRecentlyDeleted&&(i=this.staleShapes.get(e,t)),i>0)return t.__types[i-1]}setShape(e,t){if(t.enum){const s=this.getEnumShape(e,t.enum,!1);s&&this.clearShape(e,s)}this.shapes.set(e,t),this.staleShapes.set(e,t),this.reshapedEntityIds.push(e),(t!==this.Alive||this.hasNegativeQueries)&&this.dispatcher.shapeLog.push(e|t.id<<i,t)}clearShape(e,t){this.clearRefs(e,t,!1),this.shapes.unset(e,t),this.removedShapes.set(e,t),this.reshapedEntityIds.push(e);const s=e|t.id<<i;this.removalLog.push(s),(t!==this.Alive||this.hasNegativeQueries)&&this.dispatcher.shapeLog.push(s,t),this.dispatcher.stats.forComponent(t).numEntities-=1}trackWrite(e,t){this.dispatcher.writeLog.push(e|t.id<<i,t)}clearRefs(e,t,s){if(t.__binding.refFields.length){t.__bind(e,!0);for(const e of t.__binding.refFields)e.clearRef(s)}}matchShape(e,t,s,i,r,n){if(t&&s&&!this.shapes.match(e,t,s))return!1;if(r&&!this.shapes.matchNot(e,r))return!1;if(n)for(const t of n)if(this.shapes.isSet(e,t))return!1;if(i)for(const t of i)if(t.lastMatches){if(!this.shapes.matchAny(e,t))return!1}else if(this.shapes.matchNot(e,t.mask))return!1;return!0}}function me(e,t){return.05*t+.95*e}class ye{type;_numEntities=0;maxEntities=0;capacity=0;constructor(e){this.type=e}get numEntities(){return this._numEntities}set numEntities(e){this._numEntities=e,e>this.maxEntities&&(this.maxEntities=e)}toString(){return`${this.numEntities.toLocaleString()} of ${this.maxEntities.toLocaleString()} peak (capacity ${this.capacity.toLocaleString()})`}}class ge{type;worker;_lastQueryUpdateDuration=0;averageQueryUpdateDuration=0;_lastExecutionDuration=0;averageExecutionDuration=0;_lastCoroutinesDuration=0;averageCoroutinesDuration=0;constructor(e){this.type=e}get lastQueryUpdateDuration(){return this._lastQueryUpdateDuration}set lastQueryUpdateDuration(e){this._lastQueryUpdateDuration=e,this.averageQueryUpdateDuration=me(this.averageQueryUpdateDuration,e)}get lastExecutionDuration(){return this._lastExecutionDuration}set lastExecutionDuration(e){this._lastExecutionDuration=e,this.averageExecutionDuration=me(this.averageExecutionDuration,e)}get lastCoroutinesDuration(){return this._lastCoroutinesDuration}set lastCoroutinesDuration(e){this._lastCoroutinesDuration=e,this.averageCoroutinesDuration=me(this.averageCoroutinesDuration,e)}}class _e{frames=0;_numEntities=0;_maxEntities=0;_maxLimboComponents=0;_maxRefChangesPerFrame=0;_maxShapeChangesPerFrame=0;_maxWritesPerFrame=0;components=Object.create(null);systems=Object.create(null);get maxEntities(){return this._maxEntities}get numEntities(){return this._numEntities}set numEntities(e){this._numEntities=e,e>this._maxEntities&&(this._maxEntities=e)}get maxLimboComponents(){return this._maxLimboComponents}set maxLimboComponents(e){e>this._maxLimboComponents&&(this._maxLimboComponents=e)}get maxRefChangesPerFrame(){return this._maxRefChangesPerFrame}set maxRefChangesPerFrame(e){e>this._maxRefChangesPerFrame&&(this._maxRefChangesPerFrame=e)}get maxShapeChangesPerFrame(){return this._maxShapeChangesPerFrame}set maxShapeChangesPerFrame(e){e>this._maxShapeChangesPerFrame&&(this._maxShapeChangesPerFrame=e)}get maxWritesPerFrame(){return this._maxWritesPerFrame}set maxWritesPerFrame(e){e>this._maxWritesPerFrame&&(this._maxWritesPerFrame=e)}forComponent(e){const t=this.components[e.name]??new ye(e);return e.__internal||(this.components[e.name]=t),t}forSystem(e){const t=this.systems[e.name]??new ge(e);return e.__internal||(this.systems[e.name]=t),t}toString(){return`World stats:\n  frames: ${this.frames.toLocaleString()}\n  entities: ${this.numEntities.toLocaleString()} of ${this.maxEntities.toLocaleString()} max\n  refs: ${this.maxRefChangesPerFrame.toLocaleString()} ref changes/frame max\n  logs: ${this.maxShapeChangesPerFrame.toLocaleString()} shape changes/frame max, ${this.maxWritesPerFrame.toLocaleString()} writes/frame max\n  components: (${this.maxLimboComponents.toLocaleString()} limbo max)\n`+Object.keys(this.components).map((e=>{const t=this.components[e];return`    ${e}: ${t.numEntities} (max ${t.maxEntities})`})).join("\n")}}var we;!function(e){e[e.REFERENCE=0]="REFERENCE",e[e.UNREFERENCE=1073741824]="UNREFERENCE",e[e.RELEASE=2147483648]="RELEASE",e[e.UNREFERENCE_AND_RELEASE=-1073741824]="UNREFERENCE_AND_RELEASE"}(we||(we={}));const be=we.UNREFERENCE_AND_RELEASE;class xe{targetEntityId;selector;trackStale;dispatcher;entities=[];tags;entityIndex;clearing=!1;registry;constructor(e,t,s,i){this.targetEntityId=e,this.selector=t,this.trackStale=s,this.dispatcher=i;const r=t.sourceType?.__binding;t.matchType&&(t.matchSeq&&!r.fields[t.sourceSeq].type.internallyIndexed||1===r.refFields.length&&!r.refFields[0].type.internallyIndexed)||(this.tags=[]),this.registry=i.registry}clearAllRefs(e){if(!this.tags)throw new a("Unreferencing an untagged tracker");this.clearing=!0;for(let t=0;t<this.entities.length;t++){const s=this.entities[t].__id,i=this.tags[t];if("number"==typeof i)this.clearRef(s,i,e);else for(const t of i)this.clearRef(s,t,e)}this.entities=[],this.tags&&(this.tags=[]),this.entityIndex=void 0,this.clearing=!1}clearRef(e,t,s){const i=t&n,r=t>>>9&127,a=t>>>16,o=this.registry.types[i];$(o,this.registry.executingSystem,"write"),o.__bind(e,!0),o.__binding.fields[r].clearRef(s,this.targetEntityId,a)}trackReference(e,t,s,i,r){if(this.clearing)throw new a("Cannot track a new reference while clearing tracker");r&&this.checkUpdateMask();let n=this.getEntityIndex(e);void 0===n&&(n=this.addEntity(e,r)),this.addTag(n,this.makeTag(t,s,i))}trackUnreference(e,t,s,i,r){if(this.clearing)return;r&&this.checkUpdateMask();const n=this.getEntityIndex(e);if(void 0===n)throw new a("Entity backref not tracked");this.removeTag(n,this.makeTag(t,s,i))&&this.removeEntity(n,e,r)}getEntityIndex(e){if(this.entityIndex)return this.entityIndex[e];const t=this.entities.findIndex((t=>t.__id===e));return t>=0?t:void 0}indexEntities(){if(this.entityIndex)throw new a("Entities already indexed");this.entityIndex=new Array(this.dispatcher.maxEntities);for(let e=0;e<this.entities.length;e++)this.entityIndex[this.entities[e].__id]=e}addTag(e,t){if(!this.tags)return;const s=this.tags[e];if(void 0===s)this.tags[e]=t;else if("number"==typeof s){if(s===t)throw new a(`Ref ${t} already tracked (single)`);this.tags[e]=[s,t]}else if(Array.isArray(s)){if(s.includes(t))throw new a(`Ref ${t} already tracked (array)`);s.length>=1e3?(this.tags[e]=new Set(s)).add(t):s.push(t)}else{if(s.has(t))throw new a(`Ref ${t} already tracked (set)`);s.add(t)}}removeTag(e,t){if(!this.tags)return!0;const s=this.tags[e];if(void 0===s)throw new a(`Ref ${t} not tracked (none)`);if("number"==typeof s){if(s!==t)throw new a(`Ref ${t} not tracked (single ${s})`);return delete this.tags[e],!0}if(Array.isArray(s)){const e=s.indexOf(t);if(-1===e)throw new a(`Ref ${t} not tracked (array ${s})`);return s.splice(e,1),!this.tags.length}if(!s.has(t))throw new a(`Ref ${t} not tracked (set ${new Array(...s)})`);return s.delete(t),!s.size}makeTag(e,t,s){return e|t<<9|(void 0===s?0:s<<16)}addEntity(e,t){const s=this.entities.length;return this.entities.push(this.registry.pool.borrow(e)),this.entityIndex?this.entityIndex[e]=s:s>100&&this.indexEntities(),t&&this.trackBackrefsChange(),s}removeEntity(e,t,s){this.registry.pool.return(t);const i=this.entities.pop();if(this.entityIndex&&delete this.entityIndex[t],this.entities.length>e&&(this.entities[e]=i,this.entityIndex&&(this.entityIndex[i.__id]=e)),this.tags){const t=this.tags.pop();this.tags.length>e&&(this.tags[e]=t)}s&&this.trackBackrefsChange()}trackBackrefsChange(){for(const e of this.selector.targetTypes)e.__binding.trackedWrites&&this.registry.trackWrite(this.targetEntityId,e)}checkUpdateMask(){const e=this.registry.executingSystem;for(const t of this.selector.targetTypes)this.registry.hasShape(this.targetEntityId,t,this.trackStale)&&$(t,e,"update")}}class Ee{dispatcher;maxRefChangesPerFrame;refLog;refLogPointer;refLogStatsPointer;selectorIdsBySourceKey=new Map;selectors=[];trackers=new Map;registry;constructor(e,t){this.dispatcher=e,this.maxRefChangesPerFrame=t,this.registry=e.registry}completeCycle(){this.flush(),this.dispatcher.stats.maxRefChangesPerFrame=this.refLog?.countSince(this.refLogStatsPointer)??0}registerSelector(e,t,s,i=!1){e&&x(e),t&&x(t),this.refLog||(this.refLog=new T(this.maxRefChangesPerFrame,"maxRefChangesPerFrame",this.dispatcher.buffers,{localProcessingAllowed:!0}),this.refLogPointer=this.refLog.createPointer(),this.refLogStatsPointer=this.refLog.createPointer());const r=t?void 0===s?-2-t.id:t.id|s<<9:-1;let n=this.selectorIdsBySourceKey.get(r);if(void 0===n){this.selectors.length||(i=!0);const a={id:this.selectors.length,targetTypes:e?[e]:[],sourceType:t,matchType:!!t,matchSeq:void 0!==s,sourceTypeId:t?.id,sourceSeq:s,trackStale:i};if(this.selectors.push(a),n=a.id,this.selectorIdsBySourceKey.set(r,n),n>512)throw new o("Too many distinct backrefs selectors")}else{const t=this.selectors[n];t.trackStale=t.trackStale||i,e&&t.targetTypes.push(e)}return n}getBackrefs(e,t=0){const s=this.selectors[t];return this.getOrCreateTracker(s,e,this.registry.includeRecentlyDeleted).entities}trackRefChange(e,t,s,i,r,n,o,h){if(!this.refLog)throw new a("Trying to trackRefChange without a refLog");if(r===n&&o)throw new a("No-op call to trackRefChange");if(-1!==r){const n=(o?we.UNREFERENCE:0)|(h?we.RELEASE:0);if(!n)throw new a("Called trackRefChange with neither unreference nor release");this.pushRefLogEntry(e,t,s,i,r,n)}-1!==n&&this.pushRefLogEntry(e,t,s,i,n,we.REFERENCE)}clearAllRefs(e,t){this.selectors.length&&this.getTracker(this.selectors[0],e,t)?.clearAllRefs(t)}pushRefLogEntry(e,t,s,r,n,o){const h=void 0!==r;if(h&&!t.__binding.fields[s].type.internallyIndexed)throw new a("Inconsistent internally indexed flag");this.refLog.push(e|t.id<<i),this.refLog.push(n|s<<i|o|(h?2**29:0)),h&&this.refLog.push(r),this.processEntry(e,t.id,s,r,n,o,!0)}getOrCreateTracker(e,t,s){let r,n=this.getTracker(e,t,s);if(n)return n;if(s&&!e.trackStale)throw new a("Selector not configured for stale tracking");return n=new xe(t,e,!1,this.dispatcher),this.trackers.set(t|e.id<<i,n),e.trackStale&&(r=new xe(t,e,!0,this.dispatcher),this.trackers.set(t|e.id<<i|2**31,r)),s?r:n}getTracker(e,t,s){return this.trackers.get(t|e.id<<i|(s?2**31:0))}flush(){if(this.refLog)for(;;){const[e,t,s,n]=this.refLog.processAndCommitSince(this.refLogPointer);if(!e)break;if(!n)for(let n=t;n<s;n+=2){const t=e[n],s=e[n+1],a=t&r,o=t>>>i,h=s&r,c=s>>>i&127,d=s&be,l=0!=(s&2**29),u=l?e[n+2]:void 0;l&&(n+=1),this.processEntry(a,o,c,u,h,d,!1)}}}processEntry(e,t,s,i,r,n,a){for(let o=0;o<this.selectors.length;o++){const h=this.selectors[o];if(!(h.matchType&&h.sourceTypeId!==t||h.matchSeq&&h.sourceSeq!==s)){if(n===we.REFERENCE||n&we.UNREFERENCE){const o=this.getOrCreateTracker(h,r,!1);n===we.REFERENCE?o.trackReference(e,t,s,i,a):o.trackUnreference(e,t,s,i,a)}if(h.trackStale&&(n===we.REFERENCE||n&we.RELEASE)){const o=this.getOrCreateTracker(h,r,!0);n===we.REFERENCE?o.trackReference(e,t,s,i,a):o.trackUnreference(e,t,s,i,a)}}}}}class ve{buffer;array;update}const ke=new Map([[Uint8Array,"u8"],[Int8Array,"i8"],[Uint16Array,"u16"],[Int16Array,"i16"],[Uint32Array,"u32"],[Int32Array,"i32"],[Float32Array,"f32"],[Float64Array,"f64"]]),Ce=new Map([["u8",Uint8Array],["i8",Int8Array],["u16",Uint16Array],["i16",Int16Array],["u32",Uint32Array],["i32",Int32Array],["f32",Float32Array],["f64",Float64Array]]);class Se{threaded;items=new Map;changes;constructor(e){this.threaded=e}register(e,t,s,i,r){const n=t*s.BYTES_PER_ELEMENT;let a=this.items.get(e);const o=!a||a.buffer.byteLength<n,h=o||a.array.constructor!==s;if(!a||o||h){const t=new ve;t.buffer=o?this.threaded?new SharedArrayBuffer(n):new ArrayBuffer(n):a.buffer,t.array=new s(t.buffer),a?(t.array.set(a.array),void 0!==r&&t.array.length>a.array.length&&t.array.fill(r,a.array.length)):void 0!==r&&t.array.fill(r),a=t,this.items.set(e,a),this.threaded&&(this.changes||(this.changes=new Map),this.changes.set(e,{buffer:a.buffer,arrayKind:ke.get(s)})),i?.(a.array)}return a.update=i,a.array}makePatch(){if(!this.changes)return;const e=this.changes;return this.changes=void 0,e}applyPatch(e){for(const[t,s]of e.entries()){const e=new ve;e.update=this.items.get(t)?.update,e.buffer=s.buffer;const i=Ce.get(s.arrayKind);e.array=new i(e.buffer),this.items.set(t,e),e.update?.(e.array)}}}function Ie(e,t,s){t.constructor.schema||(t.constructor.schema={}),t.constructor.schema[s]=e}function Re(e){return function(t,s){Ie("type"in e?e:{type:e},t,s)}}function Pe(e){const t=Ie.bind(null,{type:e});return t.vector=(t,s)=>(i,r)=>{Ie({type:u.vector(e,t,s)},i,r)},t}Re.boolean=Ie.bind(null,{type:u.boolean}),Re.uint8=Pe(u.uint8),Re.int8=Pe(u.int8),Re.uint16=Pe(u.uint16),Re.int16=Pe(u.int16),Re.uint32=Pe(u.uint32),Re.int32=Pe(u.int32),Re.float32=Pe(u.float32),Re.float64=Pe(u.float64),Re.staticString=function(e){return Ie.bind(null,{type:u.staticString(e)})},Re.dynamicString=function(e){return Ie.bind(null,{type:u.dynamicString(e)})},Re.ref=Ie.bind(null,{type:u.ref}),Re.backrefs=function(...e){if("function"==typeof e[0]||void 0===e[0])return Ie.bind(null,{type:u.backrefs(...e)});Ie({type:u.backrefs},e[0],e[1])},Re.object=Ie.bind(null,{type:u.object}),Re.weakObject=Ie.bind(null,{type:u.weakObject});const $e=[],Me=[];class Ae{vertices;numVertices;edges;paths;vertexIndexMap=new Map;sealed=!1;sortedVertices;dependencyCounts;traversalCounts;numTraversedVertices;constructor(e){this.vertices=e,this.numVertices=e.length;for(let t=0;t<e.length;t++)this.vertexIndexMap.set(e[t],t);this.edges=new Array(this.numVertices**2).fill(0),this.dependencyCounts=new Array(this.numVertices),this.traversalCounts=new Array(this.numVertices)}get topologicallySortedVertices(){if(!this.sealed)throw new a("Graph not yet sealed");return this.sortedVertices||(this.sortedVertices=this.sortTopologically()),this.sortedVertices}getEdgeIndex(e,t){const s=this.vertexIndexMap.get(e),i=this.vertexIndexMap.get(t);if(void 0===s)throw new a(`Unknown vertex: ${e}`);if(void 0===i)throw new a(`Unknown vertex: ${t}`);return s*this.numVertices+i}setEdge(e,t,s){if(this.sealed)throw new a("Graph already sealed");if(e===t)return;const i=this.getEdgeIndex(e,t),r=this.getEdgeIndex(t,e),n=Math.abs(s);n<Math.abs(this.edges[i])||n<Math.abs(this.edges[r])||(this.edges[i]=s,n>Math.abs(this.edges[r])&&(this.edges[r]=0))}addEdge(e,t,s){if(s<=0)throw new a(`Edge has non-positive weight: ${s}`);this.setEdge(e,t,s)}denyEdge(e,t,s){if(s<=0)throw new a(`Edge has non-positive weight: ${s}`);this.setEdge(e,t,-s)}hasEdge(e,t){return this.edges[this.getEdgeIndex(e,t)]>0}hasPath(e,t){if(!this.sealed)throw new a("Graph not yet sealed");return this.paths[this.getEdgeIndex(e,t)]>0}hasEdgeBetweenIds(e,t){if(e>this.numVertices)throw new a(`Vertex id out of range: ${e} > ${this.numVertices}`);if(t>this.numVertices)throw new a(`Vertex id out of range: ${t} > ${this.numVertices}`);return this.edges[e*this.numVertices+t]>0}seal(){if(this.sealed)throw new a("Graph already sealed");this.sealed=!0,this.derivePaths(),this.checkForCycles(),this.simplify(),this.countDependencies()}checkForCycles(){const e=this.findCycles();if(e.length)throw e.sort(((e,t)=>e.length-t.length)),new o("Precedence cycles detected for the following systems, please resolve by adjusting their schedules: "+e.map((e=>e.map((e=>e.toString())).join(""))).join(", "))}findCycles(){const e=new Array(this.numVertices).fill(!1),t=[],s=[],i=[];let r,n;for(let e=0;e<this.numVertices;e++)t[e]=new Set;const a=s=>{e[s]=!1;for(const i of t[s])t[s].delete(i),e[i]&&a(i)},o=h=>{let c=!1;s.push(h),e[h]=!0;for(let t=0;t<this.numVertices;t++)n.has(t)&&this.hasEdgeBetweenIds(h,t)&&(t===r?(i.push(s.map((e=>this.vertices[e]))),c=!0):!e[t]&&o(t)&&(c=!0));if(c)a(h);else for(let e=0;e<this.numVertices;e++)n.has(e)&&this.hasEdgeBetweenIds(h,e)&&t[e].add(h);return s.pop(),c};for(r=0;r<this.numVertices;r++){const s=this.findLeastStronglyConnectedComponent(r);r=s[0];for(const i of s)e[i]=!1,t[i].clear();n=new Set(s),o(r)}return i}findLeastStronglyConnectedComponent(e){let t;const s=[],i=[],r=[],n=[];let a=0;const o=h=>{s[h]=++a,i.push(h),r.push(h);for(let t=e;t<this.numVertices;t++)if(this.hasEdgeBetweenIds(h,t))if(s[t]){if(!n[t])for(;r.length&&s[r[r.length-1]]>s[t];)r.pop()}else o(t);if(r[r.length-1]===h){const e=[];for(;;){const t=i.pop();if(e.push(t),n[t]=!0,t===h)break}r.pop(),e.sort(((e,t)=>e-t)),(!t||e[0]<t[0])&&(t=e)}};for(let t=e;t<this.numVertices;t++)s[t]||o(t);return t}induceSubgraph(e){const t=new Ae(e);for(const s of e){if(!this.vertexIndexMap.has(s))throw new a(`Vertex not in graph: ${s}`);for(const i of e){const e=this.getEdgeIndex(s,i),r=this.edges[e];r>0?t.addEdge(s,i,r):r<0&&t.denyEdge(s,i,-r)}}return this.sealed&&t.seal(),t}sortTopologically(){const e=new Array(this.numVertices).fill(0);for(let t=0;t<this.numVertices;t++)for(let s=0;s<this.numVertices;s++)this.hasEdgeBetweenIds(t,s)&&(e[s]+=1);const t=[];let s;for(;t.length<this.numVertices;){s=!1;for(let i=0;i<e.length;i++)if(0===e[i]){s=!0,e[i]=-1,t.push(this.vertices[i]);for(let t=0;t<this.numVertices;t++)this.hasEdgeBetweenIds(i,t)&&(e[t]-=1)}if(!s)throw new a("Graph has a cycle, topological sort not possible")}return t}derivePaths(){const e=this.numVertices;for(let e=0;e<this.edges.length;e++)this.edges[e]<0&&(this.edges[e]=0);const t=this.edges.slice();for(let s=0;s<e;s++)for(let i=0;i<e;i++)if(s!==i)for(let r=0;r<e;r++){if(r===s||r===i)continue;const n=t[s*e+r],a=t[r*e+i];if(n&&a){const r=Math.min(n,a);t[s*e+i]<r&&t[i*e+s]<r&&(t[s*e+i]=r,t[i*e+s]=0)}}this.paths=t;for(let s=0;s<e;s++)for(let i=0;i<e;i++)this.edges[s*e+i]&&(this.edges[s*e+i]=t[s*e+i])}simplify(){const e=this.numVertices,t=this.paths;for(let s=0;s<e;s++)for(let i=0;i<e;i++)if(this.edges[s*e+i])for(let r=0;r<e;r++)r!==s&&r!==i&&t[s*e+r]&&t[r*e+i]&&(this.edges[s*e+i]=0)}countDependencies(){for(let e=0;e<this.numVertices;e++){let t=0;for(let s=0;s<this.numVertices;s++)this.edges[s*this.numVertices+e]&&(t+=1);this.dependencyCounts[e]=t}}traverse(e){if(!this.sealed)throw new a("Graph not yet sealed");const t=[];if(e){this.numTraversedVertices+=1;const s=this.vertexIndexMap.get(e);if(void 0===s)throw new a(`Unknown vertex: ${e}`);for(let e=0;e<this.numVertices;e++)this.edges[s*this.numVertices+e]&&0==--this.traversalCounts[e]&&t.push(this.vertices[e])}else{this.numTraversedVertices=0;for(let e=0;e<this.numVertices;e++)0===(this.traversalCounts[e]=this.dependencyCounts[e])&&t.push(this.vertices[e])}if(this.numTraversedVertices!==this.numVertices)return t}printMatrix(e){const t=this.numVertices,s=[];for(let i=0;i<t;i++){const r=[];for(let s=0;s<t;s++)r.push(e[i*t+s]);s.push(r.join(" "))}return s.join("\n")}}class Oe{planner;group;graph;constructor(e,t){this.planner=e,this.group=t,this.graph=e.graph.induceSubgraph(t.__systems)}}class Te extends Oe{planner;group;systems;constructor(e,t){if(super(e,t),this.planner=e,this.group=t,this.systems=this.graph.topologicallySortedVertices,this.systems.length>1&&"undefined"==typeof process){console.log("System execution order:");for(const e of this.systems)console.log(" ",e.name)}}execute(e,t){const s=this.planner.dispatcher,i=this.systems;this.group.__executed=!0;for(let r=0;r<i.length;r++)i[r].execute(e,t),s.flush();return Promise.resolve()}async initialize(){const e=this.planner.dispatcher;return this.group.__executed=!0,new Promise(((t,s)=>{let i=!1;const r=async n=>{try{if(await n.prepare(),i)return;n.initialize(),e.flush();const s=this.graph.traverse(n);if(!s)return t();for(let e=0;e<s.length;e++)r(s[e])}catch(e){i=!0,s(e)}},n=this.graph.traverse();if(!n)return t();for(let e=0;e<n.length;e++)r(n[e])}))}async finalize(){const e=this.planner.dispatcher;return this.group.__executed=!0,new Promise(((t,s)=>{const i=r=>{try{r.finalize(),e.flush();const s=this.graph.traverse(r);if(!s)return t();for(let e=0;e<s.length;e++)i(s[e])}catch(e){s(e)}},r=this.graph.traverse();if(!r)return t();for(let e=0;e<r.length;e++)i(r[e])}))}}class Le extends Oe{execute(e,t){return Promise.resolve()}initialize(){return Promise.resolve()}finalize(){return Promise.resolve()}}class Be{id;systems=[];constructor(e){this.id=e}add(...e){for(const t of e)t.lane=this;this.systems.push(...e)}merge(e){return this===e?this:-1===this.id||-1!==e.id&&e.id<this.id?e.merge(this):(this.add(...e.systems),e.systems.length=0,this)}}class Ne{dispatcher;systems;groups;graph;readers=new Map;writers=new Map;lanes=[];replicatedLane;laneCount=0;constructor(e,t,s){this.dispatcher=e,this.systems=t,this.groups=s,this.graph=new Ae(t);for(const t of e.registry.types)this.readers.set(t,new Set),this.writers.set(t,new Set);e.threaded&&(this.createLane(),this.replicatedLane=new Be(-1))}get mainLane(){return this.lanes[0]}createLane(){const e=new Be(this.laneCount++);return this.lanes.push(e),e}organize(){for(const e of this.groups)e.__collectSystems(this.dispatcher);for(const e of this.systems)e.buildQueries();for(const e of this.systems)e.buildSchedule();for(const e of this.groups)e.__buildSchedule();this.addComponentEntitlementDependencies(),this.graph.seal(),this.dispatcher.threaded&&this.assignSystemsToLanes();for(const e of this.systems)e.stats.worker=e.lane?.id??0;delete this.readers,delete this.writers;for(const e of this.groups)e.__plan=this.dispatcher.threaded?new Le(this,e):new Te(this,e)}addComponentEntitlementDependencies(){for(const[e,t]of this.readers.entries())for(const s of t)for(const t of this.writers.get(e))this.graph.addEdge(t,s,1)}assignSystemsToLanes(){this.initSystemLanes(),this.mergeAccessorsOfUnsharedComponentTypes(),this.mergeAttachedSystems(),this.pruneEmptyLanes(),this.reduceLanes(this.dispatcher.threads+1),this.pruneEmptyLanes()}initSystemLanes(){for(const e of this.systems)e.lane||this.createLane().add(e)}mergeAccessorsOfUnsharedComponentTypes(){for(const e of this.dispatcher.registry.types){if(e.__binding.fields.every((e=>e.type.shared)))continue;const t=this.readers.get(e),s=this.writers.get(e);if(!t&&!s)continue;let i=e.options?.restrictedToMainThread?this.mainLane:this.createLane();t?.forEach((e=>{i=i.merge(e.lane)})),s?.forEach((e=>{i=i.merge(e.lane)}))}}mergeAttachedSystems(){for(const e of this.systems)for(const t of e.attachedSystems)t&&e.lane.merge(t.lane)}reduceLanes(e){if(this.lanes.length<=e)return;let t=[];for(let e=1;e<this.lanes.length-1;e++){const s=this.lanes[e];for(let i=e+1;i<this.lanes.length;i++){const e=this.lanes[i];t.push({laneA:s,laneB:e,independence:this.computeIndependence(s,e)})}}let s=this.lanes.length;for(;s>e;){t.sort(((e,t)=>t.independence-e.independence));const i=t.pop(),r=i.laneA.merge(i.laneB),n=r===i.laneA?i.laneB:i.laneA;s-=1,s>e&&(t=t.filter((e=>e.laneA!==n&&e.laneB!==n&&(e.laneA!==r&&e.laneB!==r||(e.independence=this.computeIndependence(e.laneA,e.laneB)),!0))))}}computeIndependence(e,t){return Math.min(this.computeIndependentWeight(e,t),this.computeIndependentWeight(t,e))}computeIndependentWeight(e,t){let s=0;for(const i of e.systems){let e=0;for(const s of t.systems)this.graph.hasPath(i,s)||this.graph.hasPath(s,i)||(e+=s.weight);s+=Math.min(i.weight,e)}return s}pruneEmptyLanes(){this.lanes=this.lanes.filter((e=>0===e.id||e.systems.length));for(let e=1;e<this.lanes.length;e++)this.lanes[e].id=e}}class Fe extends ne{static __internal=!0;__callback;start(e,...t){throw new o("The build system cannot run coroutines")}execute(){this.__callback(this)}}class De extends ne{static __internal=!0}var je;!function(e){e[e.init=0]="init",e[e.setup=1]="setup",e[e.run=2]="run",e[e.finish=3]="finish",e[e.done=4]="done"}(je||(je={}));class Ve{maxEntities;defaultComponentStorage;registry;systems;systemsByClass=new Map;systemGroups;default;lastTime;executing;executingSyncFrame;state=je.init;shapeLog;writeLog;shapeLogFramePointer;writeLogFramePointer;stats;indexer;planner;threads;buffers;singleton;buildSystem;deferredControls=new Map;constructor({defs:e,threads:t=1,maxEntities:s=1e4,maxLimboComponents:i=Math.ceil(s/5),maxShapeChangesPerFrame:r=2*s,maxWritesPerFrame:n=4*s,maxRefChangesPerFrame:a=s,defaultComponentStorage:h="packed"}){if(t<1)throw new o("Minimum of one thread");if(t>1)throw new o("Multithreading not yet implemented");if(s>4194304)throw new o("maxEntities too high, the limit is 4194304");const{componentTypes:c,componentEnums:d,systemTypes:l,systemGroups:u}=this.splitDefs([e??[],$e,Me]);if(c.length>512)throw new o("Too many component types, the limit is 512");this.stats=new _e,this.threads=t,this.buffers=new Se(t>1),this.maxEntities=s,this.defaultComponentStorage=h,this.registry=new pe(s,i,c,d,this),this.indexer=new Ee(this,a),this.shapeLog=new T(r,"maxShapeChangesPerFrame",this.buffers,{sortedByComponentType:!0,numComponentTypes:this.registry.types.length}),this.shapeLogFramePointer=this.shapeLog.createPointer(),this.systemGroups=u,this.systems=this.createSystems(l),this.createBuildSystem(),this.registry.initializeComponentTypes(),this.registry.validateSystem=this.createValidateSystem(c),this.singleton=this.createSingletons();for(const e of this.systems)e.replacePlaceholders();this.planner=new Ne(this,this.systems,this.systemGroups),this.planner.organize(),this.registry.hasNegativeQueries=this.systems.some((e=>e.hasNegativeQueries)),this.systems.some((e=>e.hasWriteQueries))&&(this.writeLog=new T(n,"maxWritesPerFrame",this.buffers,{sortedByComponentType:!0,numComponentTypes:this.registry.types.length}),this.writeLogFramePointer=this.writeLog.createPointer());for(const e of this.systems)e.finishConstructing();this.state=je.setup}get threaded(){return this.threads>1}get defaultGroup(){return this.default.group}createSystems(e){const t=[],s=[],i=new Set;let r=0;for(let n=0;n<e.length;n++){const a=e[n];let h=this.systemsByClass.get(a);if(!h){if(a.name||Object.defineProperty(a,"name",{value:"Anonymous_"+r++}),!a.__internal){if(i.has(a.name))throw new o(`Multiple component types named ${a.name}; names must be unique`);i.add(a.name)}this.stats.forSystem(a),s.push(a);const e=new a;e.id=n+2,h=new ae(e,this),t.push(h),this.systemsByClass.set(a,h)}const c=e[n+1];c&&"function"!=typeof c&&(h.assignProps(c),n++)}return this.default=this.createSingleGroupFrame(s),t}createBuildSystem(){this.buildSystem=new Fe,this.buildSystem.id=0;const e=new ae(this.buildSystem,this);e.accessMasks.read=void 0,e.accessMasks.update=void 0,e.accessMasks.create=void 0,e.accessMasks.write=void 0,e.accessMasks.check=void 0,this.systems.push(e),this.systemsByClass.set(Fe,e)}createValidateSystem(e){const t=new De;t.id=1;const s=new ae(t,this);for(const t of e)A(s.accessMasks.check,t);return this.systems.push(s),this.systemsByClass.set(De,s),s}createSingleGroupFrame(e){const t=new K(e);return this.systemGroups.push(t),{group:t,frame:new Y(this,[t])}}createSingletons(){const e=new Set,t=this.systems.flatMap((t=>t.singletonComponentDefs.filter(((s,i)=>{let r=!0;return"function"==typeof s&&(r=i<t.singletonComponentDefs.length-1&&"function"!=typeof t.singletonComponentDefs[i+1],r&&e.add(s)),r})))).concat(this.systems.flatMap((t=>t.singletonComponentDefs.filter((t=>"function"==typeof t&&!e.has(t)&&(e.add(t),!0))))));if(!t.length)return;this.executing=!0;const s=this.createEntity(t).hold();return this.executing=!1,this.flush(),s}splitDefs(e){const t=[],s=new Set,i=new Set,r=[],n=[];let a=!1;for(const t of e.flat(1/0))if(t instanceof K){n.push(t);const{componentTypes:e,systemTypes:s,systemGroups:i}=this.splitDefs(t.__contents);for(const t of e)h(t);r.push(...s),n.push(...i)}else if("function"==typeof t)a=!!t.__system,a?r.push(t):h(t);else if(t instanceof oe){i.add(t);for(const e of t.__types)h(e)}else{if(!a)throw new o("Unexpected value in world defs: "+t);r.push(t),a=!1}return{componentTypes:t,componentEnums:Array.from(i),systemTypes:r,systemGroups:n};function h(e){if(e.enum&&!i.has(e.enum)){i.add(e.enum);for(const t of e.enum.__types)h(t)}else s.has(e)||(t.push(e),s.add(e))}}getSystems(e){if(e instanceof K)return e.__systems;const t=this.systemsByClass.get(e);if(!t)throw new o(`System ${e.name} not registered in world`);return[t]}async initialize(){await this.default.frame.begin(),this.state=je.setup,await this.default.group.__plan.initialize(),await this.default.frame.end(),this.stats.frames-=1}async finalize(){await this.default.frame.begin(),this.state=je.done,await this.default.group.__plan.finalize(),await this.default.frame.end(),this.stats.frames-=1,this.registry.releaseComponentTypes()}async execute(e,t){await this.default.frame.begin(),await this.default.frame.execute(this.default.group,e,t),await this.default.frame.end()}executeFunction(e){this.startFrame(this.lastTime),this.executingSyncFrame=!0,this.buildSystem.__callback=e,this.systemsByClass.get(Fe).execute(this.lastTime,0),this.flush(),this.completeCycle(),this.completeFrame(),this.executingSyncFrame=!1,this.stats.frames-=1}completeCycle(){this.registry.completeCycle(),this.indexer.completeCycle(),this.writeLog?.commit()}startFrame(e){if(this.executing)throw new o("Another frame already executing");if(this.executing=!0,this.state!==je.setup&&this.state!==je.run&&this.state!==je.finish)throw new o("World terminated");this.state=je.run,this.lastTime=e}completeFrame(){if(!this.executing)throw new a("No frame executing");return this.executing=!1,this.gatherFrameStats(),this.processDeferredControls(),this.state===je.finish?this.finalize():Promise.resolve()}gatherFrameStats(){this.stats.frames+=1,this.stats.maxShapeChangesPerFrame=this.shapeLog.countSince(this.shapeLogFramePointer),this.stats.maxWritesPerFrame=this.writeLog?.countSince(this.writeLogFramePointer)??0}flush(){this.indexer.flush(),this.registry.flush(),this.shapeLog.commit(),this.writeLog?.commit()}async terminate(){if(this.state!==je.setup&&this.state!==je.run)throw new o("World terminated");if(this.executingSyncFrame)throw new o("Cannot terminate world from within build callback");this.state=je.finish,this.executing||await this.finalize()}createEntity(e){const t=this.registry.createEntity(e);return this.executing||this.flush(),t}control(e){this.checkControlOverlap(e),this.deferRequestedRunState(e.stop,se.STOPPED),this.deferRequestedRunState(e.restart,se.RUNNING),this.executing||this.processDeferredControls()}deferRequestedRunState(e,t){for(const s of this.splitDefs(e).systemTypes){if(!s.__system)continue;const e=this.systemsByClass.get(s);if(!e)throw new o(`System ${s.name} not defined for this world`);this.deferredControls.set(e,t)}}checkControlOverlap(e){const t=new Set;for(const s of this.splitDefs(e.stop).systemTypes)s.__system&&t.add(s);for(const s of this.splitDefs(e.restart).systemTypes)if(s.__system&&t.has(s))throw new o(`Request to both stop and restart system ${s.name}`)}processDeferredControls(){if(this.deferredControls.size){for(const[e,t]of this.deferredControls.entries())switch(t){case se.STOPPED:e.stop();break;case se.RUNNING:e.restart()}this.deferredControls.clear()}}}const Ue={};class qe{__dispatcher;static async create(e={}){const t=new qe(e,Ue);return await t.__dispatcher.initialize(),t}static defineEnum(e,...t){return"function"==typeof e&&(t.unshift(e),e=""),new oe(e=e||"<anonymous>",t)}constructor(e,t){if(t!==Ue)throw new o("Don't call World constructor directly; use World.create instead");this.__dispatcher=new Ve(e)}build(e){if(this.__dispatcher.state!==je.setup)throw new o("This method cannot be called after the world has started executing");this.__dispatcher.executeFunction(e)}createEntity(...e){if(this.__dispatcher.state!==je.setup)throw new o("This method cannot be called after the world has started executing");this.__dispatcher.createEntity(e)}execute(e,t){return this.__dispatcher.execute(e,t)}control(e){this.__dispatcher.control(e)}createCustomExecutor(...e){return new Y(this.__dispatcher,e)}async terminate(){await this.__dispatcher.terminate()}get stats(){return this.__dispatcher.stats}get alive(){return this.__dispatcher.state!==je.done}}}}]);
//# sourceMappingURL=232.echo-d.min.js.map