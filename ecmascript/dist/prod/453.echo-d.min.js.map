{"version":3,"file":"453.echo-d.min.js","mappings":"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","sources":["webpack://echoD/./node_modules/@lastolivegames/becsy/index.js"],"sourcesContent":["const ENTITY_ID_BITS = 22;\r\nconst COMPONENT_ID_BITS = 9;\r\nconst FIELD_SEQ_BITS = 7;\r\nconst MAX_NUM_ENTITIES = 2 ** ENTITY_ID_BITS;\r\nconst ENTITY_ID_MASK = MAX_NUM_ENTITIES - 1;\r\nconst MAX_NUM_COMPONENTS = 2 ** COMPONENT_ID_BITS;\r\nconst COMPONENT_ID_MASK = MAX_NUM_COMPONENTS - 1;\r\nconst MAX_NUM_FIELDS = 2 ** FIELD_SEQ_BITS;\r\nconst FIELD_SEQ_MASK = MAX_NUM_FIELDS - 1;\r\n// TODO: enforce max length of ref structs/arrays\n\nclass InternalError extends Error {\r\n    constructor(message) {\r\n        super(`Internal error: ${message}. Please report a bug!`);\r\n    }\r\n}\r\nclass CheckError extends Error {\r\n}\n\nconst encoder = new TextEncoder();\r\nconst decoder = new TextDecoder();\r\nfunction throwNotWritable(binding) {\r\n    throw new CheckError(`Component is not writable; ` +\r\n        `use entity.write(${binding.type.name}) to acquire a writable version`);\r\n}\r\nfunction checkInvalid(component, binding) {\r\n    if (component.__invalid) {\r\n        throw new CheckError(`Component instance for ${binding.type.name} is no longer valid, as you already bound it ` +\r\n            `to another entity`);\r\n    }\r\n}\r\nclass Type {\r\n    defaultValue;\r\n    shared;\r\n    constructor(defaultValue, shared = true) {\r\n        this.defaultValue = defaultValue;\r\n        this.shared = shared;\r\n    }\r\n    get internallyIndexed() { return false; }\r\n    /* eslint-disable lines-between-class-members */\r\n    static boolean;\r\n    static uint8;\r\n    static int8;\r\n    static uint16;\r\n    static int16;\r\n    static uint32;\r\n    static int32;\r\n    static float32;\r\n    static float64;\r\n    static vector;\r\n    static staticString;\r\n    static dynamicString;\r\n    static object;\r\n    static weakObject;\r\n    // TODO: add autoremove/autodelete when nulled out\r\n    static ref;\r\n    static backrefs;\r\n}\r\nclass BooleanType extends Type {\r\n    constructor() { super(false); }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity, Uint8Array, (newData) => { data = newData; });\r\n        };\r\n        field.updateBuffer();\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return Boolean(data[binding.writableIndex]);\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value ? 1 : 0;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return Boolean(data[binding.readonlyIndex]);\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, Uint8Array);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return Boolean(data[binding.writableIndex]);\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value ? 1 : 0;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return Boolean(data[binding.readonlyIndex]);\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass NumberType extends Type {\r\n    NumberArray;\r\n    constructor(NumberArray) {\r\n        super(0);\r\n        this.NumberArray = NumberArray;\r\n    }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.NumberArray, (newData) => { data = newData; });\r\n        };\r\n        field.updateBuffer();\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.writableIndex];\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.readonlyIndex];\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.NumberArray);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.writableIndex];\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.readonlyIndex];\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass VectorType extends Type {\r\n    type;\r\n    Class;\r\n    stride;\r\n    elementNames;\r\n    constructor(type, elements, Class) {\r\n        super(new Array(typeof elements === 'number' ? elements : elements.length).fill(0));\r\n        this.type = type;\r\n        this.Class = Class;\r\n        if (typeof elements === 'number') {\r\n            this.stride = elements;\r\n        }\r\n        else {\r\n            this.stride = elements.length;\r\n            this.elementNames = elements;\r\n        }\r\n    }\r\n    get internallyIndexed() { return true; }\r\n    defineElastic(binding, field) {\r\n        const stride = this.stride;\r\n        const elementNames = this.elementNames;\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity * stride, this.type.NumberArray, (newData) => { data = newData; });\r\n        };\r\n        field.updateBuffer();\r\n        const masterWritableAccessor = this.Class ? new this.Class() : {};\r\n        const masterReadonlyAccessor = this.Class ? new this.Class() : {};\r\n        Object.defineProperty(masterWritableAccessor, 'length', { value: stride });\r\n        Object.defineProperty(masterReadonlyAccessor, 'length', { value: stride });\r\n        {\r\n            Object.defineProperty(masterWritableAccessor, '__becsyComponent', { value: undefined, writable: true });\r\n            Object.defineProperty(masterReadonlyAccessor, '__becsyComponent', { value: undefined, writable: true });\r\n        }\r\n        let writableAccessor = Object.create(masterWritableAccessor);\r\n        Object.seal(writableAccessor);\r\n        let readonlyAccessor = Object.create(masterReadonlyAccessor);\r\n        Object.seal(readonlyAccessor);\r\n        /* eslint-disable no-loop-func */\r\n        for (let i = 0; i < this.stride; i++) {\r\n            Object.defineProperty(masterWritableAccessor, `${i}`, {\r\n                enumerable: true,\r\n                get() {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    return data[binding.writableIndex * stride + i];\r\n                },\r\n                set(value) {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    data[binding.writableIndex * stride + i] = value;\r\n                }\r\n            });\r\n            Object.defineProperty(masterReadonlyAccessor, `${i}`, {\r\n                enumerable: true,\r\n                get() {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    return data[binding.readonlyIndex * stride + i];\r\n                },\r\n                set(value) {\r\n                    throwNotWritable(binding);\r\n                }\r\n            });\r\n            if (this.elementNames?.[i]) {\r\n                Object.defineProperty(masterWritableAccessor, this.elementNames[i], {\r\n                    enumerable: true,\r\n                    get() {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        return data[binding.writableIndex * stride + i];\r\n                    },\r\n                    set(value) {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        data[binding.writableIndex * stride + i] = value;\r\n                    }\r\n                });\r\n                Object.defineProperty(masterReadonlyAccessor, this.elementNames[i], {\r\n                    enumerable: true,\r\n                    get() {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        return data[binding.readonlyIndex * stride + i];\r\n                    },\r\n                    set(value) {\r\n                        throwNotWritable(binding);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        /* eslint-enable no-loop-func */\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                {\r\n                    checkInvalid(this, binding);\r\n                    writableAccessor = Object.create(masterWritableAccessor);\r\n                    writableAccessor.__becsyComponent = this;\r\n                    Object.seal(writableAccessor);\r\n                }\r\n                return writableAccessor;\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value.length) {\r\n                    if (value.length !== stride) {\r\n                        throw new CheckError(`Value of length ${value.length} doesn't match vector of length ${stride}`);\r\n                    }\r\n                    for (let i = 0; i < stride; i++)\r\n                        data[binding.writableIndex * stride + i] = value[i];\r\n                }\r\n                else {\r\n                    if (!elementNames) {\r\n                        throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} must be an array`);\r\n                    }\r\n                    for (let i = 0; i < stride; i++) {\r\n                        if (typeof value[elementNames[i]] !== 'number') {\r\n                            throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} is missing element ` +\r\n                                `\"${elementNames[i]}`);\r\n                        }\r\n                        data[binding.writableIndex * stride + i] = value[elementNames[i]];\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                {\r\n                    checkInvalid(this, binding);\r\n                    readonlyAccessor = Object.create(masterReadonlyAccessor);\r\n                    readonlyAccessor.__becsyComponent = this;\r\n                    Object.seal(readonlyAccessor);\r\n                }\r\n                return readonlyAccessor;\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const stride = this.stride;\r\n        const elementNames = this.elementNames;\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity * stride, this.type.NumberArray);\r\n        const masterWritableAccessor = this.Class ? new this.Class() : {};\r\n        const masterReadonlyAccessor = this.Class ? new this.Class() : {};\r\n        Object.defineProperty(masterWritableAccessor, 'length', { value: stride });\r\n        Object.defineProperty(masterReadonlyAccessor, 'length', { value: stride });\r\n        {\r\n            Object.defineProperty(masterWritableAccessor, '__becsyComponent', { value: undefined, writable: true });\r\n            Object.defineProperty(masterReadonlyAccessor, '__becsyComponent', { value: undefined, writable: true });\r\n        }\r\n        let writableAccessor = Object.create(masterWritableAccessor);\r\n        Object.seal(writableAccessor);\r\n        let readonlyAccessor = Object.create(masterReadonlyAccessor);\r\n        Object.seal(readonlyAccessor);\r\n        for (let i = 0; i < this.stride; i++) {\r\n            Object.defineProperty(masterWritableAccessor, `${i}`, {\r\n                enumerable: true,\r\n                get() {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    return data[binding.writableIndex * stride + i];\r\n                },\r\n                set(value) {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    data[binding.writableIndex * stride + i] = value;\r\n                }\r\n            });\r\n            Object.defineProperty(masterReadonlyAccessor, `${i}`, {\r\n                enumerable: true,\r\n                get() {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    return data[binding.readonlyIndex * stride + i];\r\n                },\r\n                set(value) {\r\n                    throwNotWritable(binding);\r\n                }\r\n            });\r\n            if (this.elementNames?.[i]) {\r\n                Object.defineProperty(masterWritableAccessor, this.elementNames[i], {\r\n                    enumerable: true,\r\n                    get() {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        return data[binding.writableIndex * stride + i];\r\n                    },\r\n                    set(value) {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        data[binding.writableIndex * stride + i] = value;\r\n                    }\r\n                });\r\n                Object.defineProperty(masterReadonlyAccessor, this.elementNames[i], {\r\n                    enumerable: true,\r\n                    get() {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        return data[binding.readonlyIndex * stride + i];\r\n                    },\r\n                    set(value) {\r\n                        throwNotWritable(binding);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                {\r\n                    checkInvalid(this, binding);\r\n                    writableAccessor = Object.create(masterWritableAccessor);\r\n                    writableAccessor.__becsyComponent = this;\r\n                    Object.seal(writableAccessor);\r\n                }\r\n                return writableAccessor;\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value.length) {\r\n                    if (value.length !== stride) {\r\n                        throw new CheckError(`Value of length ${value.length} doesn't match vector of length ${stride}`);\r\n                    }\r\n                    for (let i = 0; i < stride; i++)\r\n                        data[binding.writableIndex * stride + i] = value[i];\r\n                }\r\n                else {\r\n                    if (!elementNames) {\r\n                        throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} must be an array`);\r\n                    }\r\n                    for (let i = 0; i < stride; i++) {\r\n                        if (typeof value[elementNames[i]] !== 'number') {\r\n                            throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} is missing element ` +\r\n                                `\"${elementNames[i]}`);\r\n                        }\r\n                        data[binding.writableIndex * stride + i] = value[elementNames[i]];\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                {\r\n                    checkInvalid(this, binding);\r\n                    readonlyAccessor = Object.create(masterReadonlyAccessor);\r\n                    readonlyAccessor.__becsyComponent = this;\r\n                    Object.seal(readonlyAccessor);\r\n                }\r\n                return readonlyAccessor;\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass StaticStringType extends Type {\r\n    choices;\r\n    choicesIndex = new Map();\r\n    TypedArray;\r\n    constructor(choices) {\r\n        super(choices[0]);\r\n        this.choices = choices;\r\n        {\r\n            if (!choices?.length)\r\n                throw new CheckError('No choices specified for Type.staticString');\r\n        }\r\n        if (choices.length < 1 << 8)\r\n            this.TypedArray = Uint8Array;\r\n        else if (choices.length < 1 << 16)\r\n            this.TypedArray = Uint16Array;\r\n        else\r\n            this.TypedArray = Uint32Array;\r\n        for (let i = 0; i < choices.length; i++)\r\n            this.choicesIndex.set(choices[i], i);\r\n    }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        const choices = this.choices, choicesIndex = this.choicesIndex;\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.TypedArray, (newData) => { data = newData; });\r\n        };\r\n        field.updateBuffer();\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const index = data[binding.writableIndex];\r\n                const result = choices[index];\r\n                {\r\n                    if (result === undefined)\r\n                        throw new CheckError(`Invalid static string index: ${index}`);\r\n                }\r\n                return result;\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                const index = choicesIndex.get(value);\r\n                {\r\n                    if (index === undefined)\r\n                        throw new CheckError(`Static string not in set: \"${value}\"`);\r\n                }\r\n                data[binding.writableIndex] = index;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const index = data[binding.readonlyIndex];\r\n                const result = choices[index];\r\n                {\r\n                    if (result === undefined)\r\n                        throw new CheckError(`Invalid static string index: ${index}`);\r\n                }\r\n                return result;\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const choices = this.choices, choicesIndex = this.choicesIndex;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.TypedArray);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const index = data[binding.writableIndex];\r\n                const result = choices[index];\r\n                {\r\n                    if (result === undefined)\r\n                        throw new CheckError(`Invalid static string index: ${index}`);\r\n                }\r\n                return result;\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                const index = choicesIndex.get(value);\r\n                {\r\n                    if (index === undefined)\r\n                        throw new CheckError(`Static string not in set: \"${value}\"`);\r\n                }\r\n                data[binding.writableIndex] = index;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const index = data[binding.readonlyIndex];\r\n                const result = choices[index];\r\n                {\r\n                    if (result === undefined)\r\n                        throw new CheckError(`Invalid static string index: ${index}`);\r\n                }\r\n                return result;\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass DynamicStringType extends Type {\r\n    maxUtf8Length;\r\n    lengthsStride;\r\n    bytesStride;\r\n    constructor(maxUtf8Length) {\r\n        super('');\r\n        this.maxUtf8Length = maxUtf8Length + (maxUtf8Length % 2);\r\n        this.bytesStride = this.maxUtf8Length + 2; // account for length field\r\n        this.lengthsStride = this.bytesStride / 2;\r\n    }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let lengths;\r\n        let bytes;\r\n        const maxUtf8Length = this.maxUtf8Length;\r\n        const lengthsStride = this.lengthsStride, bytesStride = this.bytesStride;\r\n        field.updateBuffer = () => {\r\n            const size = binding.capacity * (this.maxUtf8Length + Uint16Array.BYTES_PER_ELEMENT);\r\n            binding.dispatcher.buffers.register(bufferKey, size, Uint8Array, (newData) => {\r\n                bytes = newData;\r\n                lengths = new Uint16Array(bytes.buffer);\r\n            });\r\n        };\r\n        field.updateBuffer();\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const length = lengths[binding.writableIndex * lengthsStride];\r\n                return decoder.decode(new Uint8Array(bytes.buffer, binding.writableIndex * bytesStride + 2, length));\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                const encodedString = encoder.encode(value);\r\n                {\r\n                    if (encodedString.byteLength > maxUtf8Length) {\r\n                        throw new CheckError(`Dynamic string length > ${maxUtf8Length} after encoding: ${value}`);\r\n                    }\r\n                }\r\n                lengths[binding.writableIndex * lengthsStride] = encodedString.byteLength;\r\n                bytes.set(encodedString, binding.writableIndex * bytesStride + 2);\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const length = lengths[binding.readonlyIndex * lengthsStride];\r\n                return decoder.decode(new Uint8Array(bytes.buffer, binding.readonlyIndex * bytesStride + 2, length));\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const maxUtf8Length = this.maxUtf8Length;\r\n        const lengthsStride = this.lengthsStride, bytesStride = this.bytesStride;\r\n        const size = binding.capacity * (this.maxUtf8Length + Uint16Array.BYTES_PER_ELEMENT);\r\n        const bytes = binding.dispatcher.buffers.register(bufferKey, size, Uint8Array);\r\n        const lengths = new Uint16Array(bytes.buffer);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const length = lengths[binding.writableIndex * lengthsStride];\r\n                return decoder.decode(new Uint8Array(bytes.buffer, binding.writableIndex * bytesStride + 2, length));\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                const encodedString = encoder.encode(value);\r\n                {\r\n                    if (encodedString.byteLength > maxUtf8Length) {\r\n                        throw new CheckError(`Dynamic string length > ${maxUtf8Length} after encoding: ${value}`);\r\n                    }\r\n                }\r\n                lengths[binding.writableIndex * lengthsStride] = encodedString.byteLength;\r\n                bytes.set(encodedString, binding.writableIndex * bytesStride + 2);\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const length = lengths[binding.readonlyIndex * lengthsStride];\r\n                return decoder.decode(new Uint8Array(bytes.buffer, binding.readonlyIndex * bytesStride + 2, length));\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nconst STALE_REF_BIT = 2 ** 31;\r\nclass RefType extends Type {\r\n    constructor() {\r\n        super(undefined);\r\n    }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        const indexer = binding.dispatcher.indexer;\r\n        const registry = binding.dispatcher.registry;\r\n        const pool = registry.pool;\r\n        indexer.registerSelector();\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity, Int32Array, (newData) => { data = newData; }, -1);\r\n        };\r\n        field.updateBuffer();\r\n        field.clearRef = (final, targetId, internalIndex) => {\r\n            if (internalIndex)\r\n                throw new InternalError('Ref fields have no internal index');\r\n            if (data[binding.writableIndex] === -1)\r\n                return;\r\n            const stale = (data[binding.writableIndex] & STALE_REF_BIT) !== 0;\r\n            if (stale && !final)\r\n                return;\r\n            if (!stale && final)\r\n                throw new InternalError('Wrong ref stale state');\r\n            const id = (data[binding.writableIndex] & ENTITY_ID_MASK);\r\n            const targetIdGiven = targetId !== undefined;\r\n            if (targetIdGiven && id !== targetId)\r\n                return;\r\n            if (final) {\r\n                data[binding.writableIndex] = -1;\r\n            }\r\n            else {\r\n                data[binding.writableIndex] |= STALE_REF_BIT;\r\n            }\r\n            indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, id, -1, !final, final);\r\n        };\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const id = data[binding.writableIndex];\r\n                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)\r\n                    return;\r\n                return pool.borrowTemporarily((id & ENTITY_ID_MASK));\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value && !registry.hasShape(value.__id, registry.Alive, false)) {\r\n                    throw new CheckError('Referencing a deleted entity is not allowed');\r\n                }\r\n                let oldId = data[binding.writableIndex];\r\n                if (oldId !== -1)\r\n                    oldId = (oldId & ENTITY_ID_MASK);\r\n                const stale = oldId !== -1 && !!(data[binding.writableIndex] & STALE_REF_BIT);\r\n                const newId = (value?.__id ?? -1);\r\n                if (oldId === newId && !stale)\r\n                    return;\r\n                data[binding.writableIndex] = newId;\r\n                indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, oldId, newId, !stale, true);\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const id = data[binding.readonlyIndex];\r\n                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)\r\n                    return;\r\n                return pool.borrowTemporarily((id & ENTITY_ID_MASK));\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, Int32Array, undefined, -1);\r\n        const indexer = binding.dispatcher.indexer;\r\n        const registry = binding.dispatcher.registry;\r\n        const pool = registry.pool;\r\n        indexer.registerSelector();\r\n        field.clearRef = (final, targetId, internalIndex) => {\r\n            if (internalIndex)\r\n                throw new InternalError('Ref fields have no internal index');\r\n            if (data[binding.writableIndex] === -1)\r\n                return;\r\n            const stale = (data[binding.writableIndex] & STALE_REF_BIT) !== 0;\r\n            if (stale && !final)\r\n                return;\r\n            if (!stale && final)\r\n                throw new InternalError('Wrong ref stale state');\r\n            const id = (data[binding.writableIndex] & ENTITY_ID_MASK);\r\n            const targetIdGiven = targetId !== undefined;\r\n            if (targetIdGiven && id !== targetId)\r\n                return;\r\n            if (final) {\r\n                data[binding.writableIndex] = -1;\r\n            }\r\n            else {\r\n                data[binding.writableIndex] |= STALE_REF_BIT;\r\n            }\r\n            indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, id, -1, !final, final);\r\n        };\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const id = data[binding.writableIndex];\r\n                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)\r\n                    return;\r\n                return pool.borrowTemporarily((id & ENTITY_ID_MASK));\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value && !registry.hasShape(value.__id, registry.Alive, false)) {\r\n                    throw new CheckError('Referencing a deleted entity is not allowed');\r\n                }\r\n                let oldId = data[binding.writableIndex];\r\n                if (oldId !== -1)\r\n                    oldId = (oldId & ENTITY_ID_MASK);\r\n                const stale = oldId !== -1 && !!(data[binding.writableIndex] & STALE_REF_BIT);\r\n                const newId = (value?.__id ?? -1);\r\n                if (oldId === newId && !stale)\r\n                    return;\r\n                data[binding.writableIndex] = newId;\r\n                indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, oldId, newId, !stale, true);\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const id = data[binding.readonlyIndex];\r\n                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)\r\n                    return;\r\n                return pool.borrowTemporarily((id & ENTITY_ID_MASK));\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nconst EMPTY_ARRAY = [];\r\nclass BackrefsType extends Type {\r\n    type;\r\n    fieldName;\r\n    trackDeletedBackrefs;\r\n    constructor(type, fieldName, trackDeletedBackrefs) {\r\n        super(EMPTY_ARRAY);\r\n        this.type = type;\r\n        this.fieldName = fieldName;\r\n        this.trackDeletedBackrefs = trackDeletedBackrefs;\r\n    }\r\n    // TODO: build benchmarks for backrefs and see if storing pointers to the trackers' entities\r\n    // arrays for direct access performs significantly better than looking them up in the indexer's\r\n    // Map each time.\r\n    defineElastic(binding, field) {\r\n        field.updateBuffer = () => { };\r\n        const refField = this.fieldName ?\r\n            this.type?.__binding.fields.find(aField => aField.name === this.fieldName) : undefined;\r\n        {\r\n            if (this.fieldName && !refField) {\r\n                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +\r\n                    `an unknown field ${this.type.name}.${this.fieldName}`);\r\n            }\r\n            if (refField && refField.type !== Type.ref) {\r\n                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +\r\n                    `a field ${this.type.name}.${this.fieldName} that is not a ref`);\r\n            }\r\n            if (this.fieldName && !this.type) {\r\n                throw new CheckError(`Backrefs selector has field but no component in ${binding.type.name}.${field.name}`);\r\n            }\r\n            if (this.type && !this.fieldName && !this.type.__binding.refFields.length) {\r\n                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +\r\n                    `component ${this.type.name} that has no ref fields`);\r\n            }\r\n        }\r\n        const trackDeletedBackrefs = this.trackDeletedBackrefs;\r\n        const indexer = binding.dispatcher.indexer;\r\n        indexer.registerSelector(); // make sure global selector always registered first\r\n        const selectorId = indexer.registerSelector(binding.type, this.type, refField?.seq, this.trackDeletedBackrefs);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                if (!trackDeletedBackrefs && binding.dispatcher.registry.includeRecentlyDeleted) {\r\n                    throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} not configured to track recently ` +\r\n                        `deleted refs`);\r\n                }\r\n                return indexer.getBackrefs(binding.writableEntityId, selectorId);\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value !== EMPTY_ARRAY) {\r\n                    throw new CheckError('Backrefs properties are computed automatically, you cannot set them');\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                if (!trackDeletedBackrefs && binding.dispatcher.registry.includeRecentlyDeleted) {\r\n                    throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} not configured to track recently ` +\r\n                        `deleted refs`);\r\n                }\r\n                return indexer.getBackrefs(binding.readonlyEntityId, selectorId);\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value !== EMPTY_ARRAY) {\r\n                    throw new CheckError('Backrefs properties are computed automatically, you cannot set them');\r\n                }\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        this.defineElastic(binding, field);\r\n    }\r\n}\r\nclass ObjectType extends Type {\r\n    constructor() { super(undefined, false); }\r\n    defineElastic(binding, field) {\r\n        const data = [];\r\n        field.updateBuffer = () => { };\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.writableIndex];\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.readonlyIndex];\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const data = new Array(binding.capacity);\r\n        field.updateBuffer = () => { };\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.writableIndex];\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.readonlyIndex];\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass WeakObjectType extends Type {\r\n    finalizers;\r\n    constructor() { super(undefined, false); }\r\n    defineElastic(binding, field) {\r\n        const data = [];\r\n        field.updateBuffer = () => { };\r\n        const finalizers = this.initFinalizers(binding);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const value = data[binding.writableIndex];\r\n                if (value === null || value === undefined)\r\n                    return value;\r\n                return value.deref();\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value !== null && value !== undefined) {\r\n                    const weakRef = new WeakRef(value);\r\n                    finalizers?.register(value, {\r\n                        type: binding.type, data, weakRef, id: binding.writableEntityId,\r\n                        index: binding.writableIndex\r\n                    });\r\n                    value = weakRef;\r\n                }\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const value = data[binding.readonlyIndex];\r\n                if (value === null || value === undefined)\r\n                    return value;\r\n                return value.deref();\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        this.defineElastic(binding, field);\r\n    }\r\n    initFinalizers(binding) {\r\n        if (!binding.trackedWrites)\r\n            return;\r\n        if (this.finalizers)\r\n            return this.finalizers;\r\n        const dispatcher = binding.dispatcher;\r\n        if (!dispatcher.writeLog || typeof FinalizationRegistry === 'undefined')\r\n            return;\r\n        this.finalizers = new FinalizationRegistry(({ type, data, weakRef, id, index }) => {\r\n            if (data[index] === weakRef)\r\n                dispatcher.registry.trackWrite(id, type);\r\n        });\r\n        return this.finalizers;\r\n    }\r\n}\r\n// The fields below are replicated in the @field decorator, keep them in sync.\r\nType.boolean = new BooleanType();\r\nType.uint8 = new NumberType(Uint8Array);\r\nType.int8 = new NumberType(Int8Array);\r\nType.uint16 = new NumberType(Uint16Array);\r\nType.int16 = new NumberType(Int16Array);\r\nType.uint32 = new NumberType(Uint32Array);\r\nType.int32 = new NumberType(Int32Array);\r\nType.float32 = new NumberType(Float32Array);\r\nType.float64 = new NumberType(Float64Array);\r\nType.vector = (type, elements, Class) => new VectorType(type, elements, Class);\r\nType.staticString = (choices) => new StaticStringType(choices);\r\nType.dynamicString = (maxUtf8Length) => new DynamicStringType(maxUtf8Length);\r\nType.ref = new RefType();\r\nType.backrefs = (type, fieldName, trackDeletedBackrefs = false) => new BackrefsType(type, fieldName, trackDeletedBackrefs);\r\nType.object = new ObjectType();\r\nType.weakObject = new WeakObjectType();\n\nclass Binding {\r\n    type;\r\n    fields;\r\n    dispatcher;\r\n    capacity;\r\n    storage;\r\n    elastic;\r\n    constructor(type, fields, shapeSpec, dispatcher, capacity, storage, elastic) {\r\n        this.type = type;\r\n        this.fields = fields;\r\n        this.dispatcher = dispatcher;\r\n        this.capacity = capacity;\r\n        this.storage = storage;\r\n        this.elastic = elastic;\r\n        this.readonlyMaster = this.readonlyInstance = new type(); // eslint-disable-line new-cap\r\n        this.writableMaster = this.writableInstance = new type(); // eslint-disable-line new-cap\r\n        {\r\n            this.readonlyInstance = Object.create(this.readonlyMaster);\r\n            this.readonlyInstance.__invalid = !this.elastic && this.capacity > 1;\r\n            this.writableInstance = Object.create(this.writableMaster);\r\n            this.writableInstance.__invalid = !this.elastic && this.capacity > 1;\r\n        }\r\n        this.shapeOffset = shapeSpec.offset;\r\n        this.shapeMask = shapeSpec.mask;\r\n        this.shapeValue = shapeSpec.value;\r\n        this.refFields = fields.filter(field => field.type === Type.ref);\r\n        this.trackedWrites = false;\r\n        this.writableEntityId = 0;\r\n        this.writableIndex = 0;\r\n        this.readonlyEntityId = 0;\r\n        this.readonlyIndex = 0;\r\n        // eslint-disable-next-line no-new-func\r\n        this.initDefault = new Function('component', fields\r\n            .filter(field => field.default !== EMPTY_ARRAY)\r\n            .map(field => `component.${field.name} = ${JSON.stringify(field.default)};`)\r\n            .join('\\n'));\r\n        let backrefFieldInits = [];\r\n        {\r\n            backrefFieldInits = fields\r\n                .filter(field => field.default === EMPTY_ARRAY)\r\n                .map(field => `\n          if (${JSON.stringify(field.name)} in values) {\n            component.${field.name} = values.${field.name};\n          }\n        `);\r\n        }\r\n        // eslint-disable-next-line no-new-func\r\n        this.init = new Function('component', 'values', fields\r\n            .filter(field => field.default !== EMPTY_ARRAY)\r\n            .map(field => `\n          component.${field.name} = values.${field.name} === undefined ?\n            ${JSON.stringify(field.default)} : values.${field.name};\n        `)\r\n            .concat(backrefFieldInits)\r\n            .join('\\n'));\r\n    }\r\n    resetWritableInstance(entityId, index) {\r\n        if (index === -1) {\r\n            throw new InternalError(`Attempt to bind unacquired entity ${entityId} to ${this.type.name}`);\r\n        }\r\n        this.writableEntityId = entityId;\r\n        this.writableIndex = index;\r\n        if (this.elastic || this.capacity > 1) {\r\n            this.writableInstance.__invalid = true;\r\n            this.writableInstance = Object.create(this.writableMaster);\r\n        }\r\n        return this.writableInstance;\r\n    }\r\n    resetReadonlyInstance(entityId, index) {\r\n        if (index === -1) {\r\n            throw new InternalError(`Attempt to bind unacquired entity ${entityId} to ${this.type.name}`);\r\n        }\r\n        this.readonlyEntityId = entityId;\r\n        this.readonlyIndex = index;\r\n        if (this.elastic || this.capacity > 1) {\r\n            this.readonlyInstance.__invalid = true;\r\n            this.readonlyInstance = Object.create(this.readonlyMaster);\r\n        }\r\n        return this.readonlyInstance;\r\n    }\r\n}\r\nfunction checkTypeDefined(type) {\r\n    if (!type.__binding) {\r\n        throw new CheckError(`Component ${type.name} not defined; add to world defs`);\r\n    }\r\n}\r\nclass PackedStorage {\r\n    maxEntities;\r\n    binding;\r\n    fields;\r\n    constructor(maxEntities, binding, fields) {\r\n        this.maxEntities = maxEntities;\r\n        this.binding = binding;\r\n        this.fields = fields;\r\n        this.growSpares();\r\n        this.growCapacity();\r\n    }\r\n    acquireIndex(id) {\r\n        let index = this.index[id];\r\n        if (index === -1) {\r\n            if (this.spares[3] > 0) {\r\n                index = this.spares[--this.spares[3] + 4];\r\n            }\r\n            else {\r\n                if (this.spares[1] === this.spares[2]) {\r\n                    if (!this.binding.elastic) {\r\n                        throw new CheckError(`Storage exhausted for component ${this.binding.type.name}; ` +\r\n                            `raise its capacity above ${this.binding.capacity}`);\r\n                    }\r\n                    if (this.binding.capacity === this.maxEntities) {\r\n                        throw new InternalError(`Trying to grow storage index for component ${this.binding.type.name} beyond ` +\r\n                            `maxEntities`);\r\n                    }\r\n                    this.binding.capacity = Math.min(this.maxEntities, this.binding.capacity * 2);\r\n                    this.growCapacity();\r\n                }\r\n                index = this.spares[1]++;\r\n            }\r\n            this.index[id] = index;\r\n        }\r\n        return index;\r\n    }\r\n    releaseIndex(id) {\r\n        if (this.index[id] === -1) {\r\n            throw new InternalError(`Index for entity ${id} in component ${this.binding.type.name} not allocated`);\r\n        }\r\n        if (this.spares[3] === this.spares.length - 4)\r\n            this.growSpares();\r\n        this.spares[this.spares[3]++ + 4] = this.index[id];\r\n        this.index[id] = -1;\r\n    }\r\n    growCapacity() {\r\n        const capacity = this.binding.capacity;\r\n        this.binding.dispatcher.stats.forComponent(this.binding.type).capacity = capacity;\r\n        const ArrayType = this.ArrayType;\r\n        const elementSizeChanged = ArrayType.BYTES_PER_ELEMENT !== this.spares?.[0];\r\n        if (!this.index || elementSizeChanged) {\r\n            this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.index`, this.maxEntities, ArrayType, (index) => { this.index = index; }, -1);\r\n        }\r\n        if (elementSizeChanged) {\r\n            this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.spares`, this.spares.length, ArrayType, this.updateSpares.bind(this));\r\n        }\r\n        else {\r\n            this.spares[2] = capacity;\r\n        }\r\n        if (this.binding.elastic)\r\n            for (const field of this.fields)\r\n                field.updateBuffer();\r\n    }\r\n    growSpares() {\r\n        const maxSpares = this.spares ? Math.min(this.maxEntities, (this.spares.length - 4) * 2) : 8;\r\n        this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.spares`, 4 + maxSpares, this.ArrayType, this.updateSpares.bind(this));\r\n    }\r\n    updateSpares(spares) {\r\n        spares[2] = this.binding.capacity = Math.max(this.binding.capacity, spares[2]);\r\n        spares[0] = this.ArrayType.BYTES_PER_ELEMENT;\r\n        this.spares = spares;\r\n    }\r\n    get ArrayType() {\r\n        const capacity = Math.max(this.spares?.[2] ?? 0, this.binding.capacity);\r\n        return capacity < (1 << 7) ? Int8Array : capacity < (1 << 15) ? Int16Array : Int32Array;\r\n    }\r\n}\r\nclass CompactStorage {\r\n    maxEntities;\r\n    binding;\r\n    fields;\r\n    constructor(maxEntities, binding, fields) {\r\n        this.maxEntities = maxEntities;\r\n        this.binding = binding;\r\n        this.fields = fields;\r\n        this.growCapacity();\r\n    }\r\n    findIndex(id) {\r\n        for (let i = 0; i < this.index.length; i++) {\r\n            if (this.index[i] === id)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n    acquireIndex(id) {\r\n        let firstEmpty;\r\n        for (let i = 0; i < this.index.length; i++) {\r\n            if (this.index[i] === id)\r\n                return i;\r\n            if (firstEmpty === undefined && this.index[i] === -1)\r\n                firstEmpty = i;\r\n        }\r\n        if (firstEmpty === undefined) {\r\n            if (!this.binding.elastic) {\r\n                throw new CheckError(`Storage exhausted for component ${this.binding.type.name}; ` +\r\n                    `raise its capacity above ${this.binding.capacity}`);\r\n            }\r\n            if (this.binding.capacity === this.maxEntities) {\r\n                throw new InternalError(`Trying to grow storage index for component ${this.binding.type.name} beyond ` +\r\n                    `maxEntities`);\r\n            }\r\n            firstEmpty = this.index.length;\r\n            this.binding.capacity = Math.min(this.maxEntities, this.binding.capacity * 2);\r\n            this.growCapacity();\r\n        }\r\n        this.index[firstEmpty] = id;\r\n        return firstEmpty;\r\n    }\r\n    releaseIndex(id) {\r\n        for (let i = 0; i < this.index.length; i++) {\r\n            if (this.index[i] === id) {\r\n                this.index[i] = -1;\r\n                return;\r\n            }\r\n        }\r\n        throw new InternalError(`Index for entity ${id} in component ${this.binding.type.name} not allocated`);\r\n    }\r\n    growCapacity() {\r\n        const capacity = this.binding.capacity;\r\n        this.binding.dispatcher.stats.forComponent(this.binding.type).capacity = capacity;\r\n        this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.index`, capacity, Int32Array, this.updateIndex.bind(this), -1);\r\n        if (this.binding.elastic)\r\n            for (const field of this.fields)\r\n                field.updateBuffer();\r\n    }\r\n    updateIndex(index) {\r\n        this.index = index;\r\n        this.binding.capacity = this.index.length;\r\n    }\r\n}\r\nfunction initComponent(type, id, values) {\r\n    {\r\n        checkTypeDefined(type);\r\n        if (values !== undefined) {\r\n            for (const key in values) {\r\n                if (!type.schema?.[key]) {\r\n                    throw new CheckError(`Property ${key} not defined for component ${type.name}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const component = type.__allocate(id);\r\n    if (values) {\r\n        type.__binding.init(component, values);\r\n    }\r\n    else {\r\n        type.__binding.initDefault(component);\r\n    }\r\n}\r\nfunction gatherFields(type) {\r\n    const schema = type.schema;\r\n    const fields = [];\r\n    if (schema) {\r\n        let seq = 0;\r\n        for (const name in schema) {\r\n            let entry = schema[name];\r\n            if (entry instanceof Type || typeof entry === 'function')\r\n                entry = { type: entry };\r\n            if (typeof entry.type === 'function')\r\n                entry.type = entry.type();\r\n            if (!('default' in entry))\r\n                entry.default = entry.type.defaultValue;\r\n            fields.push({ name, seq: seq++, type: entry.type, default: entry.default });\r\n        }\r\n        if (seq > MAX_NUM_FIELDS) {\r\n            throw new CheckError(`Component ${type.name} declares too many fields`);\r\n        }\r\n    }\r\n    return fields;\r\n}\r\nfunction assimilateComponentType(typeId, type, shapeSpec, dispatcher) {\r\n    const fields = gatherFields(type);\r\n    // For tag components, force sparse storage since we don't actually need to allocate anything.\r\n    const storage = fields.length ? (type.options?.storage ?? dispatcher.defaultComponentStorage) : 'sparse';\r\n    const capacity = storage === 'sparse' ?\r\n        dispatcher.maxEntities : Math.min(dispatcher.maxEntities, type.options?.capacity ?? 0);\r\n    const initialCapacity = type.options?.initialCapacity ?? 8;\r\n    {\r\n        if (typeof type.options?.capacity !== 'undefined') {\r\n            if (storage === 'sparse') {\r\n                throw new CheckError(`Component type ${type.name} cannot combine custom capacity with sparse storage`);\r\n            }\r\n            if (type.options.capacity <= 0) {\r\n                throw new CheckError(`Component type ${type.name} capacity option must be great than zero: got ${capacity}`);\r\n            }\r\n            if (typeof type.options.initialCapacity !== 'undefined') {\r\n                throw new CheckError(`Component type ${type.name} cannot have both capacity and initialCapacity options`);\r\n            }\r\n        }\r\n        if (type.options?.restrictedToMainThread && fields.every(field => field.type.shared)) {\r\n            throw new CheckError(`Component type ${type.name} is restrictedToMainThread but has no thread-exclusive fields`);\r\n        }\r\n        if ((typeof process === 'undefined' || process.env.NODE_ENV !== 'test') && type.__bind) {\r\n            throw new CheckError(`Component type ${type.name} is already in use in another world`);\r\n        }\r\n    }\r\n    type.id = typeId;\r\n    const binding = new Binding(type, fields, shapeSpec, dispatcher, capacity || initialCapacity, storage, !capacity);\r\n    type.__binding = binding;\r\n}\r\nfunction defineAndAllocateComponentType(type) {\r\n    const binding = type.__binding;\r\n    for (const field of binding.fields) {\r\n        if (binding.elastic) {\r\n            field.type.defineElastic(binding, field);\r\n        }\r\n        else {\r\n            field.type.defineFixed(binding, field);\r\n        }\r\n    }\r\n    switch (binding.storage) {\r\n        case 'sparse':\r\n            // Inline the trivial storage manager for performance.\r\n            binding.dispatcher.stats.forComponent(type).capacity = binding.capacity; // fixed\r\n            type.__bind = (id, writable) => {\r\n                return writable ?\r\n                    binding.resetWritableInstance(id, id) :\r\n                    binding.resetReadonlyInstance(id, id);\r\n            };\r\n            type.__allocate = (id) => {\r\n                return binding.resetWritableInstance(id, id);\r\n            };\r\n            break;\r\n        case 'packed': {\r\n            const storageManager = new PackedStorage(binding.dispatcher.maxEntities, binding, binding.fields);\r\n            type.__bind = (id, writable) => {\r\n                return writable ?\r\n                    binding.resetWritableInstance(id, storageManager.index[id]) :\r\n                    binding.resetReadonlyInstance(id, storageManager.index[id]);\r\n            };\r\n            type.__allocate = (id) => {\r\n                return binding.resetWritableInstance(id, storageManager.acquireIndex(id));\r\n            };\r\n            type.__free = (id) => {\r\n                storageManager.releaseIndex(id);\r\n            };\r\n            break;\r\n        }\r\n        case 'compact': {\r\n            const storageManager = new CompactStorage(binding.dispatcher.maxEntities, binding, binding.fields);\r\n            type.__bind = (id, writable) => {\r\n                return writable ?\r\n                    binding.resetWritableInstance(id, storageManager.findIndex(id)) :\r\n                    binding.resetReadonlyInstance(id, storageManager.findIndex(id));\r\n            };\r\n            type.__allocate = (id) => {\r\n                return binding.resetWritableInstance(id, storageManager.acquireIndex(id));\r\n            };\r\n            type.__free = (id) => {\r\n                storageManager.releaseIndex(id);\r\n            };\r\n            break;\r\n        }\r\n        default:\r\n            throw new CheckError(`Invalid storage type \"${binding.storage}`);\r\n    }\r\n}\r\nfunction dissimilateComponentType(type) {\r\n    delete type.id;\r\n    delete type.__binding;\r\n    delete type.__bind;\r\n    delete type.__allocate;\r\n    delete type.__free;\r\n}\r\nfunction declareSingleton(type) {\r\n    if (!type.options)\r\n        type.options = {};\r\n    {\r\n        if (type.options.storage && type.options.storage !== 'compact') {\r\n            throw new CheckError(`Component ${type.name} ${type.options.storage} storage is incompatible with singletons`);\r\n        }\r\n        if (type.options.capacity && type.options.capacity !== 1) {\r\n            throw new CheckError(`Component ${type.name} capacity of ${type.options.capacity} ` +\r\n                `is incompatible with singletons`);\r\n        }\r\n        if (type.options.initialCapacity) {\r\n            throw new CheckError(`Component ${type.name} initial capacity of ${type.options.initialCapacity} ` +\r\n                `is incompatible with singletons`);\r\n        }\r\n    }\r\n    type.options.storage = 'compact';\r\n    type.options.capacity = 1;\r\n}\n\n/**\r\n * An entity represents a collection of distinct components with a unique identity.\r\n *\r\n * You can obtain entities from queries in your system.  You must not keep references to entities\r\n * thus obtained, as they may be pointed to another entity at any time between system executions.\r\n * Instead, call {@link Entity.hold} to obtain a long-lived version of the object.\r\n */\r\nclass EntityImpl {\r\n    __registry;\r\n    constructor(__registry) {\r\n        this.__registry = __registry;\r\n        this.__id = undefined;\r\n        this.__sortKey = undefined;\r\n        {\r\n            this.__valid = true;\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether the entity is alive, i.e. has not been deleted.  Turning on\r\n     * `accessRecentlyDeletedData` doesn't affect the return value.\r\n     */\r\n    get alive() {\r\n        this.__checkValid();\r\n        return this.__registry.hasShape(this.__id, this.__registry.Alive, false);\r\n    }\r\n    /**\r\n     * Returns the entity's ordinal number, as determined by the order of entity creation.  Entities\r\n     * created in systems running concurrently may have overlapping ordinals.\r\n     */\r\n    get ordinal() {\r\n        return this.__registry.entityOrdinals[this.__id];\r\n    }\r\n    /**\r\n     * Adds a component to the entity.  If the entity already possesses a component of this type the\r\n     * call will fail.\r\n     * @param type The type of component to add.\r\n     * @param values An optional object with field values to initialize the new component.\r\n     */\r\n    add(type, values) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'write');\r\n            if (!this.__registry.hasShape(this.__id, this.__registry.Alive, false)) {\r\n                throw new CheckError('Entity has been deleted');\r\n            }\r\n            if (this.__registry.hasShape(this.__id, type, false)) {\r\n                throw new CheckError(`Entity already has a ${type.name} component`);\r\n            }\r\n        }\r\n        this.__registry.setShape(this.__id, type);\r\n        this.__registry.dispatcher.stats.forComponent(type).numEntities += 1;\r\n        initComponent(type, this.__id, values);\r\n    }\r\n    /**\r\n     * Adds a list of components to the entity.  If entity already possesses a component of any of\r\n     * the given types, the call will fail.\r\n     * @param args A list of component types to add, optionally interleaved wth objects that specify\r\n     *  fields values for initializing the immediately preceding component.\r\n     */\r\n    addAll(...args) {\r\n        this.__checkValid();\r\n        {\r\n            const enums = new Set();\r\n            for (const arg of args) {\r\n                if (typeof arg === 'function' && arg.enum) {\r\n                    if (enums.has(arg.enum)) {\r\n                        throw new CheckError(`Can't add multiple components from the same enum`);\r\n                    }\r\n                    enums.add(arg.enum);\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < args.length; i++) {\r\n            const type = args[i];\r\n            {\r\n                if (typeof type !== 'function') {\r\n                    throw new CheckError(`Bad arguments to addAll: expected component type, got: ${type}`);\r\n                }\r\n            }\r\n            let value = args[i + 1];\r\n            if (typeof value === 'function')\r\n                value = undefined;\r\n            else\r\n                i++;\r\n            this.add(type, value);\r\n        }\r\n    }\r\n    /**\r\n     * Remove a component from the entity.  If the entity doesn't possess a component of this type\r\n     * the call will fail.\r\n     * @param type The type of component to remove.\r\n     */\r\n    remove(type) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'write');\r\n            if (typeof type === 'function')\r\n                this.__checkHas(type, false);\r\n        }\r\n        if (typeof type !== 'function') {\r\n            const currentType = this.__registry.getEnumShape(this.__id, type, false);\r\n            if (!currentType) {\r\n                throw new CheckError(`Entity doesn't have any components from ${type.name} enumeration`);\r\n            }\r\n            type = currentType;\r\n        }\r\n        this.__registry.clearShape(this.__id, type);\r\n    }\r\n    /**\r\n     * Remove a list of components from the entity.  If the entity doesn't possess a component of any\r\n     * of the given types, the call will fail.\r\n     * @param types A list of component types to remove.\r\n     */\r\n    removeAll(...types) {\r\n        for (const type of types)\r\n            this.remove(type);\r\n    }\r\n    /**\r\n     * Returns whether the entity currently contains a component of the given type.  If a system is\r\n     * running in `accessRecentlyDeletedData` mode, this will also return true for recently removed\r\n     * components.\r\n     *\r\n     * @param type The type of component to check for.\r\n     * @returns Whether the entity has a component of the given type.\r\n     */\r\n    has(type) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'check');\r\n        }\r\n        if (typeof type === 'function')\r\n            return this.__registry.hasShape(this.__id, type, true);\r\n        return !!this.__registry.getEnumShape(this.__id, type, true);\r\n    }\r\n    // TODO: see if precomputing the masks and using Registry.match gets better performance on the\r\n    // following has* methods.\r\n    /**\r\n     * Returns whether the entity currently contains a component of any of the given types.  If a\r\n     * system is running in `accessRecentlyDeletedData` mode, this will also consider recently removed\r\n     * components.\r\n     * @param types A list of component types to check for.\r\n     * @returns Whether the entity has a component of at least one of the given types.\r\n     */\r\n    hasSomeOf(...types) {\r\n        this.__checkValid();\r\n        for (const type of types)\r\n            if (this.has(type))\r\n                return true;\r\n        return false;\r\n    }\r\n    /**\r\n     * Returns whether the entity currently contains a component of every one of the given types.  If\r\n     * a system is running in `accessRecentlyDeletedData` mode, this will also consider recently\r\n     * removed components.\r\n     * @param types A list of component types to check for.\r\n     * @returns Whether the entity has a component of every one of the given types.\r\n     */\r\n    hasAllOf(...types) {\r\n        this.__checkValid();\r\n        for (const type of types)\r\n            if (!this.has(type))\r\n                return false;\r\n        return true;\r\n    }\r\n    /**\r\n     * Returns whether the entity currently contains a component of any type other than the given\r\n     * ones.  If a system is running in `accessRecentlyDeletedData` mode, this will also consider\r\n     * recently removed components.\r\n     * @param types A list of component types to exclude from the check.\r\n     * @returns Whether the entity has a component of a type not given.\r\n     */\r\n    hasAnyOtherThan(...types) {\r\n        this.__checkValid();\r\n        const typeSet = new Set(types);\r\n        for (const type of this.__registry.types) {\r\n            this.__checkMask(type, 'check');\r\n            if (!(typeSet.has(type) || type.enum && typeSet.has(type.enum)) &&\r\n                this.__registry.hasShape(this.__id, type, true))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Counts the number of components of the given types the entity currently contains. If a system\r\n     * is running in `accessRecentlyDeletedData` mode, this will also consider recently removed\r\n     * components.\r\n     * @param types A list of component types to count.\r\n     * @returns The number of components present from among the given types.\r\n     */\r\n    countHas(...types) {\r\n        this.__checkValid();\r\n        let count = 0;\r\n        for (const type of types)\r\n            if (this.has(type))\r\n                count += 1;\r\n        return count;\r\n    }\r\n    /**\r\n     * Returns the type from the given enumeration currently contained by the entity, if any.  If a\r\n     * system is running in `accessRecentlyDeletedData` mode, this will also consider recently removed\r\n     * components.\r\n     * @param enumeration The enumeration of the desired types.\r\n     * @returns A type from the enumeration if contained by the entity, or `undefined` if none.\r\n     */\r\n    hasWhich(enumeration) {\r\n        this.__checkValid();\r\n        this.__checkMask(enumeration, 'check');\r\n        return this.__registry.getEnumShape(this.__id, enumeration, true);\r\n    }\r\n    /**\r\n     * Obtains a component of the entity that will not allow writing to its fields.  If a component of\r\n     * the given type is not part of this entity this method will fail, unless a system is running in\r\n     * `accessRecentlyDeletedData` mode and the component was only recently removed.\r\n     *\r\n     * The component returned must be used immediately; you must not retain a reference to it beyond\r\n     * the local scope.  Any subsequent request to read the same component type on any entity will\r\n     * invalidate the object.\r\n     * @param type The type of component to obtain.\r\n     * @returns The component of the given type that is part of the entity, ready for reading.\r\n     */\r\n    read(type) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'read');\r\n            this.__checkHas(type, true);\r\n        }\r\n        return type.__bind(this.__id, false);\r\n    }\r\n    /**\r\n     * Obtains a component of the entity that will allow writing to its fields, and mark the component\r\n     * as having been written to (for `changed` queries).  If a component of the given type is not\r\n     * part of this entity this method will fail, unless a system is running in\r\n     * `accessRecentlyDeletedData` mode and the component was only recently removed.\r\n     *\r\n     * The component returned must be used immediately; you must not retain a reference to it beyond\r\n     * the local scope.  Any subsequent request to write the same component type on any entity will\r\n     * invalidate the object.\r\n     * @param type The type of component to obtain.\r\n     * @returns The component of the given type that is part of the entity, ready for reading and\r\n     *  writing.\r\n     */\r\n    write(type) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'write');\r\n            this.__checkHas(type, true);\r\n        }\r\n        if (type.__binding.trackedWrites)\r\n            this.__registry.trackWrite(this.__id, type);\r\n        return type.__bind(this.__id, true);\r\n    }\r\n    /**\r\n     * Deletes this entity and removes all its components.\r\n     */\r\n    delete() {\r\n        this.__checkValid();\r\n        const Alive = this.__registry.Alive;\r\n        if (!this.__registry.hasShape(this.__id, Alive, false)) {\r\n            throw new CheckError('Entity already deleted');\r\n        }\r\n        for (const type of this.__registry.types) {\r\n            if (this.__registry.hasShape(this.__id, type, false)) {\r\n                if (type !== Alive)\r\n                    this.__checkMask(type, 'write');\r\n                this.__registry.clearShape(this.__id, type);\r\n            }\r\n        }\r\n        this.__registry.dispatcher.indexer.clearAllRefs(this.__id, false);\r\n    }\r\n    /**\r\n     * Creates a long-lived version of this entity object, that you can safely keep for as long as the\r\n     * entity exists.  Once the entity is deleted (and swept up after the end of the next frame) all\r\n     * further calls on the object will fail.\r\n     * @returns A long-lived version of this entity object.\r\n     */\r\n    hold() {\r\n        this.__checkValid();\r\n        return this.__registry.holdEntity(this.__id);\r\n    }\r\n    /**\r\n     * Returns whether this entity and another one are in fact the same entity.  This can be useful\r\n     * for comparing held entities to transient query ones.\r\n     * @param other The other entity to match against.\r\n     * @returns Whether this entity and the other one are the same.\r\n     */\r\n    isSame(other) {\r\n        this.__checkValid();\r\n        return this.__id === other.__id;\r\n    }\r\n    __checkMask(type, kind) {\r\n        checkMask(type, this.__registry.executingSystem, kind);\r\n    }\r\n    __checkHas(type, allowRecentlyDeleted) {\r\n        if (!this.__registry.hasShape(this.__id, type, allowRecentlyDeleted)) {\r\n            throw new CheckError(`Entity doesn't have a ${type.name} component`);\r\n        }\r\n    }\r\n    __checkValid() {\r\n        if (!this.__valid)\r\n            throw new CheckError('Entity handle no longer valid');\r\n    }\r\n}\r\nfunction checkMask(type, system, kind) {\r\n    checkTypeDefined(type);\r\n    const mask = system?.accessMasks[kind];\r\n    if (!mask)\r\n        return;\r\n    // Inline isMaskFlagSet for performance.\r\n    const binding = type.__binding;\r\n    if (((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) === 0) {\r\n        throw new CheckError(`System ${system.name} didn't mark component ${type.name} as ${kind}able`);\r\n    }\r\n}\r\nfunction isMaskFlagSet(mask, type) {\r\n    const binding = type.__binding;\r\n    return ((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) !== 0;\r\n}\r\nfunction extendMaskAndSetFlag(mask, type, useValues = false) {\r\n    checkTypeDefined(type);\r\n    const flagOffset = type.__binding.shapeOffset;\r\n    if (flagOffset >= mask.length) {\r\n        const oldLength = mask.length;\r\n        mask.length = flagOffset + 1;\r\n        mask.fill(0, oldLength, flagOffset);\r\n    }\r\n    mask[flagOffset] |=\r\n        useValues ? type.__binding.shapeValue : type.__binding.shapeMask;\r\n}\n\nconst HEADER_LENGTH$1 = 2;\r\nconst EMPTY_TUPLE = [];\r\n/**\r\n * A circular log of u32 numbers with smart pointers into it.  When the log wraps around it\r\n * increments a generation counter so you can tell if your pointer got lapped and is now invalid.\r\n */\r\nclass Log {\r\n    maxEntries;\r\n    configParamName;\r\n    options;\r\n    /* layout: [index, generation, ...entries] */\r\n    data;\r\n    /* layout: [length, generation, ...entries] */\r\n    corral;\r\n    /* layout: [length, unused, ...entries] */\r\n    staging;\r\n    typeCounters;\r\n    constructor(maxEntries, configParamName, buffers, options = {\r\n        localProcessingAllowed: false, sortedByComponentType: false, numComponentTypes: 0\r\n    }) {\r\n        this.maxEntries = maxEntries;\r\n        this.configParamName = configParamName;\r\n        this.options = options;\r\n        buffers.register(`log.${configParamName}.buffer`, maxEntries + HEADER_LENGTH$1, Uint32Array, (data) => { this.data = data; });\r\n        buffers.register(`log.${configParamName}.corral`, maxEntries + HEADER_LENGTH$1, Uint32Array, (corral) => { this.corral = corral; });\r\n        if (options.sortedByComponentType) {\r\n            if (options.numComponentTypes === undefined) {\r\n                throw new InternalError(`numComponentTypes required when ${this.configParamName} is sortedByComponentType`);\r\n            }\r\n            buffers.register(`log.${configParamName}.staging`, maxEntries + HEADER_LENGTH$1, Uint32Array, (staging) => { this.staging = staging; });\r\n            this.typeCounters = new Uint32Array(this.options.numComponentTypes);\r\n        }\r\n    }\r\n    push(value, type) {\r\n        const corralLength = this.corral[0];\r\n        if (corralLength >= this.maxEntries)\r\n            this.throwCapacityExceeded();\r\n        if (corralLength && this.corral[corralLength] === value)\r\n            return;\r\n        this.corral[corralLength + HEADER_LENGTH$1] = value;\r\n        this.corral[0] += 1;\r\n        if (!!type !== !!this.options.sortedByComponentType) {\r\n            throw new InternalError(`Pushing value ${type ? 'with' : 'without'} type to log ${this.configParamName} ` +\r\n                `${this.options.sortedByComponentType ? '' : 'not '}sorted by component type`);\r\n        }\r\n        if (type)\r\n            this.typeCounters[type.id] += 1;\r\n    }\r\n    commit(pointer) {\r\n        if (!pointer && this.options.localProcessingAllowed) {\r\n            throw new InternalError(`Cannot use blind commit when local processing is allowed in log ${this.configParamName}`);\r\n        }\r\n        if (!this.corral[0])\r\n            return true;\r\n        if (pointer && !(pointer.generation === this.data[1] && pointer.index === this.data[0] &&\r\n            pointer.corralGeneration === this.corral[1] && pointer.corralIndex === this.corral[0]))\r\n            return false;\r\n        this.copyToData(this.staging ? this.sortCorral() : this.corral);\r\n        this.corral[0] = 0;\r\n        this.corral[1] += 1;\r\n        if (pointer) {\r\n            pointer.index = this.data[0];\r\n            pointer.generation = this.data[1];\r\n        }\r\n        return true;\r\n    }\r\n    sortCorral() {\r\n        let offset = HEADER_LENGTH$1, soleTypeId = -1, soleTypeCount = 0, numNonZeroTypes = 0;\r\n        for (let typeId = 0; typeId < this.typeCounters.length; typeId++) {\r\n            const count = this.typeCounters[typeId];\r\n            if (!count)\r\n                continue;\r\n            numNonZeroTypes += 1;\r\n            if (soleTypeId === -1) {\r\n                soleTypeId = typeId;\r\n                soleTypeCount = count;\r\n            }\r\n            else if (soleTypeId >= 0) {\r\n                soleTypeId = -2;\r\n            }\r\n            if (count === 1) {\r\n                this.typeCounters[typeId] = offset;\r\n                offset += 1;\r\n            }\r\n            else {\r\n                this.typeCounters[typeId] = offset + 1;\r\n                this.staging[offset] = count | (typeId << ENTITY_ID_BITS) | 2 ** 31;\r\n                offset += count + 1;\r\n            }\r\n        }\r\n        if (soleTypeId >= 0) {\r\n            if (soleTypeCount > 1) {\r\n                if (this.corral[0] === this.maxEntries)\r\n                    this.throwCapacityExceeded();\r\n                this.corral[this.corral[0] + HEADER_LENGTH$1] = this.corral[HEADER_LENGTH$1];\r\n                this.corral[HEADER_LENGTH$1] = this.corral[0] | (soleTypeId << ENTITY_ID_BITS) | 2 ** 31;\r\n                this.corral[0] += 1;\r\n            }\r\n            this.typeCounters.fill(0);\r\n            return this.corral;\r\n        }\r\n        if (this.corral[0] + numNonZeroTypes > this.maxEntries)\r\n            this.throwCapacityExceeded();\r\n        const corralAndHeaderLength = this.corral[0] + HEADER_LENGTH$1;\r\n        for (let i = HEADER_LENGTH$1; i < corralAndHeaderLength; i++) {\r\n            const value = this.corral[i];\r\n            const typeId = value >>> ENTITY_ID_BITS;\r\n            this.staging[this.typeCounters[typeId]++] = value;\r\n        }\r\n        this.staging[0] = offset - HEADER_LENGTH$1;\r\n        this.typeCounters.fill(0);\r\n        return this.staging;\r\n    }\r\n    copyToData(source) {\r\n        let index = this.data[0];\r\n        const length = source[0];\r\n        const firstSegmentLength = Math.min(length, this.maxEntries - index);\r\n        this.data.set(source.subarray(HEADER_LENGTH$1, firstSegmentLength + HEADER_LENGTH$1), index + HEADER_LENGTH$1);\r\n        if (firstSegmentLength < length) {\r\n            this.data.set(source.subarray(firstSegmentLength + HEADER_LENGTH$1, length + HEADER_LENGTH$1), HEADER_LENGTH$1);\r\n        }\r\n        index += length;\r\n        while (index >= this.maxEntries) {\r\n            index -= this.maxEntries;\r\n            this.data[1] += 1;\r\n        }\r\n        this.data[0] = index;\r\n    }\r\n    createPointer(pointer) {\r\n        if (!pointer) {\r\n            return {\r\n                index: this.data[0], generation: this.data[1],\r\n                corralIndex: this.corral[0], corralGeneration: this.corral[1]\r\n            };\r\n        }\r\n        pointer.index = this.data[0];\r\n        pointer.generation = this.data[1];\r\n        pointer.corralIndex = this.corral[0];\r\n        pointer.corralGeneration = this.corral[1];\r\n        return pointer;\r\n    }\r\n    copyPointer(pointer) {\r\n        return {\r\n            index: pointer.index, generation: pointer.generation,\r\n            corralIndex: pointer.corralIndex, corralGeneration: pointer.corralGeneration\r\n        };\r\n    }\r\n    hasUpdatesSince(pointer) {\r\n        this.checkPointer(pointer);\r\n        return !(pointer.index === this.data[0] && pointer.generation === this.data[1] &&\r\n            (pointer.corralGeneration === this.corral[1] ?\r\n                pointer.corralIndex === this.corral[0] : this.corral[0] === 0));\r\n    }\r\n    processSince(startPointer, endPointer) {\r\n        this.checkPointers(startPointer, endPointer);\r\n        let result = EMPTY_TUPLE;\r\n        const endIndex = endPointer?.index ?? this.data[0];\r\n        const endGeneration = endPointer?.generation ?? this.data[1];\r\n        if (startPointer.generation === endGeneration) {\r\n            if (startPointer.index < endIndex) {\r\n                result = [\r\n                    this.data, startPointer.index + HEADER_LENGTH$1, endIndex + HEADER_LENGTH$1, false\r\n                ];\r\n                startPointer.index = endIndex;\r\n            }\r\n            else {\r\n                const corralLength = this.corral[0];\r\n                const corralGeneration = this.corral[1];\r\n                const corralHasNewEntries = startPointer.corralGeneration === corralGeneration ?\r\n                    startPointer.corralIndex < corralLength : corralLength;\r\n                if (corralHasNewEntries) {\r\n                    result = [\r\n                        this.corral, startPointer.corralIndex + HEADER_LENGTH$1,\r\n                        corralLength + HEADER_LENGTH$1, true\r\n                    ];\r\n                    startPointer.corralIndex = corralLength;\r\n                    startPointer.corralGeneration = corralGeneration;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            result = [this.data, startPointer.index + HEADER_LENGTH$1, this.data.length, false];\r\n            startPointer.index = 0;\r\n            startPointer.generation = endGeneration;\r\n        }\r\n        return result;\r\n    }\r\n    processAndCommitSince(startPointer) {\r\n        const result = this.processSince(startPointer);\r\n        if (result[0])\r\n            return result;\r\n        if (this.commit(startPointer))\r\n            return EMPTY_TUPLE;\r\n        return this.processSince(startPointer);\r\n    }\r\n    countSince(startPointer, endPointer) {\r\n        this.checkPointers(startPointer, endPointer);\r\n        if (this.corral[0]) {\r\n            throw new InternalError(`Should commit log ${this.configParamName} before counting`);\r\n        }\r\n        const startIndex = startPointer.index;\r\n        const startGeneration = startPointer.generation;\r\n        const endIndex = endPointer?.index ?? this.data[0];\r\n        const endGeneration = endPointer?.generation ?? this.data[1];\r\n        startPointer.index = endIndex;\r\n        startPointer.generation = endGeneration;\r\n        if (startIndex === endIndex && startGeneration === endGeneration)\r\n            return 0;\r\n        if (startIndex < endIndex)\r\n            return endIndex - startIndex;\r\n        return this.maxEntries - (startIndex - endIndex);\r\n    }\r\n    checkPointers(startPointer, endPointer) {\r\n        this.checkPointer(startPointer);\r\n        if (endPointer) {\r\n            this.checkPointer(endPointer);\r\n            {\r\n                if (startPointer.index > endPointer.index &&\r\n                    startPointer.generation >= endPointer.generation) {\r\n                    throw new InternalError(`Start pointer exceeds end pointer in log ${this.configParamName}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    checkPointer(pointer) {\r\n        const index = this.data[0];\r\n        let generation = pointer.generation;\r\n        if (pointer.index === index) {\r\n            if (generation + 1 < this.data[1])\r\n                this.throwCapacityExceeded();\r\n        }\r\n        else {\r\n            if (pointer.index > index)\r\n                generation += 1;\r\n            if (generation !== this.data[1])\r\n                this.throwCapacityExceeded();\r\n        }\r\n        {\r\n            if (pointer.corralGeneration > this.corral[1]) {\r\n                throw new InternalError(`Pointer corral generation older than corral in log ${this.configParamName}`);\r\n            }\r\n            if (pointer.corralGeneration === this.corral[1] && pointer.corralIndex > this.corral[0]) {\r\n                throw new InternalError(`Pointer past end of corral area in log ${this.configParamName}`);\r\n            }\r\n        }\r\n    }\r\n    throwCapacityExceeded() {\r\n        throw new CheckError(`Log capacity exceeded, please raise ${this.configParamName} above ${this.maxEntries}`);\r\n    }\r\n}\n\n/**\r\n * A fixed but arbitrary size bitset.\r\n */\r\nclass Bitset {\r\n    size;\r\n    bytes;\r\n    constructor(size) {\r\n        this.size = size;\r\n        this.bytes = new Uint32Array(Math.ceil(size / 32));\r\n    }\r\n    get(index) {\r\n        {\r\n            if (index < 0 || index >= this.size) {\r\n                throw new InternalError(`Bit index out of bounds: ${index}`);\r\n            }\r\n        }\r\n        return (this.bytes[index >>> 5] & (1 << (index & 31))) !== 0;\r\n    }\r\n    set(index) {\r\n        {\r\n            if (index < 0 || index >= this.size) {\r\n                throw new InternalError(`Bit index out of bounds: ${index}`);\r\n            }\r\n        }\r\n        this.bytes[index >>> 5] |= (1 << (index & 31));\r\n    }\r\n    unset(index) {\r\n        {\r\n            if (index < 0 || index >= this.size) {\r\n                throw new InternalError(`Bit index out of bounds: ${index}`);\r\n            }\r\n        }\r\n        this.bytes[index >>> 5] &= ~(1 << (index & 31));\r\n    }\r\n    clear() {\r\n        this.bytes.fill(0);\r\n    }\r\n}\n\nclass ArrayEntityList {\r\n    pool;\r\n    orderBy;\r\n    entities = [];\r\n    maxOrderKey = -Infinity;\r\n    sorted = true;\r\n    constructor(pool, orderBy) {\r\n        this.pool = pool;\r\n        this.orderBy = orderBy;\r\n    }\r\n    add(id) {\r\n        const entity = this.pool.borrowTemporarily(id);\r\n        if (this.orderBy) {\r\n            const orderKey = this.orderBy(entity);\r\n            if (orderKey >= this.maxOrderKey) {\r\n                this.maxOrderKey = orderKey;\r\n            }\r\n            else {\r\n                this.sorted = false;\r\n            }\r\n        }\r\n        this.entities.push(entity);\r\n    }\r\n    clear() {\r\n        if (this.entities.length)\r\n            this.entities.length = 0;\r\n        this.maxOrderKey = -Infinity;\r\n        this.sorted = true;\r\n    }\r\n    sort() {\r\n        if (this.sorted)\r\n            return;\r\n        const orderBy = this.orderBy;\r\n        for (const entity of this.entities)\r\n            entity.__sortKey = orderBy(entity);\r\n        this.entities.sort((a, b) => {\r\n            return a.__sortKey < b.__sortKey ? -1 : a.__sortKey > b.__sortKey ? +1 : 0;\r\n        });\r\n        this.sorted = true;\r\n    }\r\n}\r\nclass PackedArrayEntityList {\r\n    pool;\r\n    orderBy;\r\n    entities = [];\r\n    lookupTable;\r\n    maxOrderKey = -Infinity;\r\n    sorted = true;\r\n    constructor(pool, orderBy, maxEntities) {\r\n        this.pool = pool;\r\n        this.orderBy = orderBy;\r\n        this.lookupTable = new Int32Array(maxEntities);\r\n        this.lookupTable.fill(-1);\r\n    }\r\n    add(id) {\r\n        const entity = this.pool.borrow(id);\r\n        if (this.orderBy) {\r\n            const orderKey = this.orderBy(entity);\r\n            if (orderKey >= this.maxOrderKey) {\r\n                this.maxOrderKey = orderKey;\r\n            }\r\n            else {\r\n                this.sorted = false;\r\n            }\r\n        }\r\n        const index = this.entities.push(entity) - 1;\r\n        this.lookupTable[id] = index;\r\n    }\r\n    remove(id) {\r\n        const index = this.lookupTable[id];\r\n        if (index < 0)\r\n            throw new InternalError('Entity not in list');\r\n        this.pool.return(id);\r\n        this.lookupTable[id] = -1;\r\n        const entity = this.entities.pop();\r\n        if (index < this.entities.length) {\r\n            this.entities[index] = entity;\r\n            this.lookupTable[entity.__id] = index;\r\n            if (this.orderBy)\r\n                this.sorted = false;\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.lookupTable[id] >= 0;\r\n    }\r\n    clear() {\r\n        for (const entity of this.entities)\r\n            this.pool.return(entity.__id);\r\n        this.entities = [];\r\n        this.lookupTable.fill(-1);\r\n        this.maxOrderKey = -Infinity;\r\n        this.sorted = true;\r\n    }\r\n    sort() {\r\n        if (this.sorted)\r\n            return;\r\n        const orderBy = this.orderBy;\r\n        for (const entity of this.entities)\r\n            entity.__sortKey = orderBy(entity);\r\n        this.entities.sort((a, b) => {\r\n            return a.__sortKey < b.__sortKey ? -1 : a.__sortKey > b.__sortKey ? +1 : 0;\r\n        });\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            this.lookupTable[this.entities[i].__id] = i;\r\n        }\r\n        this.sorted = true;\r\n    }\r\n}\n\nvar QueryFlavor;\r\n(function (QueryFlavor) {\r\n    QueryFlavor[QueryFlavor[\"current\"] = 1] = \"current\";\r\n    QueryFlavor[QueryFlavor[\"added\"] = 2] = \"added\";\r\n    QueryFlavor[QueryFlavor[\"removed\"] = 4] = \"removed\";\r\n    QueryFlavor[QueryFlavor[\"changed\"] = 8] = \"changed\";\r\n    QueryFlavor[QueryFlavor[\"addedOrChanged\"] = 16] = \"addedOrChanged\";\r\n    QueryFlavor[QueryFlavor[\"changedOrRemoved\"] = 32] = \"changedOrRemoved\";\r\n    QueryFlavor[QueryFlavor[\"addedChangedOrRemoved\"] = 64] = \"addedChangedOrRemoved\";\r\n})(QueryFlavor || (QueryFlavor = {}));\r\nconst transientFlavorsMask = QueryFlavor.added | QueryFlavor.removed | QueryFlavor.changed | QueryFlavor.addedOrChanged |\r\n    QueryFlavor.changedOrRemoved | QueryFlavor.addedChangedOrRemoved;\r\nconst changedFlavorsMask = QueryFlavor.changed | QueryFlavor.addedOrChanged | QueryFlavor.changedOrRemoved |\r\n    QueryFlavor.addedChangedOrRemoved;\r\nconst shapeFlavorsMask = QueryFlavor.added | QueryFlavor.removed | QueryFlavor.addedOrChanged |\r\n    QueryFlavor.changedOrRemoved | QueryFlavor.addedChangedOrRemoved;\r\nclass QueryBox {\r\n    system;\r\n    results = {};\r\n    flavors = 0;\r\n    withMask;\r\n    withValues;\r\n    withAnyRecords;\r\n    withoutMask;\r\n    withoutEnumTypes;\r\n    trackWritesMask;\r\n    orderBy;\r\n    hasTransientResults;\r\n    hasChangedResults;\r\n    hasShapeResults;\r\n    hasMatchTracking;\r\n    currentEntities;\r\n    processedEntities;\r\n    changedEntities;\r\n    constructor(query, system) {\r\n        this.system = system;\r\n        query.__results = this.results;\r\n        query.__systemName = system.name;\r\n    }\r\n    complete() {\r\n        const dispatcher = this.system.dispatcher;\r\n        this.hasTransientResults = Boolean(this.flavors & transientFlavorsMask);\r\n        this.hasChangedResults = Boolean(this.flavors & changedFlavorsMask);\r\n        this.hasShapeResults = Boolean(this.flavors & shapeFlavorsMask);\r\n        this.hasMatchTracking = Boolean(this.withAnyRecords?.some(record => record.lastMatches));\r\n        {\r\n            if (this.withMask && this.withoutMask) {\r\n                const minLength = Math.min(this.withMask.length, this.withoutMask.length);\r\n                for (let i = 0; i < minLength; i++) {\r\n                    if ((this.withMask[i] & this.withoutMask[i]) !== 0) {\r\n                        throw new CheckError('Query must not list a component type in both `with` and `without` clauses');\r\n                    }\r\n                }\r\n            }\r\n            if (this.withAnyRecords && this.withoutMask) {\r\n                for (const { mask } of this.withAnyRecords) {\r\n                    const minLength = Math.min(mask.length, this.withoutMask.length);\r\n                    for (let i = 0; i < minLength; i++) {\r\n                        if ((mask[i] & this.withoutMask[i]) !== 0) {\r\n                            throw new CheckError('Query must not list a component type in both `withAny` and `without` clauses');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const hasTrackers = !!this.trackWritesMask || this.withAnyRecords?.some(item => item.lastMatches);\r\n            if (this.hasChangedResults && !hasTrackers) {\r\n                throw new CheckError(`Query for changed entities must track at least one component`);\r\n            }\r\n            if (!this.hasChangedResults && hasTrackers) {\r\n                throw new CheckError('You can only track components if you have a query for changed entities');\r\n            }\r\n        }\r\n        if (this.flavors & QueryFlavor.current) {\r\n            this.results.current =\r\n                new PackedArrayEntityList(dispatcher.registry.pool, this.orderBy, dispatcher.maxEntities);\r\n        }\r\n        else {\r\n            this.currentEntities = new Bitset(dispatcher.maxEntities);\r\n        }\r\n        this.processedEntities = new Bitset(dispatcher.maxEntities);\r\n        if (this.hasTransientResults)\r\n            this.allocateTransientResultLists();\r\n        if (this.flavors)\r\n            this.system.shapeQueries.push(this);\r\n        if (this.hasChangedResults) {\r\n            this.changedEntities = new Bitset(dispatcher.maxEntities);\r\n            this.system.writeQueries.push(this);\r\n        }\r\n    }\r\n    allocateTransientResultLists() {\r\n        if (this.flavors & QueryFlavor.added)\r\n            this.allocateResult('added');\r\n        if (this.flavors & QueryFlavor.removed)\r\n            this.allocateResult('removed');\r\n        if (this.flavors & QueryFlavor.changed)\r\n            this.allocateResult('changed');\r\n        if (this.flavors & QueryFlavor.addedOrChanged)\r\n            this.allocateResult('addedOrChanged');\r\n        if (this.flavors & QueryFlavor.changedOrRemoved)\r\n            this.allocateResult('changedOrRemoved');\r\n        if (this.flavors & QueryFlavor.addedChangedOrRemoved) {\r\n            this.allocateResult('addedChangedOrRemoved');\r\n        }\r\n    }\r\n    allocateResult(name) {\r\n        const dispatcher = this.system.dispatcher;\r\n        this.results[name] = new ArrayEntityList(dispatcher.registry.pool, this.orderBy);\r\n    }\r\n    clearTransientResults() {\r\n        if (!this.hasTransientResults)\r\n            return;\r\n        this.results.added?.clear();\r\n        this.results.removed?.clear();\r\n        this.results.changed?.clear();\r\n        this.results.addedOrChanged?.clear();\r\n        this.results.changedOrRemoved?.clear();\r\n        this.results.addedChangedOrRemoved?.clear();\r\n        this.changedEntities?.clear();\r\n    }\r\n    clearAllResults() {\r\n        this.clearTransientResults();\r\n        this.results.current?.clear();\r\n    }\r\n    clearProcessedEntities() {\r\n        this.processedEntities.clear();\r\n    }\r\n    handleShapeUpdate(id) {\r\n        if (this.processedEntities.get(id))\r\n            return;\r\n        this.processedEntities.set(id);\r\n        const registry = this.system.dispatcher.registry;\r\n        const oldMatch = this.results.current?.has(id) ?? this.currentEntities.get(id);\r\n        const newMatch = registry.matchShape(id, this.withMask, this.withValues, this.withAnyRecords, this.withoutMask, this.withoutEnumTypes);\r\n        if (newMatch && !oldMatch) {\r\n            this.currentEntities?.set(id);\r\n            this.changedEntities?.set(id);\r\n            this.results.current?.add(id);\r\n            this.results.added?.add(id);\r\n            this.results.addedOrChanged?.add(id);\r\n            this.results.addedChangedOrRemoved?.add(id);\r\n        }\r\n        else if (!newMatch && oldMatch) {\r\n            this.currentEntities?.unset(id);\r\n            this.changedEntities?.set(id);\r\n            this.results.current?.remove(id);\r\n            this.results.removed?.add(id);\r\n            this.results.changedOrRemoved?.add(id);\r\n            this.results.addedChangedOrRemoved?.add(id);\r\n        }\r\n        else if (newMatch && oldMatch && this.hasMatchTracking) {\r\n            for (const record of this.withAnyRecords) {\r\n                if (record.changed) {\r\n                    this.changedEntities.set(id);\r\n                    this.results.changed?.add(id);\r\n                    this.results.addedOrChanged?.add(id);\r\n                    this.results.changedOrRemoved?.add(id);\r\n                    this.results.addedChangedOrRemoved?.add(id);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    handleWrite(id, componentFlagOffset, componentFlagMask) {\r\n        if (!this.changedEntities.get(id) &&\r\n            (this.hasShapeResults ?\r\n                (this.results.current?.has(id) ?? this.currentEntities.get(id)) :\r\n                this.system.dispatcher.registry.matchShape(id, this.withMask, this.withValues, this.withAnyRecords, this.withoutMask, this.withoutEnumTypes)) &&\r\n            (this.trackWritesMask[componentFlagOffset] ?? 0) & componentFlagMask) {\r\n            this.changedEntities.set(id);\r\n            this.results.changed?.add(id);\r\n            this.results.addedOrChanged?.add(id);\r\n            this.results.changedOrRemoved?.add(id);\r\n            this.results.addedChangedOrRemoved?.add(id);\r\n        }\r\n    }\r\n    sort() {\r\n        this.results.current?.sort();\r\n        this.results.added?.sort();\r\n        this.results.removed?.sort();\r\n        this.results.changed?.sort();\r\n        this.results.addedOrChanged?.sort();\r\n        this.results.changedOrRemoved?.sort();\r\n        this.results.addedChangedOrRemoved?.sort();\r\n    }\r\n}\r\n/**\r\n * A fluent DSL for specifying a family of queries over the world's entities.\r\n *\r\n * Each query has a number of aspects:\r\n * 1. What components an entity must (`with`) and must not (`without`) have to be selected.\r\n * 2. Whether to return all `current` entities that satisfy the query, only various deltas from the\r\n *    last frame (`added`, `removed`, `changed`, etc.).  It's permitted and encouraged to declare\r\n *    multiple such variants on a single query if needed.  For the delta queries, each entity will\r\n *    be compared against the query's value in the previous frame, so an entity that changes state\r\n *    and changes back again between system executions will not be selected.\r\n * 3. Which component types the query will read and write.  This doesn't affect the results of the\r\n *    query but is used to order and deconflict systems.\r\n */\r\nclass QueryBuilder {\r\n    __callback;\r\n    __userQuery;\r\n    __query;\r\n    __system;\r\n    __lastTypes;\r\n    __lastWasWithAny;\r\n    constructor(__callback, __userQuery) {\r\n        this.__callback = __callback;\r\n        this.__userQuery = __userQuery;\r\n    }\r\n    __build(system) {\r\n        try {\r\n            this.__system = system;\r\n            this.__query = new QueryBox(this.__userQuery, system);\r\n            this.__callback(this);\r\n            if (!this.__query.withMask && this.__query.flavors) {\r\n                this.set('withMask', [this.__system.dispatcher.registry.Alive]);\r\n            }\r\n            this.__query.complete();\r\n        }\r\n        catch (e) {\r\n            e.message = `Failed to build query in system ${system.name}: ${e.message}`;\r\n            throw e;\r\n        }\r\n    }\r\n    // TODO: support partitioned queries in stateless systems\r\n    /**\r\n     * A noop connector to make a query definition read better.\r\n     */\r\n    get and() {\r\n        return this;\r\n    }\r\n    /**\r\n     * A noop connector to make a query definition read better.\r\n     */\r\n    get but() {\r\n        return this;\r\n    }\r\n    /**\r\n     * A noop connector to make a query definition read better.\r\n     */\r\n    get also() {\r\n        return this;\r\n    }\r\n    /**\r\n     * Requests the maintenance of a list of all entities that currently satisfy the query.  This is\r\n     * the most common use of queries.\r\n     */\r\n    get current() {\r\n        this.__query.flavors |= QueryFlavor.current;\r\n        return this;\r\n    }\r\n    /**\r\n     * Requests that a list of all entities that newly satisfy the query be made available each frame.\r\n     */\r\n    get added() {\r\n        this.__query.flavors |= QueryFlavor.added;\r\n        return this;\r\n    }\r\n    /**\r\n     * Requests that a list of all entities that no longer satisfy the query be made available each\r\n     * frame.\r\n     */\r\n    get removed() {\r\n        this.__query.flavors |= QueryFlavor.removed;\r\n        return this;\r\n    }\r\n    /**\r\n     * Requests that a list of all entities that were recently written to and satisfy the query be\r\n     * made available each frame.  You must additionally specify which components the write detection\r\n     * should be sensitive to using `trackWrites`.\r\n     */\r\n    get changed() {\r\n        this.__query.flavors |= QueryFlavor.changed;\r\n        return this;\r\n    }\r\n    /**\r\n     * A combination of the `added` and `changed` query types, with the advantage that an entity that\r\n     * satisfies both will only appear once.\r\n     */\r\n    get addedOrChanged() {\r\n        this.__query.flavors |= QueryFlavor.addedOrChanged;\r\n        return this;\r\n    }\r\n    /**\r\n     * A combination of the `changed` and `removed` query types, with the advantage that an entity\r\n     * that satisfies both will only appear once.\r\n     */\r\n    get changedOrRemoved() {\r\n        this.__query.flavors |= QueryFlavor.changedOrRemoved;\r\n        return this;\r\n    }\r\n    /**\r\n     * A combination of the `added`, `changed`, and `removed` query types, with the advantage that an\r\n     * entity that satisfies multiple ones will only appear once.\r\n     */\r\n    get addedChangedOrRemoved() {\r\n        this.__query.flavors |= QueryFlavor.addedChangedOrRemoved;\r\n        return this;\r\n    }\r\n    /**\r\n     * Order query results in ascending order of the given function's output for each entity.\r\n     * @example\r\n     *   q.added.orderBy(entity => entity.ordinal)\r\n     * @param transformer A function that transforms an entity to a number for sorting.\r\n     */\r\n    orderBy(transformer) {\r\n        this.__query.orderBy = transformer;\r\n        return this;\r\n    }\r\n    /**\r\n     * Constrains the query to entities that possess components of all the given types.  All given\r\n     * types are also marked as `read`.\r\n     *\r\n     * All `with` clauses are combined into a single `O(1)` check.\r\n     *\r\n     * You cannot pass in enums since by definition it's impossible for an entity to possess more than\r\n     * one component from an enum.  See {@link QueryBuilder.withAny} instead.\r\n     * @param types The types of components required to match the query.\r\n     */\r\n    with(...types) {\r\n        this.set(this.__system.accessMasks.read, types);\r\n        this.set('withMask');\r\n        return this;\r\n    }\r\n    /**\r\n     * Constrains the query to entities that possess a component of at least one of the given types.\r\n     * All given types are also marked as `read`.\r\n     *\r\n     * Unlike `with`, `withAny` clauses are not combined; each is evaluated as a separate check, which\r\n     * may affect performance.\r\n     *\r\n     * You cannot pass in enum component types, only whole enums.\r\n     * @param types\r\n     */\r\n    withAny(...types) {\r\n        for (const type of types) {\r\n            if (typeof type === 'function' && type.enum) {\r\n                throw new CheckError(`Cannot use enum types in a withAny clause: ${type.name}`);\r\n            }\r\n        }\r\n        this.set(this.__system.accessMasks.read, types);\r\n        if (!this.__query.withAnyRecords)\r\n            this.__query.withAnyRecords = [];\r\n        const mask = [];\r\n        this.__query.withAnyRecords.push({ mask, lastMatches: undefined, changed: false });\r\n        this.set(mask);\r\n        return this;\r\n    }\r\n    /**\r\n     * Constrains the query to entities that don't possess components of any of the given types.  All\r\n     * given types are also marked as `read`.\r\n     *\r\n     * While you can pass in enum component types, evaluating such queries is inefficient (`O(n)` in\r\n     * the number of enum types passed).  Passing in whole enums is fine, though (the query stays\r\n     * `O(1)`).\r\n     * @param types The types of components that must not be present to match the query.\r\n     */\r\n    without(...types) {\r\n        this.set(this.__system.accessMasks.read, types);\r\n        this.set('withoutMask');\r\n        return this;\r\n    }\r\n    /**\r\n     * Mentions some component types for follow-up modifiers.\r\n     * @param types The types of components for follow-up modifiers, but that don't constrain the\r\n     * query.\r\n     */\r\n    using(...types) {\r\n        this.__lastTypes = types;\r\n        return this;\r\n    }\r\n    /**\r\n     * Makes all component types in the world available for follow-up modifiers.  This can be modified\r\n     * with a `.write` as usual, and may be useful in \"sweeper\" systems that want to be able to, e.g.,\r\n     * delete any entity without having to worry what it might hold refs to or what components might\r\n     * have backrefs pointing to it.\r\n     */\r\n    get usingAll() {\r\n        // All types except Alive, which is always at index 0.\r\n        this.__lastTypes = this.__system.dispatcher.registry.types.slice(1);\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks writes to the most recently mentioned component types as trackable for `changed` query\r\n     * flavors.  An entity will be considered changed if any system called `write` on one of those\r\n     * components since the last frame.\r\n     */\r\n    get trackWrites() {\r\n        this.set('trackWritesMask');\r\n        for (const type of this.__lastTypes) {\r\n            if (typeof type === 'function') {\r\n                type.__binding.trackedWrites = true;\r\n            }\r\n            else {\r\n                for (const enumType of type.__types)\r\n                    enumType.__binding.trackedWrites = true;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks changes in the matching set of the immediately preceding `withAny` component types as\r\n     * trackable for `changed` query flavors.  An entity will be considered changed if it matched the\r\n     * query in the last frame and still matches it in the current frame, but satisfied the `withAny`\r\n     * constraint with a different set of components.\r\n     *\r\n     * This tracking is particularly useful for detecting changing enum states, but can be applied to\r\n     * any set of components.\r\n     */\r\n    get trackMatches() {\r\n        if (!this.__lastWasWithAny) {\r\n            throw new Error('You can only apply trackMatches to a withAny clause');\r\n        }\r\n        this.__query.withAnyRecords[this.__query.withAnyRecords.length - 1].lastMatches = [];\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks the most recently mentioned component types as read by the system.  This declaration\r\n     * is enforced: you will only be able to read components of types thus declared.\r\n     */\r\n    get read() {\r\n        this.set(this.__system.accessMasks.read);\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks the most recently mentioned component types as created (and only created!) by the system.\r\n     * This means that the component types will only be used in `createEntity` calls; they cannot be\r\n     * otherwise read, checked for (`has` methods), or written.  It can run concurrently with other\r\n     * `create` entitlements but counts as a `write` for purposes of system ordering.\r\n     */\r\n    get create() {\r\n        this.set(this.__system.accessMasks.create);\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks the most recently mentioned component types as indirectly updated by the system.  This\r\n     * covers automatic change propagation to non-writable fields such as updates of `backrefs`\r\n     * properties; however, it doesn't cover automatic clearing of refs to a deleted entity.  It can\r\n     * run concurrently with other `read` and `update` entitlements but counts as a `write` for\r\n     * purposes of system ordering.\r\n     */\r\n    get update() {\r\n        this.set(this.__system.accessMasks.update);\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks the most recently mentioned component types as read, written, created and/or updated by\r\n     * the system.  This declaration is enforced: you will only be able to read and write to component\r\n     * of types thus declared. You should try to declare the minimum writable set that your system\r\n     * will need to improve ordering and concurrency.\r\n     */\r\n    get write() {\r\n        this.set(this.__system.accessMasks.write);\r\n        this.set(this.__system.accessMasks.read);\r\n        this.set(this.__system.accessMasks.create);\r\n        this.set(this.__system.accessMasks.update);\r\n        return this;\r\n    }\r\n    set(mask, types) {\r\n        if (!mask)\r\n            return;\r\n        if (types) {\r\n            for (const type of types)\r\n                checkTypeDefined(type);\r\n        }\r\n        if (!types)\r\n            types = this.__lastTypes;\r\n        if (!types)\r\n            throw new InternalError('No component type to apply query modifier to');\r\n        this.__lastTypes = types;\r\n        if (typeof mask === 'string') {\r\n            if (!this.__query[mask])\r\n                this.__query[mask] = [];\r\n            mask = this.__query[mask];\r\n        }\r\n        this.__lastWasWithAny = this.__query.withAnyRecords?.some(item => item.mask === mask) ?? false;\r\n        const readMask = mask === this.__system.accessMasks.read;\r\n        const updateMask = mask === this.__system.accessMasks.update;\r\n        const createMask = mask === this.__system.accessMasks.create;\r\n        const writeMask = mask === this.__system.accessMasks.write;\r\n        const withMask = mask === this.__query.withMask;\r\n        const withoutMask = mask === this.__query.withoutMask;\r\n        const shapeMask = mask === this.__query.withMask || mask === this.__query.withoutMask || this.__lastWasWithAny;\r\n        const trackMask = mask === this.__query.trackWritesMask;\r\n        const map = readMask ? this.__system.dispatcher.planner.readers :\r\n            writeMask || createMask || updateMask ? this.__system.dispatcher.planner.writers :\r\n                undefined;\r\n        for (const type of types) {\r\n            {\r\n                if (!isMaskFlagSet(this.__system.accessMasks.write, type) && (readMask && isMaskFlagSet(this.__system.accessMasks.create, type) ||\r\n                    createMask && isMaskFlagSet(this.__system.accessMasks.read, type))) {\r\n                    throw new CheckError(`Cannot combine create and read entitlements for component type ${type.name}; ` +\r\n                        `just use a write entitlement instead`);\r\n                }\r\n            }\r\n            if (withoutMask && typeof type === 'function' && type.enum) {\r\n                this.__query.withoutEnumTypes = this.__query.withoutEnumTypes ?? [];\r\n                this.__query.withoutEnumTypes.push(type);\r\n            }\r\n            else {\r\n                extendMaskAndSetFlag(mask, type);\r\n                if (withMask) {\r\n                    if (!this.__query.withValues)\r\n                        this.__query.withValues = [];\r\n                    extendMaskAndSetFlag(this.__query.withValues, type, true);\r\n                }\r\n            }\r\n            if (readMask)\r\n                extendMaskAndSetFlag(this.__system.accessMasks.check, type);\r\n            if (typeof type === 'function') {\r\n                if (map)\r\n                    map.get(type).add(this.__system);\r\n                if (shapeMask)\r\n                    this.categorize(this.__system.shapeQueriesByComponent, type);\r\n                if (trackMask)\r\n                    this.categorize(this.__system.writeQueriesByComponent, type);\r\n            }\r\n            else {\r\n                for (const enumType of type.__types) {\r\n                    if (map)\r\n                        map.get(enumType).add(this.__system);\r\n                    if (shapeMask)\r\n                        this.categorize(this.__system.shapeQueriesByComponent, enumType);\r\n                    if (trackMask)\r\n                        this.categorize(this.__system.writeQueriesByComponent, enumType);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    categorize(index, type) {\r\n        const id = type.id;\r\n        if (!index[id])\r\n            index[id] = [];\r\n        if (!index[id].includes(this.__query))\r\n            index[id].push(this.__query);\r\n    }\r\n}\r\nclass Query {\r\n    __results;\r\n    __systemName;\r\n    // TODO: add an API for freezing/thawing a query\r\n    /**\r\n     * A list of all entities that match this query as of the beginning of the system's current (or\r\n     * last) execution.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get current() {\r\n        this.__checkList('current');\r\n        return this.__results.current.entities;\r\n    }\r\n    /**\r\n     * A list of all entities that newly started matching this query between the system's current (or\r\n     * last) and previous executions.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get added() {\r\n        this.__checkList('added');\r\n        return this.__results.added.entities;\r\n    }\r\n    /**\r\n     * A list of all entities that newly stopped matching this query between the system's current (or\r\n     * last) and previous executions.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get removed() {\r\n        this.__checkList('removed');\r\n        return this.__results.removed.entities;\r\n    }\r\n    /**\r\n     * A list of all entities that match this query as of the beginning of of the system's current (or\r\n     * last) execution, and that had tracked components written to between the system's current (or\r\n     * last) and previous executions.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get changed() {\r\n        this.__checkList('changed');\r\n        return this.__results.changed.entities;\r\n    }\r\n    /**\r\n     * A list that combines `added` and `changed`, but without duplicate entities.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get addedOrChanged() {\r\n        this.__checkList('addedOrChanged');\r\n        return this.__results.addedOrChanged.entities;\r\n    }\r\n    /**\r\n     * A list that combines `changed` and `removed`, but without duplicate entities.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get changedOrRemoved() {\r\n        this.__checkList('changedOrRemoved');\r\n        return this.__results.changedOrRemoved.entities;\r\n    }\r\n    /**\r\n     * A list that combines `added`, `changed`, and `removed`, but without duplicate entities.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get addedChangedOrRemoved() {\r\n        this.__checkList('addedChangedOrRemoved');\r\n        return this.__results.addedChangedOrRemoved.entities;\r\n    }\r\n    __checkList(flavor) {\r\n        const list = this.__results[flavor];\r\n        if (!list) {\r\n            throw new CheckError(`Query '${flavor}' not configured, please add .${flavor} to your query definition in ` +\r\n                `system ${this.__systemName}`);\r\n        }\r\n    }\r\n}\n\nconst now = typeof window !== 'undefined' && typeof window.performance !== 'undefined' ?\r\n    performance.now.bind(performance) : Date.now.bind(Date);\r\n// TODO: support replicated systems\r\n// TODO: support continuously executed systems\r\n/**\r\n * A fluent DSL for specifying a system's scheduling constraints.\r\n *\r\n * Any given pair of systems will be ordered by the first of the following rules that matches:\r\n * 1. A system was explicitly placed `before` or `after` another.\r\n * 2. A system was explicitly left unordered with respect to another using `inAnyOrderWith`.\r\n * 3. A system was implicitly placed before or after another system based on the components the\r\n *    other system reads or writes, using `beforeReadersOf`, `afterReadersOf`, `beforeWritersOf` or\r\n *    `afterWritersOf`.\r\n * 4. A system was explicitly left unordered with respect to another using `inAnyOrderWithReadersOf`\r\n *    or `inAnyOrderWithWritersOf`.\r\n * 5. A system was implicitly placed after another because it reads a component that the other\r\n *    system writes.\r\n *\r\n * If there are multiple constraints at the same priority level they will conflict and create a\r\n * cycle.  If there are any cycles in the order graph (whether due to explicit conflicts or implicit\r\n * circular dependencies), world creation will fail with an informative error and you'll need to\r\n * break the cycles by adding scheduling constraints to the systems involved.\r\n */\r\nclass ScheduleBuilder {\r\n    __callback;\r\n    __schedule;\r\n    __systems;\r\n    __dispatcher;\r\n    constructor(__callback, __schedule) {\r\n        this.__callback = __callback;\r\n        this.__schedule = __schedule;\r\n    }\r\n    __build(systems, name) {\r\n        try {\r\n            this.__systems = systems;\r\n            this.__dispatcher = systems[0].dispatcher;\r\n            this.__callback(this);\r\n        }\r\n        catch (e) {\r\n            e.message = `Failed to build schedule in ${name}: ${e.message}`;\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a group that includes all the world's systems.\r\n     */\r\n    get allSystems() {\r\n        return this.__dispatcher.defaultGroup;\r\n    }\r\n    /**\r\n     * Forces this system to only execute on the main thread.  This is needed for systems that\r\n     * interact with APIs only available in the main thread such as the DOM.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    get onMainThread() {\r\n        this.__checkNoLaneAssigned();\r\n        this.__dispatcher.planner.mainLane?.add(...this.__systems);\r\n        return this;\r\n    }\r\n    /**\r\n     * Executes this system consistently on a single thread.  This is the default behavior to\r\n     * accommodate systems with internal state.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    get onOneThread() {\r\n        this.__checkNoLaneAssigned();\r\n        this.__dispatcher.planner.createLane().add(...this.__systems);\r\n        return this;\r\n    }\r\n    /**\r\n     * Replicates this system among multiple threads and execute it on any one of them, possibly a\r\n     * different one each time.  This allows Becsy to better utilize available CPUs but requires the\r\n     * system to be stateless (except for queries and attached systems).  Note that `prepare` and\r\n     * `initialize` will be called on each replicated instance of the system!\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    get onManyThreads() {\r\n        this.__checkNoLaneAssigned();\r\n        this.__dispatcher.planner.replicatedLane?.add(...this.__systems);\r\n        for (const system of this.__systems)\r\n            system.stateless = true;\r\n        return this;\r\n    }\r\n    __checkNoLaneAssigned() {\r\n        if (this.__systems.some(system => system.lane)) {\r\n            throw new CheckError(`Threading semantics already specified`);\r\n        }\r\n    }\r\n    /**\r\n     * Schedules this system before all the given ones (highest priority).  Any systems present in\r\n     * both the receiver and the target are skipped.\r\n     * @param systemTypes The systems or groups that this one should precede.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    before(...systemTypes) {\r\n        const thisSet = new Set(this.__systems);\r\n        for (const type of systemTypes) {\r\n            for (const other of this.__dispatcher.getSystems(type)) {\r\n                if (thisSet.has(other))\r\n                    continue;\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(system, other, 5);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system after all the given ones (highest priority).  Any systems present in\r\n     * both the receiver and the target are skipped.\r\n     * @param systemTypes The systems or groups that this one should follow.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    after(...systemTypes) {\r\n        const thisSet = new Set(this.__systems);\r\n        for (const type of systemTypes) {\r\n            for (const other of this.__dispatcher.getSystems(type)) {\r\n                if (thisSet.has(other))\r\n                    continue;\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(other, system, 5);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system in any order relative to the given ones (high priority).\r\n     * @param systemTypes The systems or groups whose order doesn't matter relative to this one.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    inAnyOrderWith(...systemTypes) {\r\n        for (const type of systemTypes) {\r\n            for (const other of this.__dispatcher.getSystems(type)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.denyEdge(system, other, 4);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system before all other systems that declared a read dependency on the given\r\n     * component types (medium priority).\r\n     * @param componentTypes The component types whose readers this system should precede.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    beforeReadersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.readers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(system, other, 3);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system after all other systems that declared a read dependency on the given\r\n     * component types (medium priority).\r\n     * @param componentTypes The component types whose readers this system should follow.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    afterReadersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.readers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(other, system, 3);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system before all other systems that declared a write dependency on the given\r\n     * component types (medium priority).\r\n     * @param componentTypes The component types whose writers this system should precede.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    beforeWritersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.writers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(system, other, 3);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system after all other systems that declared a write dependency on the given\r\n     * component types (medium priority).\r\n     * @param componentTypes The component types whose writers this system should follow.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    afterWritersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.writers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(other, system, 3);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system in any order relative to systems that declared a read dependency on the\r\n     * given component types (low priority).\r\n     * @param componentTypes The component types whose readers' order doesn't matter relative to this\r\n     *  one.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    inAnyOrderWithReadersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.readers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.denyEdge(other, system, 2);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system in any order relative to systems that declared a write dependency on the\r\n     * given component types (low priority).\r\n     * @param componentTypes The component types whose writers' order doesn't matter relative to this\r\n     *  one.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    inAnyOrderWithWritersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.writers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.denyEdge(other, system, 2);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n}\r\n/**\r\n * A placeholder object returned from {@link System.schedule} with no public API.\r\n */\r\nclass Schedule {\r\n}\r\nclass SystemGroupImpl {\r\n    __contents;\r\n    __plan;\r\n    __executed = false;\r\n    __systems;\r\n    __scheduleBuilder;\r\n    constructor(__contents) {\r\n        this.__contents = __contents;\r\n    }\r\n    __collectSystems(dispatcher) {\r\n        if (!this.__systems) {\r\n            this.__systems = [];\r\n            for (const item of this.__contents) {\r\n                if (item instanceof Function && item.__system) {\r\n                    this.__systems.push(dispatcher.systemsByClass.get(item));\r\n                }\r\n                else if (item instanceof SystemGroupImpl) {\r\n                    this.__systems.push(...item.__collectSystems(dispatcher));\r\n                }\r\n            }\r\n        }\r\n        return this.__systems;\r\n    }\r\n    __buildSchedule() {\r\n        this.__scheduleBuilder?.__build(this.__systems, `a group`);\r\n        this.__scheduleBuilder = null;\r\n    }\r\n    /**\r\n     * Creates scheduling constraints for all systems in the group; this works exactly as if the\r\n     * call was made individually to every {@link System.schedule}.  Can be called at most once.\r\n     * @param buildCallback A function that constrains the schedule using a small DSL.  See\r\n     * {@link ScheduleBuilder} for the API.\r\n     * @returns This group for chaining calls.\r\n     */\r\n    schedule(buildCallback) {\r\n        if (this.__scheduleBuilder === null) {\r\n            throw new CheckError(`Attempt to define group schedule after world initialized`);\r\n        }\r\n        if (this.__scheduleBuilder) {\r\n            throw new CheckError(`Attempt to define multiple schedules in a group`);\r\n        }\r\n        this.__scheduleBuilder = new ScheduleBuilder(buildCallback, new Schedule());\r\n        return this;\r\n    }\r\n}\r\nclass FrameImpl {\r\n    dispatcher;\r\n    groups;\r\n    executing;\r\n    time = now() / 1000;\r\n    delta;\r\n    constructor(dispatcher, groups) {\r\n        this.dispatcher = dispatcher;\r\n        this.groups = groups;\r\n        if (groups.length === 0) {\r\n            throw new CheckError('At least one system group needed');\r\n        }\r\n        for (const group of groups) {\r\n            if (!dispatcher.systemGroups.includes(group)) {\r\n                throw new CheckError('Some groups in the frame are not parts of the world defs');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Indicates that execution of a frame has begun and locks in the default `time` and `delta`.\r\n     * Must be called once at the beginning of each frame, prior to any calls to `execute`.  Must be\r\n     * bookended by a call to `end`.\r\n     *\r\n     * You cannot call `begin` while any other executors are running.\r\n     */\r\n    async begin() {\r\n        if (this.executing)\r\n            throw new CheckError('Frame already executing');\r\n        this.executing = true;\r\n        const lastTime = this.dispatcher.lastTime ?? this.time;\r\n        this.time = now() / 1000;\r\n        this.delta = this.time - lastTime;\r\n        this.dispatcher.startFrame(this.time);\r\n    }\r\n    /**\r\n     * Indicates that execution of a frame has completed.  Must be called once at the end of each\r\n     * frame, after any calls to `execute`.\r\n     */\r\n    async end() {\r\n        if (!this.executing)\r\n            throw new CheckError('Frame not executing');\r\n        this.executing = false;\r\n        allExecuted: {\r\n            for (const group of this.groups)\r\n                if (!group.__executed)\r\n                    break allExecuted;\r\n            for (const group of this.groups)\r\n                group.__executed = false;\r\n            this.dispatcher.completeCycle();\r\n        }\r\n        await this.dispatcher.completeFrame();\r\n    }\r\n    /**\r\n     * Executes a group of systems.  If your world is single-threaded then execution is synchronous\r\n     * and you can ignore the returned promise.\r\n     *\r\n     * You cannot execute individual systems, unless you create a singleton group to hold them.\r\n     *\r\n     * @param group The group of systems to execute.  Must be a member of the group list passed in\r\n     * when this executor was created.\r\n     *\r\n     * @param time The time of this frame's execution.  This will be set on every system's `time`\r\n     * property and defaults to the time when `begin` was called.  It's not used internally so you can\r\n     * pass in any numeric value that's expected by your systems.\r\n     *\r\n     * @param delta The duration since the last frame's execution.  This will be set on every system's\r\n     * `delta` property and default to the duration since any previous frame's `begin` was called.\r\n     * It's not used internally so you can pass in any numeric value that's expected by your systems.\r\n     */\r\n    execute(group, time, delta) {\r\n        if (!this.groups.includes(group)) {\r\n            throw new CheckError('Group not included in this frame');\r\n        }\r\n        if (!this.executing)\r\n            throw new CheckError('Frame not executing');\r\n        return group.__plan.execute(time ?? this.time, delta ?? this.delta);\r\n    }\r\n}\n\n/**\r\n * An exception thrown by coroutines when they've been canceled. You should normally rethrow it\r\n * from any catch blocks, and it will be caught and ignored at the top coroutine nesting level.\r\n */\r\nclass CanceledError extends Error {\r\n    canceled = true;\r\n    constructor() {\r\n        super('Canceled');\r\n    }\r\n}\r\nlet currentCoroutine;\r\nclass CoroutineImpl {\r\n    __generator;\r\n    __fn;\r\n    __supervisor;\r\n    __cancellers = [];\r\n    __blocker;\r\n    __scope;\r\n    __done = false;\r\n    __awaited = false;\r\n    __error;\r\n    __value;\r\n    __firstRun = true;\r\n    constructor(__generator, __fn, __supervisor) {\r\n        this.__generator = __generator;\r\n        this.__fn = __fn;\r\n        this.__supervisor = __supervisor;\r\n    }\r\n    __checkCancelation() {\r\n        if (this.__done)\r\n            return;\r\n        for (const canceller of this.__cancellers) {\r\n            if (canceller()) {\r\n                this.cancel();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    __step() {\r\n        currentCoroutine = this; // eslint-disable-line @typescript-eslint/no-this-alias\r\n        try {\r\n            if (!this.__done && (this.__blocker?.isReady() ?? true)) {\r\n                try {\r\n                    let next;\r\n                    if (this.__blocker?.error) {\r\n                        next = this.__generator.throw(this.__blocker.error);\r\n                    }\r\n                    else if (this.__firstRun) {\r\n                        try {\r\n                            next = this.__generator.next(this.__blocker?.value);\r\n                        }\r\n                        finally {\r\n                            this.__firstRun = false;\r\n                            this.__supervisor.cancelMatching(this, this.__scope, this.__fn);\r\n                        }\r\n                    }\r\n                    else {\r\n                        next = this.__generator.next(this.__blocker?.value);\r\n                    }\r\n                    if (next.done) {\r\n                        this.__done = true;\r\n                        this.__value = next.value;\r\n                        this.__blocker = undefined;\r\n                    }\r\n                    else {\r\n                        this.__blocker = next.value;\r\n                        this.__blocker?.markAwaited?.();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    this.__done = true;\r\n                    if (!this.__error)\r\n                        this.__error = e;\r\n                    this.__blocker = undefined;\r\n                }\r\n            }\r\n            if (this.__error && !(this.__awaited || this.__error instanceof CanceledError)) {\r\n                throw this.__error;\r\n            }\r\n        }\r\n        finally {\r\n            currentCoroutine = undefined;\r\n        }\r\n    }\r\n    // Waitable methods\r\n    isReady() {\r\n        return this.__done;\r\n    }\r\n    get value() {\r\n        return this.__value;\r\n    }\r\n    get error() {\r\n        return this.__error;\r\n    }\r\n    markAwaited() {\r\n        this.__awaited = true;\r\n    }\r\n    // CurrentCoroutine methods\r\n    waitForFrames(frames) {\r\n        if (frames <= 0)\r\n            throw new CheckError('Number of frames to wait for must be >0');\r\n        return {\r\n            isReady() { return --frames <= 0; }\r\n        };\r\n    }\r\n    waitForSeconds(seconds) {\r\n        const system = this.__supervisor.system;\r\n        const targetTime = system.time + seconds;\r\n        return {\r\n            isReady() { return system.time >= targetTime; }\r\n        };\r\n    }\r\n    waitUntil(condition) {\r\n        return { isReady: condition };\r\n    }\r\n    // Coroutine methods\r\n    cancel() {\r\n        if (this.__blocker?.cancel) {\r\n            this.__blocker.cancel();\r\n        }\r\n        else {\r\n            this.__error = new CanceledError();\r\n            this.__done = true;\r\n        }\r\n        return this;\r\n    }\r\n    cancelIf(condition) {\r\n        this.__cancellers.push(condition);\r\n        return this;\r\n    }\r\n    scope(entity) {\r\n        if (this.__scope)\r\n            throw new CheckError('Scope already set for this coroutine');\r\n        if (this.__cancellers.length) {\r\n            throw new CheckError('Scope must be set before any cancelation conditions');\r\n        }\r\n        this.__scope = entity;\r\n        this.cancelIf(() => !entity.alive);\r\n        return this;\r\n    }\r\n    cancelIfComponentMissing(type) {\r\n        if (!this.__scope)\r\n            throw new CheckError('Required scope not set for this coroutine');\r\n        this.cancelIf(() => !this.__scope?.has(type));\r\n        return this;\r\n    }\r\n    cancelIfCoroutineStarted(coroutineFn) {\r\n        this.__supervisor.registerCancelIfStarted(this, this.__scope, coroutineFn === coDecorator.self ? this.__fn : coroutineFn);\r\n        return this;\r\n    }\r\n    // We need to stub out all the Generator methods because we're overloading the type.  They must\r\n    // not be called by the user, however.\r\n    return(value) {\r\n        throw new CheckError('Generator methods not available for coroutines');\r\n    }\r\n    throw(e) {\r\n        throw new CheckError('Generator methods not available for coroutines');\r\n    }\r\n    next(...args) {\r\n        throw new CheckError('Generator methods not available for coroutines');\r\n    }\r\n    [Symbol.iterator]() {\r\n        throw new CheckError('Generator methods not available for coroutines');\r\n    }\r\n}\r\nfunction coDecorator(target, name, descriptor) {\r\n    const coroutine = descriptor.value;\r\n    return {\r\n        value(...args) {\r\n            return this.start(coroutine, ...args);\r\n        },\r\n    };\r\n}\r\ncoDecorator.waitForFrames = function (frames) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.waitForFrames(frames);\r\n};\r\ncoDecorator.waitForSeconds = function (seconds) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.waitForSeconds(seconds);\r\n};\r\ncoDecorator.waitUntil = function (condition) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.waitUntil(condition);\r\n};\r\ncoDecorator.cancel = function () {\r\n    checkCurrentCoroutine();\r\n    currentCoroutine.cancel();\r\n};\r\ncoDecorator.cancelIf = function (condition) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.cancelIf(condition);\r\n};\r\ncoDecorator.scope = function (entity) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.scope(entity);\r\n};\r\ncoDecorator.cancelIfComponentMissing = function (type) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.cancelIfComponentMissing(type);\r\n};\r\ncoDecorator.cancelIfCoroutineStarted = function (coroutineFn) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.cancelIfCoroutineStarted(coroutineFn);\r\n};\r\ncoDecorator.self = function* () { yield; };\r\nfunction checkCurrentCoroutine() {\r\n    if (!currentCoroutine)\r\n        throw new CheckError('Cannot call co methods outside coroutine context');\r\n}\r\n/**\r\n * This object can be used in two ways:\r\n * 1. As a decorator, to wrap coroutine methods in a call to {@link System.start} so you can invoke\r\n * them directly.\r\n * 2. As a handle to the currently executing coroutine, so you can invoke coroutine control methods\r\n * from within the coroutine's code.\r\n */\r\nconst co = coDecorator;\r\nclass Supervisor {\r\n    system;\r\n    coroutines = [];\r\n    mutuallyExclusiveCoroutines = new Map();\r\n    constructor(system) {\r\n        this.system = system;\r\n    }\r\n    start(coroutineFn, ...args) {\r\n        const coroutine = new CoroutineImpl(coroutineFn.apply(this.system, args), coroutineFn, this);\r\n        this.coroutines.push(coroutine);\r\n        return coroutine;\r\n    }\r\n    execute() {\r\n        // Execute in reverse order, so that the most recently started coroutines execute first.  That\r\n        // way, if coroutine A started coroutine B and is waiting for it to complete, it will resume in\r\n        // the same frame as B finishes rather than having to wait for another go-around. At the same\r\n        // time, if new coroutines are started while we're processing, keep iterating to execute the\r\n        // extra ones within the same frame.\r\n        let processedLength = 0;\r\n        while (processedLength < this.coroutines.length) {\r\n            const endIndex = processedLength;\r\n            processedLength = this.coroutines.length;\r\n            for (let i = processedLength - 1; i >= endIndex; i--) {\r\n                this.system.accessRecentlyDeletedData(false);\r\n                this.coroutines[i].__checkCancelation();\r\n            }\r\n            for (let i = processedLength - 1; i >= endIndex; i--) {\r\n                this.system.accessRecentlyDeletedData(false);\r\n                const coroutine = this.coroutines[i];\r\n                coroutine.__step();\r\n                if (coroutine.isReady()) {\r\n                    this.coroutines.splice(i, 1);\r\n                    processedLength -= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    registerCancelIfStarted(targetCoroutine, scope, coroutineFn) {\r\n        const key = (scope?.__id ?? '') + (coroutineFn?.name ?? '');\r\n        if (!this.mutuallyExclusiveCoroutines.has(key))\r\n            this.mutuallyExclusiveCoroutines.set(key, []);\r\n        this.mutuallyExclusiveCoroutines.get(key)?.push(targetCoroutine);\r\n    }\r\n    cancelMatching(startingCoroutine, scope, coroutineFn) {\r\n        this.cancelMatchingKey(startingCoroutine, '');\r\n        this.cancelMatchingKey(startingCoroutine, coroutineFn.name);\r\n        if (scope) {\r\n            this.cancelMatchingKey(startingCoroutine, '' + scope.__id);\r\n            this.cancelMatchingKey(startingCoroutine, '' + scope.__id + coroutineFn.name);\r\n        }\r\n    }\r\n    cancelMatchingKey(requestingCoroutine, key) {\r\n        const coroutines = this.mutuallyExclusiveCoroutines.get(key);\r\n        if (coroutines) {\r\n            let hasRequesting = false;\r\n            for (const coroutine of coroutines) {\r\n                if (coroutine === requestingCoroutine) {\r\n                    hasRequesting = true;\r\n                }\r\n                else {\r\n                    coroutine.cancel();\r\n                }\r\n            }\r\n            coroutines.length = 0;\r\n            if (hasRequesting)\r\n                coroutines.push(requestingCoroutine);\r\n        }\r\n    }\r\n}\n\nvar RunState;\r\n(function (RunState) {\r\n    RunState[RunState[\"RUNNING\"] = 0] = \"RUNNING\";\r\n    RunState[RunState[\"STOPPED\"] = 1] = \"STOPPED\";\r\n})(RunState || (RunState = {}));\r\nclass SingletonPlaceholder {\r\n    access;\r\n    type;\r\n    initialValues;\r\n    constructor(access, type, initialValues) {\r\n        this.access = access;\r\n        this.type = type;\r\n        this.initialValues = initialValues;\r\n    }\r\n}\r\nclass AttachPlaceholder {\r\n    type;\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n}\r\n// TODO: support HMR for systems\r\n/**\r\n * An encapsulated piece of functionality for your app that executes every frame, typically by\r\n * iterating over some components returned by a query.\r\n *\r\n * You should subclass and implement {@link System.execute} at a minimum, but take a look at the\r\n * other methods as well.\r\n */\r\nclass System {\r\n    static __system = true;\r\n    /**\r\n     * Create a group of systems that can be scheduled collectively, or used in\r\n     * {@link World.createCustomExecutor} to execute a subset of all the system in a frame. The group\r\n     * needs to be included in the world's defs, which will also automatically include all its member\r\n     * systems.\r\n     * @param systemTypes System classes to include in the group, each optionally followed by an\r\n     *  object to initialize the system's properties.  A system can be a member of more than one\r\n     *  group.\r\n     * @returns A group of the given systems.\r\n     */\r\n    static group(...systemTypes) {\r\n        return new SystemGroupImpl(systemTypes);\r\n    }\r\n    __queryBuilders = [];\r\n    __scheduleBuilder;\r\n    __attachPlaceholders = [];\r\n    __singletonPlaceholders = [];\r\n    __supervisor = new Supervisor(this);\r\n    __dispatcher;\r\n    /**\r\n     * A numeric ID, unique for systems within a world, that you can use for your own purposes.  Don't\r\n     * change it!\r\n     */\r\n    id;\r\n    /**\r\n     * The time that execution of the current frame was started. See {@link World.execute} for\r\n     * details.\r\n     * @typedef {}\r\n     */\r\n    time;\r\n    /**\r\n     * The duration between the execution times of the current and previous frames.  See\r\n     * {@link World.execute} for details.\r\n     */\r\n    delta;\r\n    /**\r\n     * This system's name, as used in error messages and stats reports.\r\n     */\r\n    get name() { return this.constructor.name; }\r\n    // TODO: add an API for making immediate queries\r\n    /**\r\n     * Creates a persistent query for this system.  Can only be called from the constructor, typically\r\n     * by initializing an instance property.\r\n     *\r\n     * Each query is automatically updated each frame immediately before the system executes.\r\n     * @example\r\n     * entities = this.query(q => q.all.with(ComponentFoo).write);\r\n     * execute() {\r\n     *   for (const entity of this.entities) {\r\n     *     entity.write(ComponentFoo).bar += 1;\r\n     *   }\r\n     * }\r\n     * @param buildCallback A function that builds the actual query using a small DSL.  See\r\n     * {@link QueryBuilder} for the API.\r\n     * @returns A live query that you can reference from the `execute` method.  It's also OK to read\r\n     * a query from other attached systems, but note that it will only be updated prior to its host\r\n     * system's execution.\r\n     */\r\n    query(buildCallback) {\r\n        const query = new Query();\r\n        const builder = new QueryBuilder(buildCallback, query);\r\n        if (!this.__queryBuilders) {\r\n            throw new CheckError(`Attempt to create a new query after world initialized in system ${this.name}`);\r\n        }\r\n        this.__queryBuilders.push(builder);\r\n        return query;\r\n    }\r\n    /**\r\n     * Creates scheduling constraints for this system that will help determine its assignment to a\r\n     * thread and the order of execution.  Can be called at most once, and only from the constructor,\r\n     * typically by initializing an instance property.\r\n     * @example\r\n     * sked = this.schedule(s => s.beforeWritesTo(ComponentFoo).after(SystemBar));\r\n     * @param buildCallback A function that constrains the schedule using a small DSL.  See\r\n     * {@link ScheduleBuilder} for the API.\r\n     * @returns A schedule placeholder object with no public API.\r\n     */\r\n    schedule(buildCallback) {\r\n        if (this.__scheduleBuilder === null) {\r\n            throw new CheckError(`Attempt to define schedule after world initialized in system ${this.name}`);\r\n        }\r\n        if (this.__scheduleBuilder) {\r\n            throw new CheckError(`Attempt to define multiple schedules in system ${this.name}`);\r\n        }\r\n        const schedule = new Schedule();\r\n        this.__scheduleBuilder = new ScheduleBuilder(buildCallback, schedule);\r\n        return schedule;\r\n    }\r\n    /**\r\n     * Creates a reference to another system in the world, that you can then use in your `initialize`\r\n     * or `execute` methods.  Be careful not to abuse this feature as it will force all systems that\r\n     * reference each other to be located in the same thread when using multithreading, possibly\r\n     * limiting performance.  Can only be called from the constructor, typically by initializing an\r\n     * instance property.\r\n     * @example\r\n     * foo = this.attach(SystemFoo);\r\n     * @param systemType The type of the system to reference.\r\n     * @returns The unique instance of the system of the given type that exists in the world.\r\n     */\r\n    attach(systemType) {\r\n        if (!this.__attachPlaceholders) {\r\n            throw new CheckError(`Attempt to attach a system after world initialized in system ${this.name}`);\r\n        }\r\n        const placeholder = new AttachPlaceholder(systemType);\r\n        this.__attachPlaceholders.push(placeholder);\r\n        return placeholder;\r\n    }\r\n    /**\r\n     * Creates a new entity.  It works just like {@link World.createEntity} but returns the newly\r\n     * created entity.  You *must not* retain a direct reference to the entity past the end of the\r\n     * `execute` method.\r\n     * @param initialComponents The types of the components to add to the new entity, optionally\r\n     * interleaved with their initial properties.\r\n     * @returns The newly created entity.\r\n     */\r\n    createEntity(...initialComponents) {\r\n        return this.__dispatcher.createEntity(initialComponents);\r\n    }\r\n    /**\r\n     * Enables or disables access to recently deleted data.  When turned on, you'll be able to read\r\n     * components that were removed since the system's last execution, as well as references and\r\n     * back references to entities deleted in the same time frame.\r\n     * @param toggle Whether to turn access to recently deleted data on or off.\r\n     */\r\n    accessRecentlyDeletedData(toggle = true) {\r\n        this.__dispatcher.registry.includeRecentlyDeleted = toggle;\r\n    }\r\n    /**\r\n     * Starts running a coroutine.  The coroutine will execute after each time this system does and\r\n     * run until its next `yield` expression.  You can start coroutines anytime: from within\r\n     * `initialize` or `execute`, from within a coroutine, or even from an event handler between\r\n     * frames.  Coroutines started from within `execute` will begin running in the same frame.  The\r\n     * execution order of coroutines within a system is unspecified and you should not depend on it.\r\n     *\r\n     * If you're using the {@link co} decorator you don't need call this method manually, it'll be\r\n     * handled for you.\r\n     *\r\n     * Inside the coroutine, you can call methods on {@link co} to control the execution of the\r\n     * coroutine.  You can `yield` on the result of the various `co.wait` methods, and also `yield`\r\n     * directly on the result of starting another coroutine to wait for its returned value.\r\n     *\r\n     * @param generator The generator returned by a coroutine method.\r\n     * @param coroutineFn The coroutine being started, to be used with\r\n     *    {@link Coroutine.cancelIfCoroutineStarted}.\r\n     * @returns A coroutine handle that you can use to control it.\r\n     */\r\n    start(coroutineFn, ...args) {\r\n        // TODO: disable coroutines if system is stateless\r\n        return this.__supervisor.start(coroutineFn, ...args);\r\n    }\r\n    /**\r\n     * Prepares any data or other structures needed by the system; to be implemented in a subclass and\r\n     * invoked automatically precisely once when the world is created.  This method is not allowed to\r\n     * create entities or access components.  Instead, it should set any needed data on the system's\r\n     * properties to be used in `initialize`, which will be called afterwards.\r\n     */\r\n    async prepare() { } // eslint-disable-line @typescript-eslint/no-empty-function\r\n    /**\r\n     * Initializes the system; to be implemented in a subclass and invoked automatically precisely\r\n     * once when the world is created and after the system has been prepared.  This method is allowed\r\n     * to access the components as declared in the system's queries.\r\n     */\r\n    initialize() { } // eslint-disable-line @typescript-eslint/no-empty-function\r\n    /**\r\n     * Executes the system's function; to be implemented in a subclass and invoked automatically at\r\n     * regular intervals.\r\n     */\r\n    execute() { } // eslint-disable-line @typescript-eslint/no-empty-function\r\n    /**\r\n     * Finalizes the system; to be implemented in a subclass and invoked automatically precisely\r\n     * once when the world is terminated.  This method is allowed to access the components as declared\r\n     * in the system's queries.\r\n     */\r\n    finalize() { } // eslint-disable-line @typescript-eslint/no-empty-function\r\n}\r\nObject.defineProperty(System.prototype, 'singleton', {\r\n    get() {\r\n        const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\r\n        const singleton = {\r\n            read(type) {\r\n                if (!self.__singletonPlaceholders) {\r\n                    throw new CheckError(`Attempt to declare a singleton after world initialized in system ${self.name}`);\r\n                }\r\n                declareSingleton(type);\r\n                self.query(q => q.using(type).read);\r\n                const placeholder = new SingletonPlaceholder('read', type);\r\n                self.__singletonPlaceholders.push(placeholder);\r\n                return placeholder;\r\n            },\r\n            write(type, initialValues) {\r\n                if (!self.__singletonPlaceholders) {\r\n                    throw new CheckError(`Attempt to declare a singleton after world initialized in system ${self.name}`);\r\n                }\r\n                declareSingleton(type);\r\n                self.query(q => q.using(type).write);\r\n                const placeholder = new SingletonPlaceholder('write', type, initialValues);\r\n                self.__singletonPlaceholders.push(placeholder);\r\n                return placeholder;\r\n            }\r\n        };\r\n        Object.defineProperty(this, 'singleton', { value: singleton, configurable: true });\r\n        return singleton;\r\n    }\r\n});\r\nclass SystemBox {\r\n    system;\r\n    dispatcher;\r\n    get id() { return this.system.id; }\r\n    get name() { return this.system.name; }\r\n    toString() { return this.name; }\r\n    constructor(system, dispatcher) {\r\n        this.system = system;\r\n        this.dispatcher = dispatcher;\r\n        system.__dispatcher = dispatcher;\r\n        this.accessMasks = { read: [], update: [], create: [], write: [], check: [] };\r\n        this.shapeQueries = [];\r\n        this.shapeQueriesByComponent = [];\r\n        this.writeQueries = [];\r\n        this.writeQueriesByComponent = [];\r\n        this.state = RunState.RUNNING;\r\n        this.propsAssigned = false;\r\n        this.stateless = false;\r\n        this.weight = 1;\r\n        this.shapeLogPointer = dispatcher.shapeLog.createPointer();\r\n        this.stats = dispatcher.stats.forSystem(system.constructor);\r\n        this.attachedSystems = this.system.__attachPlaceholders.map(placeholder => this.dispatcher.systemsByClass.get(placeholder.type));\r\n        this.singletonComponentDefs = this.system.__singletonPlaceholders.flatMap(placeholder => {\r\n            return placeholder.initialValues ?\r\n                [placeholder.type, placeholder.initialValues] : [placeholder.type];\r\n        });\r\n        this.singletonStandingWrites = this.system.__singletonPlaceholders\r\n            .filter(placeholder => placeholder.access === 'write')\r\n            .map(placeholder => placeholder.type);\r\n    }\r\n    assignProps(props) {\r\n        if (this.propsAssigned) {\r\n            throw new CheckError(`System ${this.name} has multiple props assigned in world defs`);\r\n        }\r\n        Object.assign(this.system, props);\r\n        this.propsAssigned = true;\r\n    }\r\n    buildQueries() {\r\n        for (const builder of this.system.__queryBuilders)\r\n            builder.__build(this);\r\n        this.system.__queryBuilders = null;\r\n        this.hasNegativeQueries = !!this.shapeQueriesByComponent[this.dispatcher.registry.Alive.id];\r\n        this.hasWriteQueries = !!this.writeQueries.length;\r\n        this.hasTransientQueries = this.shapeQueries.some(query => query.hasTransientResults);\r\n    }\r\n    buildSchedule() {\r\n        const staticScheduler = this.system.constructor.__staticScheduler;\r\n        if (staticScheduler)\r\n            this.system.schedule(staticScheduler);\r\n        this.system.__scheduleBuilder?.__build([this], `system ${this.name}`);\r\n        this.system.__scheduleBuilder = null;\r\n    }\r\n    finishConstructing() {\r\n        this.writeLogPointer = this.dispatcher.writeLog?.createPointer();\r\n        this.singletonStandingWrites =\r\n            this.singletonStandingWrites.filter(type => type.__binding.trackedWrites);\r\n    }\r\n    replacePlaceholders() {\r\n        const openSystem = this.system;\r\n        for (const prop in this.system) {\r\n            const value = openSystem[prop];\r\n            if (value instanceof AttachPlaceholder) {\r\n                const targetSystemType = value.type;\r\n                const targetSystem = this.dispatcher.systemsByClass.get(targetSystemType);\r\n                if (!targetSystem) {\r\n                    throw new CheckError(`Attached system ${targetSystemType.name} not defined in this world`);\r\n                }\r\n                openSystem[prop] = targetSystem.system;\r\n            }\r\n            else if (value instanceof SingletonPlaceholder) {\r\n                openSystem[prop] = this.dispatcher.singleton[value.access](value.type);\r\n            }\r\n        }\r\n        this.system.__attachPlaceholders = null;\r\n        this.system.__singletonPlaceholders = null;\r\n        if (this.dispatcher.singleton) {\r\n            Object.defineProperty(this.system, 'singleton', { value: this.dispatcher.singleton });\r\n        }\r\n    }\r\n    prepare() {\r\n        return this.system.prepare();\r\n    }\r\n    initialize() {\r\n        this.dispatcher.registry.executingSystem = this;\r\n        this.system.initialize();\r\n        this.trackStandingWrites();\r\n    }\r\n    finalize() {\r\n        this.dispatcher.registry.executingSystem = this;\r\n        this.system.finalize();\r\n        this.trackStandingWrites();\r\n    }\r\n    execute(time, delta) {\r\n        if (this.state !== RunState.RUNNING)\r\n            return;\r\n        this.dispatcher.registry.executingSystem = this;\r\n        this.system.time = time;\r\n        this.system.delta = delta;\r\n        let time1, time2, time3, time4;\r\n        time1 = now();\r\n        this.runQueries();\r\n        time2 = now();\r\n        this.system.execute();\r\n        time3 = now();\r\n        this.system.__supervisor.execute();\r\n        this.trackStandingWrites();\r\n        time4 = now();\r\n        {\r\n            this.stats.lastQueryUpdateDuration = time2 - time1;\r\n            this.stats.lastExecutionDuration = time3 - time2;\r\n            this.stats.lastCoroutinesDuration = time4 - time3;\r\n        }\r\n    }\r\n    trackStandingWrites() {\r\n        const singleton = this.dispatcher.singleton;\r\n        for (const type of this.singletonStandingWrites) {\r\n            this.dispatcher.registry.trackWrite(singleton.__id, type);\r\n        }\r\n    }\r\n    runQueries() {\r\n        const ranQueriesLastFrame = this.ranQueriesLastFrame;\r\n        this.ranQueriesLastFrame = false;\r\n        const shapesChanged = this.dispatcher.shapeLog.hasUpdatesSince(this.shapeLogPointer);\r\n        const writesMade = this.hasWriteQueries &&\r\n            this.dispatcher.writeLog.hasUpdatesSince(this.writeLogPointer);\r\n        if (shapesChanged || writesMade || this.hasTransientQueries && ranQueriesLastFrame) {\r\n            if (this.hasTransientQueries) {\r\n                // Every write query is a shape query too.\r\n                for (const query of this.shapeQueries)\r\n                    query.clearTransientResults();\r\n            }\r\n            if (shapesChanged || writesMade) {\r\n                this.ranQueriesLastFrame = true;\r\n                if (shapesChanged)\r\n                    this.__updateShapeQueries();\r\n                if (writesMade)\r\n                    this.__updateWriteQueries();\r\n                for (const query of this.shapeQueries)\r\n                    query.sort();\r\n            }\r\n        }\r\n    }\r\n    __updateShapeQueries() {\r\n        const shapeLog = this.dispatcher.shapeLog;\r\n        if (!this.shapeQueries.length) {\r\n            shapeLog.createPointer(this.shapeLogPointer);\r\n            return;\r\n        }\r\n        for (const query of this.shapeQueries)\r\n            query.clearProcessedEntities();\r\n        let queries, runLength = 0;\r\n        let log, startIndex, endIndex;\r\n        while (true) {\r\n            [log, startIndex, endIndex] = shapeLog.processSince(this.shapeLogPointer);\r\n            if (!log)\r\n                break;\r\n            if (runLength && !queries) {\r\n                startIndex += runLength;\r\n                runLength = 0;\r\n            }\r\n            for (let i = startIndex; i < endIndex; i++) {\r\n                const entry = log[i];\r\n                const entityId = (entry & ENTITY_ID_MASK);\r\n                if (!queries) {\r\n                    const typeId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;\r\n                    const runHeader = entry & 2 ** 31;\r\n                    queries = this.shapeQueriesByComponent[typeId];\r\n                    if (runHeader) {\r\n                        runLength = entityId;\r\n                        if (!queries) {\r\n                            const skip = Math.min(runLength, endIndex - i);\r\n                            i += skip;\r\n                            runLength -= skip;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (!queries)\r\n                        continue;\r\n                    runLength = 1;\r\n                }\r\n                if (entry & 2 ** 31) {\r\n                    throw new InternalError('Trying to process run header as entry in shape log');\r\n                }\r\n                for (let j = 0; j < queries.length; j++)\r\n                    queries[j].handleShapeUpdate(entityId);\r\n                if (--runLength === 0)\r\n                    queries = undefined;\r\n            }\r\n        }\r\n    }\r\n    __updateWriteQueries() {\r\n        const writeLog = this.dispatcher.writeLog;\r\n        if (!this.writeQueries.length) {\r\n            writeLog.createPointer(this.writeLogPointer);\r\n            return;\r\n        }\r\n        let queries, runLength = 0;\r\n        let componentFlagOffset, componentFlagMask;\r\n        let log, startIndex, endIndex;\r\n        while (true) {\r\n            [log, startIndex, endIndex] = writeLog.processSince(this.writeLogPointer);\r\n            if (!log)\r\n                break;\r\n            if (runLength && !queries) {\r\n                startIndex += runLength;\r\n                runLength = 0;\r\n            }\r\n            for (let i = startIndex; i < endIndex; i++) {\r\n                const entry = log[i];\r\n                const entityId = (entry & ENTITY_ID_MASK);\r\n                if (!queries) {\r\n                    const typeId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;\r\n                    const runHeader = entry & 2 ** 31;\r\n                    // Manually recompute flag offset and mask instead of looking up component type.\r\n                    componentFlagOffset = typeId >> 5;\r\n                    componentFlagMask = 1 << (typeId & 31);\r\n                    queries = this.writeQueriesByComponent[typeId];\r\n                    if (runHeader) {\r\n                        runLength = entityId;\r\n                        if (!queries) {\r\n                            const skip = Math.min(runLength, endIndex - i);\r\n                            i += skip;\r\n                            runLength -= skip;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (!queries)\r\n                        continue;\r\n                    runLength = 1;\r\n                }\r\n                if (entry & 2 ** 31) {\r\n                    throw new InternalError('Trying to process run header as entry in write log');\r\n                }\r\n                for (let j = 0; j < queries.length; j++) {\r\n                    queries[j].handleWrite(entityId, componentFlagOffset, componentFlagMask);\r\n                }\r\n                if (--runLength === 0)\r\n                    queries = undefined;\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.state === RunState.STOPPED)\r\n            return;\r\n        this.state = RunState.STOPPED;\r\n        for (const query of this.shapeQueries)\r\n            query.clearAllResults();\r\n    }\r\n    restart() {\r\n        if (this.state === RunState.STOPPED) {\r\n            const registry = this.dispatcher.registry;\r\n            const Alive = registry.Alive;\r\n            for (const query of this.shapeQueries)\r\n                query.clearProcessedEntities();\r\n            for (let id = 0; id < this.dispatcher.maxEntities; id++) {\r\n                if (registry.hasShape(id, Alive, false)) {\r\n                    for (const query of this.shapeQueries)\r\n                        query.handleShapeUpdate(id);\r\n                }\r\n            }\r\n            for (const query of this.shapeQueries) {\r\n                query.clearTransientResults();\r\n                query.sort();\r\n            }\r\n            this.dispatcher.shapeLog.createPointer(this.shapeLogPointer);\r\n            this.dispatcher.writeLog?.createPointer(this.writeLogPointer);\r\n        }\r\n        this.state = RunState.RUNNING;\r\n    }\r\n}\n\nclass ComponentEnum {\r\n    name;\r\n    __types;\r\n    __binding;\r\n    constructor(name, types) {\r\n        this.name = name;\r\n        this.__types = Array.from(new Set(types));\r\n    }\r\n}\n\nconst HEADER_LENGTH = 2;\r\nclass UnsharedPool {\r\n    maxItems;\r\n    configParamName;\r\n    // layout: length, mark, ...uints\r\n    data;\r\n    constructor(maxItems, configParamName) {\r\n        this.maxItems = maxItems;\r\n        this.configParamName = configParamName;\r\n        this.data = new Uint32Array(new ArrayBuffer((maxItems + HEADER_LENGTH) * Uint32Array.BYTES_PER_ELEMENT));\r\n    }\r\n    get length() {\r\n        return this.data[0];\r\n    }\r\n    take() {\r\n        const length = --this.data[0];\r\n        if (length < 0) {\r\n            throw new RangeError(`Pool capacity exceeded, please raise ${this.configParamName} above ${this.maxItems}`);\r\n        }\r\n        return this.data[length + HEADER_LENGTH];\r\n    }\r\n    return(id) {\r\n        if (this.length >= this.maxItems) {\r\n            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');\r\n        }\r\n        this.data[this.length + HEADER_LENGTH] = id;\r\n        this.data[0] += 1;\r\n    }\r\n    mark() {\r\n        this.data[1] = this.data[0];\r\n    }\r\n    peekSinceMark(index) {\r\n        const i = this.data[1] + index;\r\n        if (i < this.data[0])\r\n            return this.data[i + HEADER_LENGTH];\r\n    }\r\n    refill(source) {\r\n        if (!source.length)\r\n            return;\r\n        const length = this.length;\r\n        const newLength = length + source.length;\r\n        if (newLength > this.maxItems) {\r\n            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');\r\n        }\r\n        this.data.set(source, length + HEADER_LENGTH);\r\n        this.data[0] = newLength;\r\n    }\r\n    fillWithDescendingIntegers(first) {\r\n        const lowerBound = this.length + HEADER_LENGTH;\r\n        for (let i = this.data.length - 1; i >= lowerBound; i--) {\r\n            this.data[i] = first++;\r\n        }\r\n        this.data[0] = this.data.length - HEADER_LENGTH;\r\n    }\r\n}\r\n/**\r\n * A shared pool of u32's that uses atomic operations to deconflict concurrent callers of `take`.\r\n * The `return` method is not threadsafe.\r\n */\r\nclass SharedAtomicPool {\r\n    maxItems;\r\n    configParamName;\r\n    // layout: length, mark, ...uints\r\n    data;\r\n    constructor(maxItems, configParamName, buffers) {\r\n        this.maxItems = maxItems;\r\n        this.configParamName = configParamName;\r\n        buffers.register(`pool.${configParamName}`, maxItems + HEADER_LENGTH, Uint32Array, (data) => { this.data = data; });\r\n    }\r\n    get length() {\r\n        return this.data[0];\r\n    }\r\n    take() {\r\n        const length = Atomics.sub(this.data, 0, 1);\r\n        if (length < 0) {\r\n            throw new RangeError(`Pool capacity exceeded, please raise ${this.configParamName} above ${this.maxItems}`);\r\n        }\r\n        return this.data[length + HEADER_LENGTH];\r\n    }\r\n    return(id) {\r\n        if (this.length >= this.maxItems) {\r\n            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');\r\n        }\r\n        this.data[this.length + HEADER_LENGTH] = id;\r\n        this.data[0] += 1;\r\n    }\r\n    mark() {\r\n        this.data[1] = this.data[0];\r\n    }\r\n    peekSinceMark(index) {\r\n        const i = this.data[1] + index;\r\n        if (i < this.data[0])\r\n            return this.data[i + HEADER_LENGTH];\r\n    }\r\n    refill(source) {\r\n        if (!source.length)\r\n            return;\r\n        const length = this.length;\r\n        const newLength = length + source.length;\r\n        if (newLength > this.maxItems) {\r\n            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');\r\n        }\r\n        this.data.set(source, length + HEADER_LENGTH);\r\n        this.data[0] = newLength;\r\n    }\r\n    fillWithDescendingIntegers(first) {\r\n        const lowerBound = this.length + HEADER_LENGTH;\r\n        for (let i = this.data.length - 1; i >= lowerBound; i--) {\r\n            this.data[i] = first++;\r\n        }\r\n        this.data[0] = this.data.length - HEADER_LENGTH;\r\n    }\r\n}\n\nclass UnsharedShapeArray {\r\n    stride;\r\n    array;\r\n    constructor(bufferKey, numBits, maxEntities, buffers) {\r\n        this.stride = Math.ceil(numBits / 32);\r\n        buffers.register(bufferKey, maxEntities * this.stride, Uint32Array, shapes => { this.array = shapes; });\r\n    }\r\n    syncThreads() {\r\n        // no-op\r\n    }\r\n    set(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        const value = binding.shapeValue;\r\n        this.array[index] &= ~mask;\r\n        this.array[index] |= value;\r\n    }\r\n    unset(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        this.array[index] &= ~mask;\r\n    }\r\n    isSet(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        const value = binding.shapeValue;\r\n        return (this.array[index] & mask) === value;\r\n    }\r\n    get(entityId, enumeration) {\r\n        const binding = enumeration.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        return (this.array[index] & mask) >>> binding.shapeShift;\r\n    }\r\n    clear() {\r\n        this.array.fill(0);\r\n    }\r\n    match(entityId, positiveMask, positiveValues) {\r\n        if (positiveMask.length !== positiveValues.length) {\r\n            throw new InternalError(`Mismatched mask and value lengths: ${positiveMask.length} vs ${positiveValues.length}`);\r\n        }\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < positiveMask.length; i++) {\r\n            if ((array[index + i] & positiveMask[i]) !== positiveValues[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    matchNot(entityId, negativeMask) {\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < negativeMask.length; i++) {\r\n            if ((array[index + i] & negativeMask[i]) !== 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    matchAny(entityId, trackingMask) {\r\n        trackingMask.changed = false;\r\n        const mask = trackingMask.mask;\r\n        const lastMatch = trackingMask.lastMatches[entityId] = trackingMask.lastMatches[entityId] || [];\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        let ok = false;\r\n        for (let i = 0; i < mask.length; i++) {\r\n            const masked = array[index + i] & mask[i];\r\n            if (masked !== 0)\r\n                ok = true;\r\n            if (masked !== lastMatch[i])\r\n                trackingMask.changed = true;\r\n            lastMatch[i] = masked;\r\n        }\r\n        if (!ok)\r\n            delete trackingMask.lastMatches[entityId];\r\n        return ok;\r\n    }\r\n}\r\nclass AtomicSharedShapeArray {\r\n    stride;\r\n    array;\r\n    constructor(bufferKey, numBits, maxEntities, buffers) {\r\n        this.stride = Math.ceil(numBits / 32);\r\n        buffers.register(bufferKey, maxEntities * this.stride, Uint32Array, shapes => { this.array = shapes; });\r\n    }\r\n    syncThreads() {\r\n        // We assume that any atomic operation will force a write barrier on the whole array.\r\n        Atomics.load(this.array, 0);\r\n    }\r\n    set(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        const value = binding.shapeValue;\r\n        if (mask !== value)\r\n            Atomics.and(this.array, index, ~mask);\r\n        Atomics.or(this.array, index, value);\r\n    }\r\n    unset(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        Atomics.and(this.array, index, ~mask);\r\n    }\r\n    isSet(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        const value = binding.shapeValue;\r\n        // Entity liveness flag can be written at any time from any thread, so do atomic check.\r\n        if (type.id === 0)\r\n            return (Atomics.load(this.array, index) & mask) === value;\r\n        return (this.array[index] & mask) === value;\r\n    }\r\n    get(entityId, enumeration) {\r\n        const binding = enumeration.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        return (this.array[index] & mask) >>> binding.shapeShift;\r\n    }\r\n    clear() {\r\n        this.array.fill(0);\r\n    }\r\n    match(entityId, positiveMask, positiveValues) {\r\n        if (positiveMask.length !== positiveValues.length) {\r\n            throw new InternalError(`Mismatched mask and value lengths: ${positiveMask.length} vs ${positiveValues.length}`);\r\n        }\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < positiveMask.length; i++) {\r\n            if ((array[index + i] & positiveMask[i]) !== positiveValues[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    matchNot(entityId, negativeMask) {\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < negativeMask.length; i++) {\r\n            if ((array[index + i] & negativeMask[i]) !== 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    matchAny(entityId, trackingMask) {\r\n        trackingMask.changed = false;\r\n        const mask = trackingMask.mask;\r\n        const lastMatch = trackingMask.lastMatches[entityId] = trackingMask.lastMatches[entityId] || [];\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < mask.length; i++) {\r\n            const masked = array[index + i] & mask[i];\r\n            if (masked === 0) {\r\n                delete trackingMask.lastMatches[entityId];\r\n                return false;\r\n            }\r\n            if (masked !== lastMatch[i])\r\n                trackingMask.changed = true;\r\n            lastMatch[i] = masked;\r\n        }\r\n        return true;\r\n    }\r\n}\n\nconst SYSTEM_ERROR_TYPES = [\r\n    EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError,\r\n    CheckError, InternalError\r\n];\r\nclass EntityPool {\r\n    registry;\r\n    borrowed; // indexed by id\r\n    borrowCounts; // indexed by id\r\n    spares = [];\r\n    temporarilyBorrowedIds = [];\r\n    constructor(registry, maxEntities) {\r\n        this.registry = registry;\r\n        this.borrowed = Array.from({ length: maxEntities });\r\n        this.borrowCounts = new Int32Array(maxEntities);\r\n    }\r\n    borrow(id) {\r\n        this.borrowCounts[id] += 1;\r\n        let entity = this.borrowed[id];\r\n        if (!entity) {\r\n            entity = this.borrowed[id] = this.spares.pop() ?? new EntityImpl(this.registry);\r\n            entity.__id = id;\r\n        }\r\n        return entity;\r\n    }\r\n    borrowTemporarily(id) {\r\n        const entity = this.borrow(id);\r\n        this.temporarilyBorrowedIds.push(id);\r\n        return entity;\r\n    }\r\n    returnTemporaryBorrows() {\r\n        for (const id of this.temporarilyBorrowedIds)\r\n            this.return(id);\r\n        this.temporarilyBorrowedIds.length = 0;\r\n    }\r\n    return(id) {\r\n        {\r\n            if (!this.borrowCounts[id]) {\r\n                throw new InternalError('Returning entity with no borrows');\r\n            }\r\n        }\r\n        if (--this.borrowCounts[id] <= 0) {\r\n            const entity = this.borrowed[id];\r\n            this.borrowed[id] = undefined;\r\n            {\r\n                entity.__valid = false;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Registry {\r\n    types;\r\n    enums;\r\n    dispatcher;\r\n    allocationItems;\r\n    numShapeBits = 0;\r\n    shapes;\r\n    staleShapes;\r\n    removedShapes;\r\n    entityIdPool;\r\n    pool;\r\n    heldEntities;\r\n    validators;\r\n    reshapedEntityIds = [];\r\n    validateSystem;\r\n    executingSystem;\r\n    includeRecentlyDeleted = false;\r\n    hasNegativeQueries = false;\r\n    nextEntityOrdinal = 0;\r\n    entityOrdinals;\r\n    removalLog;\r\n    prevRemovalPointer;\r\n    oldRemovalPointer;\r\n    Alive = class Alive {\r\n        static __internal = true;\r\n    };\r\n    constructor(maxEntities, maxLimboComponents, types, enums, dispatcher) {\r\n        this.types = types;\r\n        this.enums = enums;\r\n        this.dispatcher = dispatcher;\r\n        this.allocationItems = this.prepareComponentTypesAndEnums();\r\n        for (const item of this.allocationItems)\r\n            this.numShapeBits += item.size;\r\n        const ShapeArrayClass = dispatcher.threaded ? AtomicSharedShapeArray : UnsharedShapeArray;\r\n        this.shapes = new ShapeArrayClass('registry.shapes', this.numShapeBits, maxEntities, dispatcher.buffers);\r\n        this.staleShapes = new ShapeArrayClass('registry.staleShapes', this.numShapeBits, maxEntities, dispatcher.buffers);\r\n        this.removedShapes = new ShapeArrayClass('registry.removedShapes', this.numShapeBits, maxEntities, dispatcher.buffers);\r\n        this.entityIdPool = dispatcher.threaded ?\r\n            new SharedAtomicPool(maxEntities, 'maxEntities', dispatcher.buffers) :\r\n            new UnsharedPool(maxEntities, 'maxEntities');\r\n        this.entityOrdinals = dispatcher.buffers.register('registry.entityOrdinals', maxEntities, Uint32Array, array => { this.entityOrdinals = array; });\r\n        this.entityIdPool.fillWithDescendingIntegers(0);\r\n        this.pool = new EntityPool(this, maxEntities);\r\n        this.heldEntities = [];\r\n        this.validators = [];\r\n        this.removalLog = new Log(maxLimboComponents, 'maxLimboComponents', dispatcher.buffers);\r\n        this.prevRemovalPointer = this.removalLog.createPointer();\r\n        this.oldRemovalPointer = this.removalLog.createPointer();\r\n    }\r\n    initializeComponentTypes() {\r\n        // Two-phase init, so components can have dependencies on each other's fields.\r\n        let bitIndex = 0, typeId = 0;\r\n        while (this.allocationItems.length) {\r\n            const shift = bitIndex % 32;\r\n            const item = this.removeBiggestNoLargerThan(32 - shift);\r\n            if (!item) {\r\n                bitIndex += 32 - shift;\r\n                continue;\r\n            }\r\n            const shapeSpec = {\r\n                offset: bitIndex >>> 5, mask: ((1 << item.size) - 1) << shift, value: 1 << shift\r\n            };\r\n            bitIndex += item.size;\r\n            if (item.typeOrEnum instanceof ComponentEnum) {\r\n                const enumeration = item.typeOrEnum;\r\n                enumeration.__binding = {\r\n                    shapeOffset: shapeSpec.offset, shapeMask: shapeSpec.mask, shapeShift: shift\r\n                };\r\n                for (const type of enumeration.__types) {\r\n                    assimilateComponentType(typeId++, type, shapeSpec, this.dispatcher);\r\n                    if (type.validate)\r\n                        this.validators.push(type);\r\n                    shapeSpec.value += 1 << shift;\r\n                }\r\n            }\r\n            else {\r\n                const type = item.typeOrEnum;\r\n                assimilateComponentType(typeId++, type, shapeSpec, this.dispatcher);\r\n                if (type.validate)\r\n                    this.validators.push(type);\r\n            }\r\n        }\r\n        for (const type of this.types)\r\n            defineAndAllocateComponentType(type);\r\n        {\r\n            const aliveBinding = this.Alive.__binding;\r\n            if (!(aliveBinding.shapeOffset === 0 && aliveBinding.shapeMask === 1 &&\r\n                aliveBinding.shapeValue === 1)) {\r\n                throw new InternalError('Alive component was not assigned first available shape mask');\r\n            }\r\n        }\r\n    }\r\n    prepareComponentTypesAndEnums() {\r\n        const pool = [];\r\n        const enumTypes = new Set();\r\n        const typeNames = new Set();\r\n        let anonymousTypeCounter = 0;\r\n        for (const type of this.types) {\r\n            if (!type.name) {\r\n                Object.defineProperty(type, 'name', { value: `Anonymous_${anonymousTypeCounter++}` });\r\n            }\r\n            if (!type.__internal) {\r\n                if (typeNames.has(type.name)) {\r\n                    throw new CheckError(`Multiple component types named ${type.name}; names must be unique`);\r\n                }\r\n                typeNames.add(type.name);\r\n            }\r\n            if (type.enum) {\r\n                if (!this.enums.includes(type.enum)) {\r\n                    throw new CheckError(`Component type ${type.name} references an enum that's not in the world's defs`);\r\n                }\r\n                if (!type.enum.__types.includes(type))\r\n                    type.enum.__types.push(type);\r\n            }\r\n            this.dispatcher.stats.forComponent(type);\r\n        }\r\n        for (const enumeration of this.enums) {\r\n            if (enumeration.__types.length > 2 ** 31) {\r\n                throw new CheckError(`Too many types in enum: ${enumeration.__types.length}`);\r\n            }\r\n            pool.push({\r\n                // +1 for the implicit null value of every enum\r\n                typeOrEnum: enumeration, size: Math.ceil(Math.log2(enumeration.__types.length + 1))\r\n            });\r\n            for (const type of enumeration.__types) {\r\n                if (enumTypes.has(type)) {\r\n                    throw new CheckError(`Component type ${type.name} is a member of more than one enum`);\r\n                }\r\n                type.enum = enumeration;\r\n                enumTypes.add(type);\r\n            }\r\n        }\r\n        for (const type of this.types) {\r\n            if (!enumTypes.has(type))\r\n                pool.push({ typeOrEnum: type, size: 1 });\r\n        }\r\n        pool.sort((a, b) => b.size - a.size);\r\n        // Ensure that Alive will always be the first type allocated.\r\n        this.types.unshift(this.Alive);\r\n        pool.unshift({ typeOrEnum: this.Alive, size: 1 });\r\n        return pool;\r\n    }\r\n    removeBiggestNoLargerThan(maxSize) {\r\n        const k = this.allocationItems.findIndex(item => item.size <= maxSize);\r\n        if (k === -1)\r\n            return;\r\n        return this.allocationItems.splice(k, 1)[0];\r\n    }\r\n    releaseComponentTypes() {\r\n        for (const type of this.types)\r\n            dissimilateComponentType(type);\r\n        for (const enumeration of this.enums)\r\n            delete enumeration.__binding;\r\n    }\r\n    createEntity(initialComponents) {\r\n        const id = this.entityIdPool.take();\r\n        this.entityOrdinals[id] = this.nextEntityOrdinal++;\r\n        this.setShape(id, this.Alive);\r\n        const entity = this.pool.borrowTemporarily(id);\r\n        this.createComponents(id, initialComponents);\r\n        this.dispatcher.stats.numEntities += 1;\r\n        return entity;\r\n    }\r\n    // Everything is copied over from Entity and inlined here to keep performance from cratering.\r\n    // Just calling checkMask with 'create' kills it...\r\n    createComponents(id, initialComponents) {\r\n        for (let i = 0; i < initialComponents.length; i++) {\r\n            const type = initialComponents[i];\r\n            {\r\n                if (typeof type !== 'function') {\r\n                    throw new CheckError(`Bad arguments to createEntity: expected component type, got: ${type}`);\r\n                }\r\n                checkTypeDefined(type);\r\n                const mask = this.executingSystem?.accessMasks.create;\r\n                if (mask) {\r\n                    const binding = type.__binding;\r\n                    if (((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) === 0) {\r\n                        throw new CheckError(`System ${this.executingSystem?.name} didn't mark component ${type.name} ` +\r\n                            `as createable`);\r\n                    }\r\n                }\r\n                if (type.enum) {\r\n                    if (this.getEnumShape(id, type.enum, false)) {\r\n                        throw new CheckError(`Can't add multiple components from the same enum when creating entity: ` +\r\n                            type.name);\r\n                    }\r\n                }\r\n                else if (this.hasShape(id, type, false)) {\r\n                    throw new CheckError(`Duplicate ${type.name} component when creating entity`);\r\n                }\r\n            }\r\n            let value = initialComponents[i + 1];\r\n            if (typeof value === 'function')\r\n                value = undefined;\r\n            else\r\n                i++;\r\n            this.setShape(id, type);\r\n            this.dispatcher.stats.forComponent(type).numEntities += 1;\r\n            initComponent(type, id, value);\r\n        }\r\n    }\r\n    flush() {\r\n        const lastExecutingSystem = this.executingSystem;\r\n        this.includeRecentlyDeleted = false;\r\n        this.validateShapes(lastExecutingSystem);\r\n        this.executingSystem = undefined;\r\n        this.pool.returnTemporaryBorrows();\r\n        this.removalLog.commit();\r\n    }\r\n    completeCycle() {\r\n        this.processRemovalLog();\r\n        this.invalidateDeletedHeldEntities();\r\n    }\r\n    validateShapes(system) {\r\n        this.executingSystem = this.validateSystem;\r\n        for (const entityId of this.reshapedEntityIds) {\r\n            for (const componentType of this.validators) {\r\n                try {\r\n                    componentType.validate(this.pool.borrowTemporarily(entityId));\r\n                }\r\n                catch (e) {\r\n                    if (!SYSTEM_ERROR_TYPES.includes(e.constructor)) {\r\n                        const systemSuffix = system ? ` after system ${system.name} executed` : '';\r\n                        const componentNames = this.types\r\n                            .filter(type => type !== this.Alive && this.hasShape(entityId, type, false))\r\n                            .map(type => type.name)\r\n                            .join(', ') || 'none';\r\n                        e.message =\r\n                            `An entity failed to satisfy ${componentType.name}.validate${systemSuffix}: ` +\r\n                                `${e.message} (components: ${componentNames})`;\r\n                    }\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        this.reshapedEntityIds.length = 0;\r\n    }\r\n    processRemovalLog() {\r\n        const indexer = this.dispatcher.indexer;\r\n        this.removalLog.commit();\r\n        this.entityIdPool.mark();\r\n        let numDeletedEntities = 0;\r\n        let log, startIndex, endIndex;\r\n        {\r\n            this.dispatcher.stats.maxLimboComponents =\r\n                this.removalLog.countSince(this.removalLog.copyPointer(this.oldRemovalPointer));\r\n        }\r\n        while (true) {\r\n            [log, startIndex, endIndex] =\r\n                this.removalLog.processSince(this.oldRemovalPointer, this.prevRemovalPointer);\r\n            if (!log)\r\n                break;\r\n            for (let i = startIndex; i < endIndex; i++) {\r\n                const entry = log[i];\r\n                const entityId = (entry & ENTITY_ID_MASK);\r\n                const componentId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;\r\n                const type = this.types[componentId];\r\n                if (!this.shapes.isSet(entityId, type) && !this.removedShapes.isSet(entityId, type)) {\r\n                    this.staleShapes.unset(entityId, type);\r\n                    if (type === this.Alive) {\r\n                        indexer.clearAllRefs(entityId, true);\r\n                        this.entityIdPool.return(entityId);\r\n                        numDeletedEntities += 1;\r\n                    }\r\n                    else {\r\n                        this.clearRefs(entityId, type, true);\r\n                    }\r\n                    type.__free?.(entityId);\r\n                    this.removedShapes.set(entityId, type);\r\n                }\r\n            }\r\n        }\r\n        this.dispatcher.stats.numEntities -= numDeletedEntities;\r\n        this.removedShapes.clear();\r\n        this.removalLog.createPointer(this.prevRemovalPointer);\r\n    }\r\n    invalidateDeletedHeldEntities() {\r\n        let index = 0;\r\n        let entityId;\r\n        while ((entityId = this.entityIdPool.peekSinceMark(index++)) !== undefined) {\r\n            const entity = this.heldEntities[entityId];\r\n            if (entity) {\r\n                entity.__valid = false;\r\n                delete this.heldEntities[entityId];\r\n            }\r\n        }\r\n    }\r\n    holdEntity(id) {\r\n        let entity;\r\n        entity = this.heldEntities[id];\r\n        if (!entity) {\r\n            entity = new EntityImpl(this);\r\n            entity.__id = id;\r\n            this.heldEntities[id] = entity;\r\n        }\r\n        return entity;\r\n    }\r\n    hasShape(id, type, allowRecentlyDeleted) {\r\n        if (this.shapes.isSet(id, type))\r\n            return true;\r\n        if (allowRecentlyDeleted && this.includeRecentlyDeleted &&\r\n            this.staleShapes.isSet(id, type))\r\n            return true;\r\n        return false;\r\n    }\r\n    getEnumShape(id, enumeration, allowRecentlyDeleted) {\r\n        let index = this.shapes.get(id, enumeration);\r\n        if (index === 0 && allowRecentlyDeleted && this.includeRecentlyDeleted) {\r\n            index = this.staleShapes.get(id, enumeration);\r\n        }\r\n        if (index > 0)\r\n            return enumeration.__types[index - 1];\r\n    }\r\n    setShape(id, type) {\r\n        if (type.enum) {\r\n            const oldType = this.getEnumShape(id, type.enum, false);\r\n            if (oldType)\r\n                this.clearShape(id, oldType);\r\n        }\r\n        this.shapes.set(id, type);\r\n        this.staleShapes.set(id, type);\r\n        this.reshapedEntityIds.push(id);\r\n        if (type !== this.Alive || this.hasNegativeQueries) {\r\n            this.dispatcher.shapeLog.push(id | (type.id << ENTITY_ID_BITS), type);\r\n        }\r\n    }\r\n    clearShape(id, type) {\r\n        this.clearRefs(id, type, false);\r\n        this.shapes.unset(id, type);\r\n        this.removedShapes.set(id, type);\r\n        this.reshapedEntityIds.push(id);\r\n        const logEntry = id | (type.id << ENTITY_ID_BITS);\r\n        this.removalLog.push(logEntry);\r\n        if (type !== this.Alive || this.hasNegativeQueries) {\r\n            this.dispatcher.shapeLog.push(logEntry, type);\r\n        }\r\n        this.dispatcher.stats.forComponent(type).numEntities -= 1;\r\n    }\r\n    trackWrite(id, type) {\r\n        this.dispatcher.writeLog.push(id | (type.id << ENTITY_ID_BITS), type);\r\n    }\r\n    clearRefs(id, type, final) {\r\n        const hasRefs = !!type.__binding.refFields.length;\r\n        if (hasRefs) {\r\n            type.__bind(id, true);\r\n            for (const field of type.__binding.refFields)\r\n                field.clearRef(final);\r\n        }\r\n    }\r\n    matchShape(id, positiveMask, positiveValues, trackingMasks, negativeMask, negativeTypes) {\r\n        if (positiveMask && positiveValues && !this.shapes.match(id, positiveMask, positiveValues)) {\r\n            return false;\r\n        }\r\n        if (negativeMask && !this.shapes.matchNot(id, negativeMask))\r\n            return false;\r\n        if (negativeTypes) {\r\n            for (const type of negativeTypes)\r\n                if (this.shapes.isSet(id, type))\r\n                    return false;\r\n        }\r\n        if (trackingMasks) {\r\n            for (const trackingMask of trackingMasks) {\r\n                if (trackingMask.lastMatches) {\r\n                    if (!this.shapes.matchAny(id, trackingMask))\r\n                        return false;\r\n                }\r\n                else if (this.shapes.matchNot(id, trackingMask.mask)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\n\nconst ALPHA = 0.05;\r\nfunction computeMovingAverage(average, value) {\r\n    return value * ALPHA + average * (1 - ALPHA);\r\n}\r\nclass ComponentStats {\r\n    type;\r\n    _numEntities = 0;\r\n    maxEntities = 0;\r\n    capacity = 0;\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n    get numEntities() {\r\n        return this._numEntities;\r\n    }\r\n    set numEntities(value) {\r\n        this._numEntities = value;\r\n        if (value > this.maxEntities)\r\n            this.maxEntities = value;\r\n    }\r\n    toString() {\r\n        /* eslint-disable max-len */\r\n        return `${this.numEntities.toLocaleString()} of ${this.maxEntities.toLocaleString()} peak (capacity ${this.capacity.toLocaleString()})`;\r\n        /* eslint-enable max-len */\r\n    }\r\n}\r\nclass SystemStats {\r\n    type;\r\n    worker; // -1 means replicated to all workers\r\n    _lastQueryUpdateDuration = 0;\r\n    averageQueryUpdateDuration = 0;\r\n    _lastExecutionDuration = 0;\r\n    averageExecutionDuration = 0;\r\n    _lastCoroutinesDuration = 0;\r\n    averageCoroutinesDuration = 0;\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n    get lastQueryUpdateDuration() {\r\n        return this._lastQueryUpdateDuration;\r\n    }\r\n    set lastQueryUpdateDuration(value) {\r\n        this._lastQueryUpdateDuration = value;\r\n        this.averageQueryUpdateDuration = computeMovingAverage(this.averageQueryUpdateDuration, value);\r\n    }\r\n    get lastExecutionDuration() {\r\n        return this._lastExecutionDuration;\r\n    }\r\n    set lastExecutionDuration(value) {\r\n        this._lastExecutionDuration = value;\r\n        this.averageExecutionDuration = computeMovingAverage(this.averageExecutionDuration, value);\r\n    }\r\n    get lastCoroutinesDuration() {\r\n        return this._lastCoroutinesDuration;\r\n    }\r\n    set lastCoroutinesDuration(value) {\r\n        this._lastCoroutinesDuration = value;\r\n        this.averageCoroutinesDuration = computeMovingAverage(this.averageCoroutinesDuration, value);\r\n    }\r\n}\r\nclass Stats {\r\n    frames = 0;\r\n    _numEntities = 0;\r\n    _maxEntities = 0;\r\n    _maxLimboComponents = 0;\r\n    _maxRefChangesPerFrame = 0;\r\n    _maxShapeChangesPerFrame = 0;\r\n    _maxWritesPerFrame = 0;\r\n    components = Object.create(null);\r\n    systems = Object.create(null);\r\n    get maxEntities() {\r\n        return this._maxEntities;\r\n    }\r\n    get numEntities() {\r\n        return this._numEntities;\r\n    }\r\n    set numEntities(value) {\r\n        this._numEntities = value;\r\n        if (value > this._maxEntities)\r\n            this._maxEntities = value;\r\n    }\r\n    get maxLimboComponents() {\r\n        return this._maxLimboComponents;\r\n    }\r\n    set maxLimboComponents(value) {\r\n        if (value > this._maxLimboComponents)\r\n            this._maxLimboComponents = value;\r\n    }\r\n    get maxRefChangesPerFrame() {\r\n        return this._maxRefChangesPerFrame;\r\n    }\r\n    set maxRefChangesPerFrame(value) {\r\n        if (value > this._maxRefChangesPerFrame)\r\n            this._maxRefChangesPerFrame = value;\r\n    }\r\n    get maxShapeChangesPerFrame() {\r\n        return this._maxShapeChangesPerFrame;\r\n    }\r\n    set maxShapeChangesPerFrame(value) {\r\n        if (value > this._maxShapeChangesPerFrame)\r\n            this._maxShapeChangesPerFrame = value;\r\n    }\r\n    get maxWritesPerFrame() {\r\n        return this._maxWritesPerFrame;\r\n    }\r\n    set maxWritesPerFrame(value) {\r\n        if (value > this._maxWritesPerFrame)\r\n            this._maxWritesPerFrame = value;\r\n    }\r\n    forComponent(type) {\r\n        const componentStats = this.components[type.name] ?? new ComponentStats(type);\r\n        if (!type.__internal)\r\n            this.components[type.name] = componentStats;\r\n        return componentStats;\r\n    }\r\n    forSystem(type) {\r\n        const systemStats = this.systems[type.name] ?? new SystemStats(type);\r\n        if (!type.__internal)\r\n            this.systems[type.name] = systemStats;\r\n        return systemStats;\r\n    }\r\n    toString() {\r\n        /* eslint-disable max-len */\r\n        return `World stats:\n  frames: ${this.frames.toLocaleString()}\n  entities: ${this.numEntities.toLocaleString()} of ${this.maxEntities.toLocaleString()} max\n  refs: ${this.maxRefChangesPerFrame.toLocaleString()} ref changes/frame max\n  logs: ${this.maxShapeChangesPerFrame.toLocaleString()} shape changes/frame max, ${this.maxWritesPerFrame.toLocaleString()} writes/frame max\n  components: (${this.maxLimboComponents.toLocaleString()} limbo max)\\n` +\r\n            Object.keys(this.components).map(name => {\r\n                const compStats = this.components[name];\r\n                return `    ${name}: ${compStats.numEntities} (max ${compStats.maxEntities})`;\r\n            }).join('\\n');\r\n        /* eslint-enable max-len */\r\n    }\r\n}\n\nvar Action;\r\n(function (Action) {\r\n    Action[Action[\"REFERENCE\"] = 0] = \"REFERENCE\";\r\n    Action[Action[\"UNREFERENCE\"] = 1073741824] = \"UNREFERENCE\";\r\n    Action[Action[\"RELEASE\"] = 2147483648] = \"RELEASE\";\r\n    Action[Action[\"UNREFERENCE_AND_RELEASE\"] = -1073741824] = \"UNREFERENCE_AND_RELEASE\";\r\n})(Action || (Action = {}));\r\nconst ACTION_MASK = Action.UNREFERENCE_AND_RELEASE;\r\nclass Tracker {\r\n    targetEntityId;\r\n    selector;\r\n    trackStale;\r\n    dispatcher;\r\n    entities = [];\r\n    tags;\r\n    entityIndex;\r\n    clearing = false;\r\n    registry;\r\n    constructor(targetEntityId, selector, trackStale, dispatcher) {\r\n        this.targetEntityId = targetEntityId;\r\n        this.selector = selector;\r\n        this.trackStale = trackStale;\r\n        this.dispatcher = dispatcher;\r\n        const binding = selector.sourceType?.__binding;\r\n        const precise = selector.matchType && (selector.matchSeq && !binding.fields[selector.sourceSeq].type.internallyIndexed ||\r\n            binding.refFields.length === 1 && !binding.refFields[0].type.internallyIndexed);\r\n        if (!precise)\r\n            this.tags = [];\r\n        this.registry = dispatcher.registry;\r\n    }\r\n    clearAllRefs(final) {\r\n        if (!this.tags)\r\n            throw new InternalError('Unreferencing an untagged tracker');\r\n        this.clearing = true;\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            const entityId = this.entities[i].__id;\r\n            const set = this.tags[i];\r\n            if (typeof set === 'number') {\r\n                this.clearRef(entityId, set, final);\r\n            }\r\n            else {\r\n                for (const tag of set)\r\n                    this.clearRef(entityId, tag, final);\r\n            }\r\n        }\r\n        this.entities = [];\r\n        if (this.tags)\r\n            this.tags = [];\r\n        this.entityIndex = undefined;\r\n        this.clearing = false;\r\n    }\r\n    clearRef(sourceId, tag, final) {\r\n        const sourceTypeId = tag & COMPONENT_ID_MASK;\r\n        const sourceSeq = (tag >>> COMPONENT_ID_BITS) & FIELD_SEQ_MASK;\r\n        const internalIndex = tag >>> (COMPONENT_ID_BITS + FIELD_SEQ_BITS);\r\n        const sourceType = this.registry.types[sourceTypeId];\r\n        checkMask(sourceType, this.registry.executingSystem, 'write');\r\n        sourceType.__bind(sourceId, true);\r\n        sourceType.__binding.fields[sourceSeq].clearRef(final, this.targetEntityId, internalIndex);\r\n    }\r\n    trackReference(entityId, typeId, fieldSeq, internalIndex, trackChanges) {\r\n        if (this.clearing) {\r\n            throw new InternalError('Cannot track a new reference while clearing tracker');\r\n        }\r\n        if (trackChanges)\r\n            this.checkUpdateMask();\r\n        let index = this.getEntityIndex(entityId);\r\n        if (index === undefined)\r\n            index = this.addEntity(entityId, trackChanges);\r\n        this.addTag(index, this.makeTag(typeId, fieldSeq, internalIndex));\r\n    }\r\n    trackUnreference(entityId, typeId, fieldSeq, internalIndex, trackChanges) {\r\n        if (this.clearing)\r\n            return;\r\n        if (trackChanges)\r\n            this.checkUpdateMask();\r\n        const index = this.getEntityIndex(entityId);\r\n        if (index === undefined)\r\n            throw new InternalError('Entity backref not tracked');\r\n        const empty = this.removeTag(index, this.makeTag(typeId, fieldSeq, internalIndex));\r\n        if (empty)\r\n            this.removeEntity(index, entityId, trackChanges);\r\n    }\r\n    getEntityIndex(entityId) {\r\n        if (this.entityIndex)\r\n            return this.entityIndex[entityId];\r\n        const k = this.entities.findIndex(entity => entity.__id === entityId);\r\n        if (k >= 0)\r\n            return k;\r\n    }\r\n    indexEntities() {\r\n        if (this.entityIndex)\r\n            throw new InternalError('Entities already indexed');\r\n        this.entityIndex = new Array(this.dispatcher.maxEntities);\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            this.entityIndex[this.entities[i].__id] = i;\r\n        }\r\n    }\r\n    addTag(index, tag) {\r\n        if (!this.tags)\r\n            return;\r\n        const set = this.tags[index];\r\n        if (set === undefined) {\r\n            this.tags[index] = tag;\r\n        }\r\n        else if (typeof set === 'number') {\r\n            if (set === tag)\r\n                throw new InternalError(`Ref ${tag} already tracked (single)`);\r\n            this.tags[index] = [set, tag];\r\n        }\r\n        else if (Array.isArray(set)) {\r\n            if (set.includes(tag))\r\n                throw new InternalError(`Ref ${tag} already tracked (array)`);\r\n            if (set.length >= 1000) {\r\n                const actualSet = this.tags[index] = new Set(set);\r\n                actualSet.add(tag);\r\n            }\r\n            else {\r\n                set.push(tag);\r\n            }\r\n        }\r\n        else {\r\n            if (set.has(tag))\r\n                throw new InternalError(`Ref ${tag} already tracked (set)`);\r\n            set.add(tag);\r\n        }\r\n    }\r\n    removeTag(index, tag) {\r\n        if (!this.tags)\r\n            return true; // precise mode\r\n        const set = this.tags[index];\r\n        if (set === undefined)\r\n            throw new InternalError(`Ref ${tag} not tracked (none)`);\r\n        if (typeof set === 'number') {\r\n            if (set !== tag)\r\n                throw new InternalError(`Ref ${tag} not tracked (single ${set})`);\r\n            delete this.tags[index];\r\n            return true;\r\n        }\r\n        if (Array.isArray(set)) {\r\n            const k = set.indexOf(tag);\r\n            if (k === -1)\r\n                throw new InternalError(`Ref ${tag} not tracked (array ${set})`);\r\n            set.splice(k, 1);\r\n            return !this.tags.length;\r\n        }\r\n        if (!set.has(tag)) {\r\n            throw new InternalError(`Ref ${tag} not tracked (set ${new Array(...set)})`);\r\n        }\r\n        set.delete(tag);\r\n        return !set.size;\r\n    }\r\n    makeTag(typeId, fieldSeq, internalIndex) {\r\n        return typeId | (fieldSeq << COMPONENT_ID_BITS) |\r\n            (internalIndex === undefined ? 0 : (internalIndex << (COMPONENT_ID_BITS + FIELD_SEQ_BITS)));\r\n    }\r\n    addEntity(entityId, trackChanges) {\r\n        const index = this.entities.length;\r\n        this.entities.push(this.registry.pool.borrow(entityId));\r\n        if (this.entityIndex) {\r\n            this.entityIndex[entityId] = index;\r\n        }\r\n        else if (index > 100) {\r\n            this.indexEntities();\r\n        }\r\n        if (trackChanges)\r\n            this.trackBackrefsChange();\r\n        return index;\r\n    }\r\n    removeEntity(index, entityId, trackChanges) {\r\n        this.registry.pool.return(entityId);\r\n        const lastEntity = this.entities.pop();\r\n        if (this.entityIndex)\r\n            delete this.entityIndex[entityId];\r\n        if (this.entities.length > index) {\r\n            this.entities[index] = lastEntity;\r\n            if (this.entityIndex)\r\n                this.entityIndex[lastEntity.__id] = index;\r\n        }\r\n        if (this.tags) {\r\n            const lastTag = this.tags.pop();\r\n            if (this.tags.length > index)\r\n                this.tags[index] = lastTag;\r\n        }\r\n        if (trackChanges)\r\n            this.trackBackrefsChange();\r\n    }\r\n    trackBackrefsChange() {\r\n        for (const targetType of this.selector.targetTypes) {\r\n            if (targetType.__binding.trackedWrites) {\r\n                this.registry.trackWrite(this.targetEntityId, targetType);\r\n            }\r\n        }\r\n    }\r\n    checkUpdateMask() {\r\n        const system = this.registry.executingSystem;\r\n        for (const targetType of this.selector.targetTypes) {\r\n            if (this.registry.hasShape(this.targetEntityId, targetType, this.trackStale)) {\r\n                checkMask(targetType, system, 'update');\r\n            }\r\n        }\r\n    }\r\n}\r\nclass RefIndexer {\r\n    dispatcher;\r\n    maxRefChangesPerFrame;\r\n    refLog;\r\n    refLogPointer;\r\n    refLogStatsPointer;\r\n    selectorIdsBySourceKey = new Map();\r\n    selectors = [];\r\n    trackers = new Map();\r\n    registry;\r\n    constructor(dispatcher, maxRefChangesPerFrame) {\r\n        this.dispatcher = dispatcher;\r\n        this.maxRefChangesPerFrame = maxRefChangesPerFrame;\r\n        this.registry = dispatcher.registry;\r\n    }\r\n    completeCycle() {\r\n        this.flush(); // to handle ref changes coming from registry.processEndOfFrame()\r\n        this.dispatcher.stats.maxRefChangesPerFrame =\r\n            this.refLog?.countSince(this.refLogStatsPointer) ?? 0;\r\n    }\r\n    registerSelector(targetType, sourceType, sourceFieldSeq, trackStale = false) {\r\n        if (targetType)\r\n            checkTypeDefined(targetType);\r\n        if (sourceType)\r\n            checkTypeDefined(sourceType);\r\n        if (!this.refLog) {\r\n            this.refLog = new Log(this.maxRefChangesPerFrame, 'maxRefChangesPerFrame', this.dispatcher.buffers, { localProcessingAllowed: true });\r\n            this.refLogPointer = this.refLog.createPointer();\r\n            this.refLogStatsPointer = this.refLog.createPointer();\r\n        }\r\n        const selectorSourceKey = sourceType ?\r\n            (sourceFieldSeq === undefined ?\r\n                -2 - sourceType.id : sourceType.id | (sourceFieldSeq << COMPONENT_ID_BITS)) : -1;\r\n        let selectorId = this.selectorIdsBySourceKey.get(selectorSourceKey);\r\n        if (selectorId === undefined) {\r\n            // Always track stale refs on the global selector.\r\n            if (!this.selectors.length)\r\n                trackStale = true;\r\n            const selector = {\r\n                id: this.selectors.length, targetTypes: targetType ? [targetType] : [], sourceType,\r\n                matchType: !!sourceType, matchSeq: sourceFieldSeq !== undefined,\r\n                sourceTypeId: sourceType?.id, sourceSeq: sourceFieldSeq, trackStale\r\n            };\r\n            this.selectors.push(selector);\r\n            selectorId = selector.id;\r\n            this.selectorIdsBySourceKey.set(selectorSourceKey, selectorId);\r\n            if (selectorId > MAX_NUM_COMPONENTS) {\r\n                throw new CheckError(`Too many distinct backrefs selectors`);\r\n            }\r\n        }\r\n        else {\r\n            const selector = this.selectors[selectorId];\r\n            selector.trackStale = selector.trackStale || trackStale;\r\n            if (targetType)\r\n                selector.targetTypes.push(targetType);\r\n        }\r\n        return selectorId;\r\n    }\r\n    getBackrefs(entityId, selectorId = 0) {\r\n        const selector = this.selectors[selectorId];\r\n        return this.getOrCreateTracker(selector, entityId, this.registry.includeRecentlyDeleted).entities;\r\n    }\r\n    trackRefChange(sourceId, sourceType, sourceSeq, sourceInternalIndex, oldTargetId, newTargetId, unreference, release) {\r\n        if (!this.refLog)\r\n            throw new InternalError(`Trying to trackRefChange without a refLog`);\r\n        if (oldTargetId === newTargetId && unreference) {\r\n            throw new InternalError('No-op call to trackRefChange');\r\n        }\r\n        if (oldTargetId !== -1) {\r\n            const action = (unreference ? Action.UNREFERENCE : 0) | (release ? Action.RELEASE : 0);\r\n            if (!action) {\r\n                throw new InternalError('Called trackRefChange with neither unreference nor release');\r\n            }\r\n            this.pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, oldTargetId, action);\r\n        }\r\n        if (newTargetId !== -1) {\r\n            this.pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, newTargetId, Action.REFERENCE);\r\n        }\r\n    }\r\n    clearAllRefs(targetId, final) {\r\n        if (!this.selectors.length)\r\n            return;\r\n        this.getTracker(this.selectors[0], targetId, final)?.clearAllRefs(final);\r\n    }\r\n    pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, targetId, action) {\r\n        const internallyIndexed = typeof sourceInternalIndex !== 'undefined';\r\n        {\r\n            if (internallyIndexed && !sourceType.__binding.fields[sourceSeq].type.internallyIndexed) {\r\n                throw new InternalError('Inconsistent internally indexed flag');\r\n            }\r\n        }\r\n        this.refLog.push(sourceId | (sourceType.id << ENTITY_ID_BITS));\r\n        this.refLog.push(targetId | (sourceSeq << ENTITY_ID_BITS) | action | (internallyIndexed ? 2 ** 29 : 0));\r\n        if (internallyIndexed)\r\n            this.refLog.push(sourceInternalIndex);\r\n        this.processEntry(sourceId, sourceType.id, sourceSeq, sourceInternalIndex, targetId, action, true);\r\n    }\r\n    getOrCreateTracker(selector, targetId, stale) {\r\n        let tracker = this.getTracker(selector, targetId, stale);\r\n        if (tracker)\r\n            return tracker;\r\n        if (stale && !selector.trackStale) {\r\n            throw new InternalError('Selector not configured for stale tracking');\r\n        }\r\n        let staleTracker;\r\n        tracker = new Tracker(targetId, selector, false, this.dispatcher);\r\n        this.trackers.set(targetId | (selector.id << ENTITY_ID_BITS), tracker);\r\n        if (selector.trackStale) {\r\n            staleTracker = new Tracker(targetId, selector, true, this.dispatcher);\r\n            this.trackers.set(targetId | (selector.id << ENTITY_ID_BITS) | 2 ** 31, staleTracker);\r\n        }\r\n        return stale ? staleTracker : tracker;\r\n    }\r\n    getTracker(selector, targetId, stale) {\r\n        return this.trackers.get(targetId | (selector.id << ENTITY_ID_BITS) | (stale ? 2 ** 31 : 0));\r\n    }\r\n    flush() {\r\n        if (!this.refLog)\r\n            return;\r\n        while (true) {\r\n            const [log, startIndex, endIndex, local] = this.refLog.processAndCommitSince(this.refLogPointer);\r\n            if (!log)\r\n                break;\r\n            if (local)\r\n                continue;\r\n            for (let i = startIndex; i < endIndex; i += 2) {\r\n                const entryPart1 = log[i], entryPart2 = log[i + 1];\r\n                const sourceId = (entryPart1 & ENTITY_ID_MASK);\r\n                const sourceTypeId = entryPart1 >>> ENTITY_ID_BITS;\r\n                const targetId = (entryPart2 & ENTITY_ID_MASK);\r\n                const sourceSeq = (entryPart2 >>> ENTITY_ID_BITS) & (MAX_NUM_FIELDS - 1);\r\n                const action = entryPart2 & ACTION_MASK;\r\n                const internallyIndexed = (entryPart2 & 2 ** 29) !== 0;\r\n                const internalIndex = internallyIndexed ? log[i + 2] : undefined;\r\n                if (internallyIndexed)\r\n                    i += 1;\r\n                this.processEntry(sourceId, sourceTypeId, sourceSeq, internalIndex, targetId, action, false);\r\n            }\r\n        }\r\n    }\r\n    processEntry(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, targetId, action, local) {\r\n        for (let j = 0; j < this.selectors.length; j++) {\r\n            const selector = this.selectors[j];\r\n            if ((!selector.matchType || selector.sourceTypeId === sourceTypeId) &&\r\n                (!selector.matchSeq || selector.sourceSeq === sourceSeq)) {\r\n                if (action === Action.REFERENCE || action & Action.UNREFERENCE) {\r\n                    const tracker = this.getOrCreateTracker(selector, targetId, false);\r\n                    if (action === Action.REFERENCE) {\r\n                        tracker.trackReference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);\r\n                    }\r\n                    else {\r\n                        tracker.trackUnreference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);\r\n                    }\r\n                }\r\n                if (selector.trackStale && (action === Action.REFERENCE || action & Action.RELEASE)) {\r\n                    const tracker = this.getOrCreateTracker(selector, targetId, true);\r\n                    if (action === Action.REFERENCE) {\r\n                        tracker.trackReference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);\r\n                    }\r\n                    else {\r\n                        tracker.trackUnreference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n\nclass Item {\r\n    buffer;\r\n    array;\r\n    update;\r\n}\r\nconst arrayTypeToKind = new Map([\r\n    [Uint8Array, 'u8'], [Int8Array, 'i8'], [Uint16Array, 'u16'], [Int16Array, 'i16'],\r\n    [Uint32Array, 'u32'], [Int32Array, 'i32'], [Float32Array, 'f32'], [Float64Array, 'f64']\r\n]);\r\nconst arrayKindToType = new Map([\r\n    ['u8', Uint8Array], ['i8', Int8Array], ['u16', Uint16Array], ['i16', Int16Array],\r\n    ['u32', Uint32Array], ['i32', Int32Array], ['f32', Float32Array], ['f64', Float64Array]\r\n]);\r\nclass Buffers {\r\n    threaded;\r\n    items = new Map();\r\n    changes;\r\n    constructor(threaded) {\r\n        this.threaded = threaded;\r\n    }\r\n    register(key, length, ArrayType, update, filler) {\r\n        const size = length * ArrayType.BYTES_PER_ELEMENT;\r\n        let item = this.items.get(key);\r\n        const needBiggerBuffer = !item || item.buffer.byteLength < size;\r\n        const needNewArray = needBiggerBuffer || item.array.constructor !== ArrayType;\r\n        if (!item || needBiggerBuffer || needNewArray) {\r\n            const newItem = new Item();\r\n            newItem.buffer = needBiggerBuffer ?\r\n                (this.threaded ? new SharedArrayBuffer(size) : new ArrayBuffer(size)) : item.buffer;\r\n            newItem.array = new ArrayType(newItem.buffer);\r\n            if (item) {\r\n                newItem.array.set(item.array);\r\n                if (filler !== undefined && newItem.array.length > item.array.length) {\r\n                    newItem.array.fill(filler, item.array.length);\r\n                }\r\n            }\r\n            else if (filler !== undefined) {\r\n                newItem.array.fill(filler);\r\n            }\r\n            item = newItem;\r\n            this.items.set(key, item);\r\n            if (this.threaded) {\r\n                if (!this.changes)\r\n                    this.changes = new Map();\r\n                this.changes.set(key, {\r\n                    buffer: item.buffer, arrayKind: arrayTypeToKind.get(ArrayType)\r\n                });\r\n            }\r\n            update?.(item.array);\r\n        }\r\n        item.update = update;\r\n        return item.array;\r\n    }\r\n    makePatch() {\r\n        if (!this.changes)\r\n            return;\r\n        const patch = this.changes;\r\n        this.changes = undefined;\r\n        return patch;\r\n    }\r\n    applyPatch(patch) {\r\n        for (const [key, patchItem] of patch.entries()) {\r\n            const item = new Item();\r\n            item.update = this.items.get(key)?.update;\r\n            item.buffer = patchItem.buffer;\r\n            const ArrayType = arrayKindToType.get(patchItem.arrayKind);\r\n            item.array = new ArrayType(item.buffer);\r\n            this.items.set(key, item);\r\n            item.update?.(item.array);\r\n        }\r\n    }\r\n}\n\nfunction addFieldSchema(options, target, name) {\r\n    if (!target.constructor.schema)\r\n        target.constructor.schema = {};\r\n    target.constructor.schema[name] = options;\r\n}\r\nfunction field(practicalOptions) {\r\n    return function (target, name) {\r\n        const options = 'type' in practicalOptions ? practicalOptions : { type: practicalOptions };\r\n        addFieldSchema(options, target, name);\r\n    };\r\n}\r\nfunction makeVectorDecorator(type) {\r\n    const fn = addFieldSchema.bind(null, { type });\r\n    fn.vector =\r\n        (elements, Class) => (target, name) => {\r\n            addFieldSchema({ type: Type.vector(type, elements, Class) }, target, name);\r\n        };\r\n    return fn;\r\n}\r\nfunction backrefs(...args) {\r\n    if (typeof args[0] === 'function' || args[0] === undefined) {\r\n        return addFieldSchema.bind(null, { type: Type.backrefs(...args) });\r\n    }\r\n    addFieldSchema({ type: Type.backrefs }, args[0], args[1]);\r\n}\r\nfield.boolean = addFieldSchema.bind(null, { type: Type.boolean });\r\nfield.uint8 = makeVectorDecorator(Type.uint8);\r\nfield.int8 = makeVectorDecorator(Type.int8);\r\nfield.uint16 = makeVectorDecorator(Type.uint16);\r\nfield.int16 = makeVectorDecorator(Type.int16);\r\nfield.uint32 = makeVectorDecorator(Type.uint32);\r\nfield.int32 = makeVectorDecorator(Type.int32);\r\nfield.float32 = makeVectorDecorator(Type.float32);\r\nfield.float64 = makeVectorDecorator(Type.float64);\r\nfield.staticString = function (choices) {\r\n    return addFieldSchema.bind(null, { type: Type.staticString(choices) });\r\n};\r\nfield.dynamicString = function (maxUtf8Length) {\r\n    return addFieldSchema.bind(null, { type: Type.dynamicString(maxUtf8Length) });\r\n};\r\nfield.ref = addFieldSchema.bind(null, { type: Type.ref });\r\nfield.backrefs = backrefs;\r\nfield.object = addFieldSchema.bind(null, { type: Type.object });\r\nfield.weakObject = addFieldSchema.bind(null, { type: Type.weakObject });\r\nconst componentTypes = [];\r\nfunction component(arg, options) {\r\n    if (typeof arg === 'function') {\r\n        componentTypes.push(arg);\r\n    }\r\n    else if (arg instanceof ComponentEnum) {\r\n        return (componentClass) => {\r\n            if (!arg.__types.includes(componentClass))\r\n                arg.__types.push(componentClass);\r\n            componentTypes.push(arg); // duplicates will be removed by Dispatcher\r\n            if (options)\r\n                componentClass.options = options;\r\n        };\r\n    }\r\n    else {\r\n        return (componentClass) => {\r\n            componentClass.options = arg;\r\n            componentTypes.push(componentClass);\r\n        };\r\n    }\r\n}\r\nconst systemTypes = [];\r\nfunction system(arg, scheduler) {\r\n    if (typeof arg === 'function' && !arg.__system) {\r\n        scheduler = arg;\r\n        arg = undefined;\r\n    }\r\n    if (typeof arg === 'function') {\r\n        systemTypes.push(arg);\r\n    }\r\n    else {\r\n        if (arg && !systemTypes.includes(arg))\r\n            systemTypes.push(arg);\r\n        return (systemClass) => {\r\n            if (arg)\r\n                arg.__contents.push(systemClass);\r\n            if (scheduler)\r\n                systemClass.__staticScheduler = scheduler;\r\n            systemTypes.push(systemClass);\r\n        };\r\n    }\r\n}\n\n/**\r\n * A directed graph with weighted edges and a few extra constraints:\r\n * 1. Loop edges on a single vertex are not allowed, nor are multiple edges from A to B.\r\n * 2. An edge from A to B with a higher weight will override an edge from B to A.\r\n * 3. A \"denial\" edge from A to B will similarly override lower-weight edges, but not count as an\r\n *    edge itself.  We store these with negative weights.\r\n */\r\nclass Graph {\r\n    vertices;\r\n    numVertices;\r\n    edges;\r\n    paths;\r\n    vertexIndexMap = new Map();\r\n    sealed = false;\r\n    sortedVertices;\r\n    dependencyCounts;\r\n    traversalCounts;\r\n    numTraversedVertices;\r\n    constructor(vertices) {\r\n        this.vertices = vertices;\r\n        this.numVertices = vertices.length;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            this.vertexIndexMap.set(vertices[i], i);\r\n        }\r\n        this.edges = new Array(this.numVertices ** 2).fill(0);\r\n        this.dependencyCounts = new Array(this.numVertices);\r\n        this.traversalCounts = new Array(this.numVertices);\r\n    }\r\n    get topologicallySortedVertices() {\r\n        if (!this.sealed)\r\n            throw new InternalError('Graph not yet sealed');\r\n        if (!this.sortedVertices)\r\n            this.sortedVertices = this.sortTopologically();\r\n        return this.sortedVertices;\r\n    }\r\n    getEdgeIndex(source, target) {\r\n        const sourceId = this.vertexIndexMap.get(source);\r\n        const targetId = this.vertexIndexMap.get(target);\r\n        if (sourceId === undefined)\r\n            throw new InternalError(`Unknown vertex: ${source}`);\r\n        if (targetId === undefined)\r\n            throw new InternalError(`Unknown vertex: ${target}`);\r\n        return sourceId * this.numVertices + targetId;\r\n    }\r\n    setEdge(source, target, weight) {\r\n        if (this.sealed)\r\n            throw new InternalError('Graph already sealed');\r\n        if (source === target)\r\n            return;\r\n        const sourceToTarget = this.getEdgeIndex(source, target);\r\n        const targetToSource = this.getEdgeIndex(target, source);\r\n        const absWeight = Math.abs(weight);\r\n        if (absWeight < Math.abs(this.edges[sourceToTarget]) ||\r\n            absWeight < Math.abs(this.edges[targetToSource]))\r\n            return;\r\n        this.edges[sourceToTarget] = weight;\r\n        if (absWeight > Math.abs(this.edges[targetToSource]))\r\n            this.edges[targetToSource] = 0;\r\n    }\r\n    addEdge(source, target, weight) {\r\n        if (weight <= 0)\r\n            throw new InternalError(`Edge has non-positive weight: ${weight}`);\r\n        this.setEdge(source, target, weight);\r\n    }\r\n    denyEdge(source, target, weight) {\r\n        if (weight <= 0)\r\n            throw new InternalError(`Edge has non-positive weight: ${weight}`);\r\n        this.setEdge(source, target, -weight);\r\n    }\r\n    hasEdge(source, target) {\r\n        return this.edges[this.getEdgeIndex(source, target)] > 0;\r\n    }\r\n    hasPath(source, target) {\r\n        if (!this.sealed)\r\n            throw new InternalError('Graph not yet sealed');\r\n        return this.paths[this.getEdgeIndex(source, target)] > 0;\r\n    }\r\n    hasEdgeBetweenIds(sourceId, targetId) {\r\n        if (sourceId > this.numVertices) {\r\n            throw new InternalError(`Vertex id out of range: ${sourceId} > ${this.numVertices}`);\r\n        }\r\n        if (targetId > this.numVertices) {\r\n            throw new InternalError(`Vertex id out of range: ${targetId} > ${this.numVertices}`);\r\n        }\r\n        return this.edges[sourceId * this.numVertices + targetId] > 0;\r\n    }\r\n    seal() {\r\n        if (this.sealed)\r\n            throw new InternalError('Graph already sealed');\r\n        this.sealed = true;\r\n        this.derivePaths();\r\n        this.checkForCycles();\r\n        this.simplify();\r\n        this.countDependencies();\r\n    }\r\n    checkForCycles() {\r\n        const cycles = this.findCycles();\r\n        if (cycles.length) {\r\n            cycles.sort((x, y) => x.length - y.length);\r\n            throw new CheckError('Precedence cycles detected for the following systems, ' +\r\n                'please resolve by adjusting their schedules: ' +\r\n                cycles.map(cycle => cycle.map(u => u.toString()).join('—')).join(', '));\r\n        }\r\n    }\r\n    findCycles() {\r\n        // This implements Johnson's cycle finding algorithm from\r\n        // https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\r\n        const blocked = new Array(this.numVertices).fill(false), b = [];\r\n        const stack = [], cycles = [];\r\n        let s, vertices;\r\n        for (let i = 0; i < this.numVertices; i++)\r\n            b[i] = new Set();\r\n        const unblock = (u) => {\r\n            blocked[u] = false;\r\n            for (const w of b[u]) {\r\n                b[u].delete(w);\r\n                if (blocked[w])\r\n                    unblock(w);\r\n            }\r\n        };\r\n        const circuit = (v) => {\r\n            let f = false;\r\n            stack.push(v);\r\n            blocked[v] = true;\r\n            for (let w = 0; w < this.numVertices; w++) {\r\n                if (!vertices.has(w) || !this.hasEdgeBetweenIds(v, w))\r\n                    continue;\r\n                if (w === s) {\r\n                    cycles.push(stack.map(u => this.vertices[u]));\r\n                    f = true;\r\n                }\r\n                else if (!blocked[w] && circuit(w)) {\r\n                    f = true;\r\n                }\r\n            }\r\n            if (f) {\r\n                unblock(v);\r\n            }\r\n            else {\r\n                for (let w = 0; w < this.numVertices; w++) {\r\n                    if (!vertices.has(w) || !this.hasEdgeBetweenIds(v, w))\r\n                        continue;\r\n                    b[w].add(v);\r\n                }\r\n            }\r\n            stack.pop();\r\n            return f;\r\n        };\r\n        for (s = 0; s < this.numVertices; s++) {\r\n            const componentVertices = this.findLeastStronglyConnectedComponent(s);\r\n            s = componentVertices[0];\r\n            for (const v of componentVertices) {\r\n                blocked[v] = false;\r\n                b[v].clear();\r\n            }\r\n            vertices = new Set(componentVertices);\r\n            circuit(s);\r\n        }\r\n        return cycles;\r\n    }\r\n    findLeastStronglyConnectedComponent(minId) {\r\n        // Implements the path-based strong component algorithm on the subgraph consisting of vertices\r\n        // minId through numVertices - 1.\r\n        // https://en.wikipedia.org/wiki/Path-based_strong_component_algorithm\r\n        let leastComponent;\r\n        const preorder = [], s = [], p = [];\r\n        const assigned = [];\r\n        let counter = 0;\r\n        const search = (v) => {\r\n            preorder[v] = ++counter;\r\n            s.push(v);\r\n            p.push(v);\r\n            for (let w = minId; w < this.numVertices; w++) {\r\n                if (!this.hasEdgeBetweenIds(v, w))\r\n                    continue;\r\n                if (preorder[w]) {\r\n                    if (!assigned[w]) {\r\n                        while (p.length && preorder[p[p.length - 1]] > preorder[w])\r\n                            p.pop();\r\n                    }\r\n                }\r\n                else {\r\n                    search(w);\r\n                }\r\n            }\r\n            if (p[p.length - 1] === v) {\r\n                const component = [];\r\n                while (true) {\r\n                    const w = s.pop();\r\n                    component.push(w);\r\n                    assigned[w] = true;\r\n                    if (w === v)\r\n                        break;\r\n                }\r\n                p.pop();\r\n                component.sort((a, b) => a - b);\r\n                if (!leastComponent || component[0] < leastComponent[0])\r\n                    leastComponent = component;\r\n            }\r\n        };\r\n        for (let i = minId; i < this.numVertices; i++) {\r\n            if (!preorder[i])\r\n                search(i);\r\n        }\r\n        return leastComponent;\r\n    }\r\n    induceSubgraph(subvertices) {\r\n        const subgraph = new Graph(subvertices);\r\n        for (const vertex of subvertices) {\r\n            if (!this.vertexIndexMap.has(vertex)) {\r\n                throw new InternalError(`Vertex not in graph: ${vertex}`);\r\n            }\r\n            for (const target of subvertices) {\r\n                const edgeIndex = this.getEdgeIndex(vertex, target);\r\n                const weight = this.edges[edgeIndex];\r\n                if (weight > 0) {\r\n                    subgraph.addEdge(vertex, target, weight);\r\n                }\r\n                else if (weight < 0) {\r\n                    subgraph.denyEdge(vertex, target, -weight);\r\n                }\r\n            }\r\n        }\r\n        if (this.sealed)\r\n            subgraph.seal();\r\n        return subgraph;\r\n    }\r\n    sortTopologically() {\r\n        const edgeCounts = new Array(this.numVertices).fill(0);\r\n        for (let i = 0; i < this.numVertices; i++) {\r\n            for (let j = 0; j < this.numVertices; j++) {\r\n                if (this.hasEdgeBetweenIds(i, j))\r\n                    edgeCounts[j] += 1;\r\n            }\r\n        }\r\n        const vertices = [];\r\n        let changed;\r\n        while (vertices.length < this.numVertices) {\r\n            changed = false;\r\n            for (let i = 0; i < edgeCounts.length; i++) {\r\n                if (edgeCounts[i] === 0) {\r\n                    changed = true;\r\n                    edgeCounts[i] = -1;\r\n                    vertices.push(this.vertices[i]);\r\n                    for (let j = 0; j < this.numVertices; j++) {\r\n                        if (this.hasEdgeBetweenIds(i, j))\r\n                            edgeCounts[j] -= 1;\r\n                    }\r\n                }\r\n            }\r\n            if (!changed) {\r\n                throw new InternalError('Graph has a cycle, topological sort not possible');\r\n            }\r\n        }\r\n        return vertices;\r\n    }\r\n    derivePaths() {\r\n        const n = this.numVertices;\r\n        // Remove denial edges, no longer needed\r\n        for (let i = 0; i < this.edges.length; i++) {\r\n            if (this.edges[i] < 0)\r\n                this.edges[i] = 0;\r\n        }\r\n        // console.log(this.printMatrix(this.edges));\r\n        // Derive path matrix using a variant of the Floyd-Warshall algorithm\r\n        const paths = this.edges.slice();\r\n        for (let i = 0; i < n; i++) {\r\n            for (let j = 0; j < n; j++) {\r\n                if (i === j)\r\n                    continue;\r\n                for (let k = 0; k < n; k++) {\r\n                    if (k === i || k === j)\r\n                        continue;\r\n                    const weight1 = paths[i * n + k];\r\n                    const weight2 = paths[k * n + j];\r\n                    if (weight1 && weight2) {\r\n                        const weight = Math.min(weight1, weight2);\r\n                        if (paths[i * n + j] < weight && paths[j * n + i] < weight) {\r\n                            paths[i * n + j] = weight;\r\n                            paths[j * n + i] = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.paths = paths;\r\n        // console.log(this.printMatrix(paths));\r\n        // Overwrite edge weights with stronger paths.\r\n        for (let i = 0; i < n; i++) {\r\n            for (let j = 0; j < n; j++) {\r\n                if (this.edges[i * n + j])\r\n                    this.edges[i * n + j] = paths[i * n + j];\r\n            }\r\n        }\r\n    }\r\n    simplify() {\r\n        const n = this.numVertices;\r\n        const paths = this.paths;\r\n        // Perform a transitive reduction\r\n        for (let i = 0; i < n; i++) {\r\n            for (let j = 0; j < n; j++) {\r\n                if (!this.edges[i * n + j])\r\n                    continue;\r\n                for (let k = 0; k < n; k++) {\r\n                    if (k === i || k === j)\r\n                        continue;\r\n                    if (paths[i * n + k] && paths[k * n + j])\r\n                        this.edges[i * n + j] = 0;\r\n                }\r\n            }\r\n        }\r\n        // console.log(this.printMatrix(this.edges));\r\n    }\r\n    countDependencies() {\r\n        for (let i = 0; i < this.numVertices; i++) {\r\n            let count = 0;\r\n            for (let j = 0; j < this.numVertices; j++) {\r\n                if (this.edges[j * this.numVertices + i])\r\n                    count += 1;\r\n            }\r\n            this.dependencyCounts[i] = count;\r\n        }\r\n    }\r\n    /**\r\n     * Traverses vertices of the graph based on dependency order.  When called without an argument it\r\n     * initializes (or re-initializes) the traversal and returns vertices with no dependencies.  When\r\n     * called with an argument, it marks that vertex as done and returns the vertices whose\r\n     * dependencies are all satisfied (if any).\r\n     * @param completedVertex The vertex to mark done; if missing, initializes the traversal instead.\r\n     * @returns The list of vertices whose dependencies have all been satisfied, or `undefined` if\r\n     *    this was the last vertex and the traversal is done.\r\n     */\r\n    traverse(completedVertex) {\r\n        if (!this.sealed)\r\n            throw new InternalError('Graph not yet sealed');\r\n        const traversedVertices = [];\r\n        if (completedVertex) {\r\n            this.numTraversedVertices += 1;\r\n            const sourceId = this.vertexIndexMap.get(completedVertex);\r\n            if (sourceId === undefined) {\r\n                throw new InternalError(`Unknown vertex: ${completedVertex}`);\r\n            }\r\n            for (let i = 0; i < this.numVertices; i++) {\r\n                if (this.edges[sourceId * this.numVertices + i]) {\r\n                    if (--this.traversalCounts[i] === 0) {\r\n                        traversedVertices.push(this.vertices[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.numTraversedVertices = 0;\r\n            for (let i = 0; i < this.numVertices; i++) {\r\n                const count = this.traversalCounts[i] = this.dependencyCounts[i];\r\n                if (count === 0) {\r\n                    traversedVertices.push(this.vertices[i]);\r\n                }\r\n            }\r\n        }\r\n        if (this.numTraversedVertices === this.numVertices)\r\n            return;\r\n        return traversedVertices;\r\n    }\r\n    printMatrix(matrix) {\r\n        const n = this.numVertices;\r\n        const lines = [];\r\n        for (let i = 0; i < n; i++) {\r\n            const line = [];\r\n            for (let j = 0; j < n; j++)\r\n                line.push(matrix[i * n + j]);\r\n            lines.push(line.join(' '));\r\n        }\r\n        return lines.join('\\n');\r\n    }\r\n}\n\nclass Plan {\r\n    planner;\r\n    group;\r\n    graph;\r\n    constructor(planner, group) {\r\n        this.planner = planner;\r\n        this.group = group;\r\n        this.graph = planner.graph.induceSubgraph(group.__systems);\r\n    }\r\n}\r\nclass SimplePlan extends Plan {\r\n    planner;\r\n    group;\r\n    systems;\r\n    constructor(planner, group) {\r\n        super(planner, group);\r\n        this.planner = planner;\r\n        this.group = group;\r\n        this.systems = this.graph.topologicallySortedVertices;\r\n        if (this.systems.length > 1 && (typeof process === 'undefined' || process.env.NODE_ENV === 'development')) {\r\n            console.log('System execution order:');\r\n            for (const system of this.systems)\r\n                console.log(' ', system.name);\r\n        }\r\n    }\r\n    execute(time, delta) {\r\n        const dispatcher = this.planner.dispatcher;\r\n        const systems = this.systems;\r\n        this.group.__executed = true;\r\n        for (let i = 0; i < systems.length; i++) {\r\n            const system = systems[i];\r\n            system.execute(time, delta);\r\n            dispatcher.flush();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    async initialize() {\r\n        const dispatcher = this.planner.dispatcher;\r\n        this.group.__executed = true;\r\n        return new Promise((resolve, reject) => {\r\n            let rejected = false;\r\n            const initSystem = async (system) => {\r\n                try {\r\n                    await system.prepare();\r\n                    if (rejected)\r\n                        return;\r\n                    system.initialize();\r\n                    dispatcher.flush();\r\n                    const systems = this.graph.traverse(system);\r\n                    if (!systems)\r\n                        return resolve();\r\n                    for (let i = 0; i < systems.length; i++)\r\n                        initSystem(systems[i]);\r\n                }\r\n                catch (e) {\r\n                    rejected = true;\r\n                    reject(e);\r\n                }\r\n            };\r\n            const systems = this.graph.traverse();\r\n            if (!systems)\r\n                return resolve();\r\n            for (let i = 0; i < systems.length; i++)\r\n                initSystem(systems[i]);\r\n        });\r\n    }\r\n    async finalize() {\r\n        const dispatcher = this.planner.dispatcher;\r\n        this.group.__executed = true;\r\n        return new Promise((resolve, reject) => {\r\n            const finalizeSystem = (system) => {\r\n                try {\r\n                    system.finalize();\r\n                    dispatcher.flush();\r\n                    const systems = this.graph.traverse(system);\r\n                    if (!systems)\r\n                        return resolve();\r\n                    for (let i = 0; i < systems.length; i++)\r\n                        finalizeSystem(systems[i]);\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            };\r\n            const systems = this.graph.traverse();\r\n            if (!systems)\r\n                return resolve();\r\n            for (let i = 0; i < systems.length; i++)\r\n                finalizeSystem(systems[i]);\r\n        });\r\n    }\r\n}\r\nclass ThreadedPlan extends Plan {\r\n    execute(time, delta) {\r\n        return Promise.resolve();\r\n    }\r\n    initialize() {\r\n        return Promise.resolve();\r\n    }\r\n    finalize() {\r\n        return Promise.resolve();\r\n    }\r\n}\r\nclass Lane {\r\n    id;\r\n    systems = [];\r\n    constructor(id) {\r\n        this.id = id;\r\n    }\r\n    add(...systems) {\r\n        for (const system of systems)\r\n            system.lane = this;\r\n        this.systems.push(...systems);\r\n    }\r\n    merge(other) {\r\n        if (this === other)\r\n            return this;\r\n        if (this.id === -1 || (other.id !== -1 && other.id < this.id))\r\n            return other.merge(this);\r\n        this.add(...other.systems);\r\n        other.systems.length = 0;\r\n        return this;\r\n    }\r\n}\r\nclass Planner {\r\n    dispatcher;\r\n    systems;\r\n    groups;\r\n    graph;\r\n    readers = new Map();\r\n    writers = new Map();\r\n    lanes = [];\r\n    replicatedLane;\r\n    laneCount = 0;\r\n    constructor(dispatcher, systems, groups) {\r\n        this.dispatcher = dispatcher;\r\n        this.systems = systems;\r\n        this.groups = groups;\r\n        this.graph = new Graph(systems);\r\n        for (const componentType of dispatcher.registry.types) {\r\n            this.readers.set(componentType, new Set());\r\n            this.writers.set(componentType, new Set());\r\n        }\r\n        if (dispatcher.threaded) {\r\n            this.createLane();\r\n            // special lane id, and don't keep this in the lanes array\r\n            this.replicatedLane = new Lane(-1);\r\n        }\r\n    }\r\n    get mainLane() {\r\n        return this.lanes[0];\r\n    }\r\n    createLane() {\r\n        const lane = new Lane(this.laneCount++);\r\n        this.lanes.push(lane);\r\n        return lane;\r\n    }\r\n    organize() {\r\n        for (const group of this.groups)\r\n            group.__collectSystems(this.dispatcher);\r\n        for (const system of this.systems)\r\n            system.buildQueries();\r\n        for (const system of this.systems)\r\n            system.buildSchedule();\r\n        for (const group of this.groups)\r\n            group.__buildSchedule();\r\n        this.addComponentEntitlementDependencies();\r\n        this.graph.seal();\r\n        if (this.dispatcher.threaded)\r\n            this.assignSystemsToLanes();\r\n        for (const system of this.systems)\r\n            system.stats.worker = system.lane?.id ?? 0;\r\n        delete this.readers;\r\n        delete this.writers;\r\n        for (const group of this.groups) {\r\n            group.__plan =\r\n                this.dispatcher.threaded ? new ThreadedPlan(this, group) : new SimplePlan(this, group);\r\n        }\r\n    }\r\n    addComponentEntitlementDependencies() {\r\n        for (const [componentType, systems] of this.readers.entries()) {\r\n            for (const reader of systems) {\r\n                for (const writer of this.writers.get(componentType)) {\r\n                    this.graph.addEdge(writer, reader, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    assignSystemsToLanes() {\r\n        this.initSystemLanes();\r\n        this.mergeAccessorsOfUnsharedComponentTypes();\r\n        this.mergeAttachedSystems();\r\n        this.pruneEmptyLanes();\r\n        this.reduceLanes(this.dispatcher.threads + 1);\r\n        this.pruneEmptyLanes();\r\n    }\r\n    initSystemLanes() {\r\n        for (const system of this.systems) {\r\n            if (!system.lane)\r\n                this.createLane().add(system);\r\n        }\r\n    }\r\n    mergeAccessorsOfUnsharedComponentTypes() {\r\n        for (const componentType of this.dispatcher.registry.types) {\r\n            if (componentType.__binding.fields.every(field => field.type.shared))\r\n                continue;\r\n            const readers = this.readers.get(componentType);\r\n            const writers = this.writers.get(componentType);\r\n            if (!readers && !writers)\r\n                continue;\r\n            let lane = componentType.options?.restrictedToMainThread ? this.mainLane : this.createLane();\r\n            readers?.forEach(system => {\r\n                lane = lane.merge(system.lane);\r\n            });\r\n            writers?.forEach(system => {\r\n                lane = lane.merge(system.lane);\r\n            });\r\n        }\r\n    }\r\n    mergeAttachedSystems() {\r\n        for (const system of this.systems) {\r\n            for (const attachedSystem of system.attachedSystems) {\r\n                if (!attachedSystem)\r\n                    continue;\r\n                system.lane.merge(attachedSystem.lane);\r\n            }\r\n        }\r\n    }\r\n    reduceLanes(maxNumLanes) {\r\n        if (this.lanes.length <= maxNumLanes)\r\n            return;\r\n        let pairs = [];\r\n        for (let i = 1; i < this.lanes.length - 1; i++) { // don't merge into lane 0 unless necessary\r\n            const laneA = this.lanes[i];\r\n            for (let j = i + 1; j < this.lanes.length; j++) {\r\n                const laneB = this.lanes[j];\r\n                pairs.push({ laneA, laneB, independence: this.computeIndependence(laneA, laneB) });\r\n            }\r\n        }\r\n        let numLanes = this.lanes.length;\r\n        while (numLanes > maxNumLanes) {\r\n            pairs.sort((pair1, pair2) => pair2.independence - pair1.independence);\r\n            const tangledPair = pairs.pop();\r\n            const combinedLane = tangledPair.laneA.merge(tangledPair.laneB);\r\n            const discardedLane = combinedLane === tangledPair.laneA ? tangledPair.laneB : tangledPair.laneA;\r\n            numLanes -= 1;\r\n            if (numLanes > maxNumLanes) {\r\n                pairs = pairs.filter(pair => {\r\n                    if (pair.laneA === discardedLane || pair.laneB === discardedLane)\r\n                        return false;\r\n                    if (pair.laneA === combinedLane || pair.laneB === combinedLane) {\r\n                        pair.independence = this.computeIndependence(pair.laneA, pair.laneB);\r\n                    }\r\n                    return true;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    computeIndependence(laneA, laneB) {\r\n        return Math.min(this.computeIndependentWeight(laneA, laneB), this.computeIndependentWeight(laneB, laneA));\r\n    }\r\n    computeIndependentWeight(lane, otherLane) {\r\n        let independentWeight = 0;\r\n        for (const system of lane.systems) {\r\n            let otherWeight = 0;\r\n            for (const otherSystem of otherLane.systems) {\r\n                if (!this.graph.hasPath(system, otherSystem) && !this.graph.hasPath(otherSystem, system)) {\r\n                    otherWeight += otherSystem.weight;\r\n                }\r\n            }\r\n            independentWeight += Math.min(system.weight, otherWeight);\r\n        }\r\n        return independentWeight;\r\n    }\r\n    pruneEmptyLanes() {\r\n        this.lanes = this.lanes.filter(lane => lane.id === 0 || lane.systems.length);\r\n        // Never prune the main thread lane.\r\n        for (let i = 1; i < this.lanes.length; i++) {\r\n            this.lanes[i].id = i;\r\n        }\r\n    }\r\n}\n\nclass Build extends System {\r\n    static __internal = true;\r\n    __callback;\r\n    start(coroutineFn, ...args) {\r\n        throw new CheckError('The build system cannot run coroutines');\r\n    }\r\n    execute() {\r\n        this.__callback(this);\r\n    }\r\n}\r\nclass Validate extends System {\r\n    static __internal = true;\r\n}\r\nvar State;\r\n(function (State) {\r\n    State[State[\"init\"] = 0] = \"init\";\r\n    State[State[\"setup\"] = 1] = \"setup\";\r\n    State[State[\"run\"] = 2] = \"run\";\r\n    State[State[\"finish\"] = 3] = \"finish\";\r\n    State[State[\"done\"] = 4] = \"done\";\r\n})(State || (State = {}));\r\nclass Dispatcher {\r\n    maxEntities;\r\n    defaultComponentStorage;\r\n    registry;\r\n    systems;\r\n    systemsByClass = new Map();\r\n    systemGroups;\r\n    default;\r\n    lastTime;\r\n    executing;\r\n    executingSyncFrame;\r\n    state = State.init;\r\n    shapeLog;\r\n    writeLog;\r\n    shapeLogFramePointer;\r\n    writeLogFramePointer;\r\n    stats;\r\n    indexer;\r\n    planner;\r\n    threads;\r\n    buffers;\r\n    singleton;\r\n    buildSystem;\r\n    deferredControls = new Map();\r\n    constructor({ defs, threads = 1, maxEntities = 10000, maxLimboComponents = Math.ceil(maxEntities / 5), maxShapeChangesPerFrame = maxEntities * 2, maxWritesPerFrame = maxEntities * 4, maxRefChangesPerFrame = maxEntities, defaultComponentStorage = 'packed' }) {\r\n        if (threads < 1)\r\n            throw new CheckError('Minimum of one thread');\r\n        if (threads > 1)\r\n            throw new CheckError('Multithreading not yet implemented');\r\n        if (maxEntities > MAX_NUM_ENTITIES) {\r\n            throw new CheckError(`maxEntities too high, the limit is ${MAX_NUM_ENTITIES}`);\r\n        }\r\n        const { componentTypes: componentTypes$1, componentEnums, systemTypes: systemTypes$1, systemGroups } = this.splitDefs([defs ?? [], componentTypes, systemTypes]);\r\n        if (componentTypes$1.length > MAX_NUM_COMPONENTS) {\r\n            throw new CheckError(`Too many component types, the limit is ${MAX_NUM_COMPONENTS}`);\r\n        }\r\n        this.stats = new Stats();\r\n        this.threads = threads;\r\n        this.buffers = new Buffers(threads > 1);\r\n        this.maxEntities = maxEntities;\r\n        this.defaultComponentStorage = defaultComponentStorage;\r\n        this.registry =\r\n            new Registry(maxEntities, maxLimboComponents, componentTypes$1, componentEnums, this);\r\n        this.indexer = new RefIndexer(this, maxRefChangesPerFrame);\r\n        this.shapeLog = new Log(maxShapeChangesPerFrame, 'maxShapeChangesPerFrame', this.buffers, { sortedByComponentType: true, numComponentTypes: this.registry.types.length });\r\n        this.shapeLogFramePointer = this.shapeLog.createPointer();\r\n        this.systemGroups = systemGroups;\r\n        this.systems = this.createSystems(systemTypes$1);\r\n        this.createBuildSystem();\r\n        this.registry.initializeComponentTypes();\r\n        this.registry.validateSystem = this.createValidateSystem(componentTypes$1);\r\n        this.singleton = this.createSingletons();\r\n        for (const box of this.systems)\r\n            box.replacePlaceholders();\r\n        this.planner = new Planner(this, this.systems, this.systemGroups);\r\n        this.planner.organize();\r\n        this.registry.hasNegativeQueries = this.systems.some(system => system.hasNegativeQueries);\r\n        if (this.systems.some(system => system.hasWriteQueries)) {\r\n            this.writeLog = new Log(maxWritesPerFrame, 'maxWritesPerFrame', this.buffers, { sortedByComponentType: true, numComponentTypes: this.registry.types.length });\r\n            this.writeLogFramePointer = this.writeLog.createPointer();\r\n        }\r\n        for (const box of this.systems)\r\n            box.finishConstructing();\r\n        this.state = State.setup;\r\n    }\r\n    get threaded() { return this.threads > 1; }\r\n    get defaultGroup() { return this.default.group; }\r\n    createSystems(systemTypes) {\r\n        const systems = [];\r\n        const systemClasses = [];\r\n        const typeNames = new Set();\r\n        let anonymousTypeCounter = 0;\r\n        for (let i = 0; i < systemTypes.length; i++) {\r\n            const SystemClass = systemTypes[i];\r\n            let box = this.systemsByClass.get(SystemClass);\r\n            if (!box) {\r\n                if (!SystemClass.name) {\r\n                    Object.defineProperty(SystemClass, 'name', { value: `Anonymous_${anonymousTypeCounter++}` });\r\n                }\r\n                if (!SystemClass.__internal) {\r\n                    if (typeNames.has(SystemClass.name)) {\r\n                        throw new CheckError(`Multiple component types named ${SystemClass.name}; names must be unique`);\r\n                    }\r\n                    typeNames.add(SystemClass.name);\r\n                }\r\n                this.stats.forSystem(SystemClass);\r\n                systemClasses.push(SystemClass);\r\n                const system = new SystemClass();\r\n                system.id = (i + 2); // 0 and 1 are reserved for internal systems\r\n                box = new SystemBox(system, this);\r\n                systems.push(box);\r\n                this.systemsByClass.set(SystemClass, box);\r\n            }\r\n            const props = systemTypes[i + 1];\r\n            if (props && typeof props !== 'function') {\r\n                box.assignProps(props);\r\n                i++;\r\n            }\r\n        }\r\n        this.default = this.createSingleGroupFrame(systemClasses);\r\n        return systems;\r\n    }\r\n    createBuildSystem() {\r\n        this.buildSystem = new Build();\r\n        this.buildSystem.id = 0;\r\n        const box = new SystemBox(this.buildSystem, this);\r\n        box.accessMasks.read = undefined;\r\n        box.accessMasks.update = undefined;\r\n        box.accessMasks.create = undefined;\r\n        box.accessMasks.write = undefined;\r\n        box.accessMasks.check = undefined;\r\n        this.systems.push(box);\r\n        this.systemsByClass.set(Build, box);\r\n    }\r\n    createValidateSystem(componentTypes) {\r\n        const system = new Validate();\r\n        system.id = 1;\r\n        const box = new SystemBox(system, this);\r\n        for (const type of componentTypes)\r\n            extendMaskAndSetFlag(box.accessMasks.check, type);\r\n        this.systems.push(box);\r\n        this.systemsByClass.set(Validate, box);\r\n        return box;\r\n    }\r\n    createSingleGroupFrame(systemTypes) {\r\n        const group = new SystemGroupImpl(systemTypes);\r\n        this.systemGroups.push(group);\r\n        const frame = new FrameImpl(this, [group]);\r\n        return { group, frame };\r\n    }\r\n    createSingletons() {\r\n        const types = new Set();\r\n        const singletonComponentDefs = this.systems.flatMap(box => {\r\n            return box.singletonComponentDefs.filter((item, i) => {\r\n                let accepted = true;\r\n                if (typeof item === 'function') {\r\n                    accepted = i < box.singletonComponentDefs.length - 1 &&\r\n                        typeof box.singletonComponentDefs[i + 1] !== 'function';\r\n                    if (accepted)\r\n                        types.add(item);\r\n                }\r\n                return accepted;\r\n            });\r\n        }).concat(this.systems.flatMap(box => {\r\n            return box.singletonComponentDefs.filter(item => {\r\n                if (typeof item === 'function' && !types.has(item)) {\r\n                    types.add(item);\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n        }));\r\n        if (!singletonComponentDefs.length)\r\n            return;\r\n        this.executing = true;\r\n        const singleton = this.createEntity(singletonComponentDefs).hold();\r\n        this.executing = false;\r\n        this.flush();\r\n        return singleton;\r\n    }\r\n    splitDefs(defs) {\r\n        const componentTypes = [];\r\n        const componentTypesSet = new Set();\r\n        const componentEnums = new Set();\r\n        const systemTypes = [];\r\n        const systemGroups = [];\r\n        let lastDefWasSystem = false;\r\n        for (const def of defs.flat(Infinity)) {\r\n            if (def instanceof SystemGroupImpl) {\r\n                systemGroups.push(def);\r\n                const { componentTypes: nestedComponentTypes, systemTypes: nestedSystemTypes, systemGroups: nestedSystemGroups } = this.splitDefs(def.__contents);\r\n                for (const type of nestedComponentTypes)\r\n                    addUniqueComponentType(type);\r\n                systemTypes.push(...nestedSystemTypes);\r\n                systemGroups.push(...nestedSystemGroups);\r\n            }\r\n            else if (typeof def === 'function') {\r\n                lastDefWasSystem = !!def.__system;\r\n                if (lastDefWasSystem) {\r\n                    systemTypes.push(def);\r\n                }\r\n                else {\r\n                    addUniqueComponentType(def);\r\n                }\r\n            }\r\n            else if (def instanceof ComponentEnum) {\r\n                componentEnums.add(def);\r\n                for (const type of def.__types)\r\n                    addUniqueComponentType(type);\r\n            }\r\n            else {\r\n                {\r\n                    if (!lastDefWasSystem)\r\n                        throw new CheckError('Unexpected value in world defs: ' + def);\r\n                }\r\n                systemTypes.push(def);\r\n                lastDefWasSystem = false;\r\n            }\r\n        }\r\n        return { componentTypes, componentEnums: Array.from(componentEnums), systemTypes, systemGroups };\r\n        function addUniqueComponentType(type) {\r\n            if (type.enum && !componentEnums.has(type.enum)) {\r\n                componentEnums.add(type.enum);\r\n                for (const enumType of type.enum.__types)\r\n                    addUniqueComponentType(enumType);\r\n            }\r\n            else if (!componentTypesSet.has(type)) {\r\n                componentTypes.push(type);\r\n                componentTypesSet.add(type);\r\n            }\r\n        }\r\n    }\r\n    getSystems(designator) {\r\n        if (designator instanceof SystemGroupImpl)\r\n            return designator.__systems;\r\n        const system = this.systemsByClass.get(designator);\r\n        if (!system)\r\n            throw new CheckError(`System ${designator.name} not registered in world`);\r\n        return [system];\r\n    }\r\n    async initialize() {\r\n        await this.default.frame.begin();\r\n        this.state = State.setup;\r\n        await this.default.group.__plan.initialize();\r\n        await this.default.frame.end();\r\n        this.stats.frames -= 1;\r\n    }\r\n    async finalize() {\r\n        await this.default.frame.begin();\r\n        this.state = State.done;\r\n        await this.default.group.__plan.finalize();\r\n        await this.default.frame.end();\r\n        this.stats.frames -= 1;\r\n        this.registry.releaseComponentTypes();\r\n    }\r\n    async execute(time, delta) {\r\n        await this.default.frame.begin();\r\n        await this.default.frame.execute(this.default.group, time, delta);\r\n        await this.default.frame.end();\r\n    }\r\n    executeFunction(fn) {\r\n        // This inlines the code for Frame begin/execute/end to make it synchronous.\r\n        this.startFrame(this.lastTime);\r\n        this.executingSyncFrame = true;\r\n        this.buildSystem.__callback = fn;\r\n        this.systemsByClass.get(Build).execute(this.lastTime, 0);\r\n        this.flush();\r\n        this.completeCycle();\r\n        this.completeFrame(); // async only if termination pending, but it's forbidden in this context\r\n        this.executingSyncFrame = false;\r\n        // This is not really a frame, so back out the count.\r\n        this.stats.frames -= 1;\r\n    }\r\n    completeCycle() {\r\n        this.registry.completeCycle(); // may update writeLog\r\n        this.indexer.completeCycle();\r\n        this.writeLog?.commit();\r\n    }\r\n    startFrame(time) {\r\n        if (this.executing)\r\n            throw new CheckError('Another frame already executing');\r\n        this.executing = true;\r\n        {\r\n            if (this.state !== State.setup && this.state !== State.run && this.state !== State.finish) {\r\n                throw new CheckError('World terminated');\r\n            }\r\n        }\r\n        this.state = State.run;\r\n        this.lastTime = time;\r\n    }\r\n    completeFrame() {\r\n        if (!this.executing)\r\n            throw new InternalError('No frame executing');\r\n        this.executing = false;\r\n        this.gatherFrameStats();\r\n        this.processDeferredControls();\r\n        if (this.state === State.finish)\r\n            return this.finalize();\r\n        return Promise.resolve();\r\n    }\r\n    gatherFrameStats() {\r\n        this.stats.frames += 1;\r\n        this.stats.maxShapeChangesPerFrame = this.shapeLog.countSince(this.shapeLogFramePointer);\r\n        this.stats.maxWritesPerFrame = this.writeLog?.countSince(this.writeLogFramePointer) ?? 0;\r\n    }\r\n    flush() {\r\n        this.indexer.flush(); // may update writeLog\r\n        this.registry.flush();\r\n        this.shapeLog.commit();\r\n        this.writeLog?.commit();\r\n    }\r\n    async terminate() {\r\n        {\r\n            if (this.state !== State.setup && this.state !== State.run) {\r\n                throw new CheckError('World terminated');\r\n            }\r\n            if (this.executingSyncFrame) {\r\n                throw new CheckError('Cannot terminate world from within build callback');\r\n            }\r\n        }\r\n        this.state = State.finish;\r\n        if (!this.executing)\r\n            await this.finalize();\r\n    }\r\n    createEntity(initialComponents) {\r\n        const entity = this.registry.createEntity(initialComponents);\r\n        if (!this.executing)\r\n            this.flush();\r\n        return entity;\r\n    }\r\n    control(options) {\r\n        this.checkControlOverlap(options);\r\n        this.deferRequestedRunState(options.stop, RunState.STOPPED);\r\n        this.deferRequestedRunState(options.restart, RunState.RUNNING);\r\n        if (!this.executing)\r\n            this.processDeferredControls();\r\n    }\r\n    deferRequestedRunState(defs, state) {\r\n        for (const def of this.splitDefs(defs).systemTypes) {\r\n            if (!def.__system)\r\n                continue;\r\n            const system = this.systemsByClass.get(def);\r\n            if (!system)\r\n                throw new CheckError(`System ${def.name} not defined for this world`);\r\n            this.deferredControls.set(system, state);\r\n        }\r\n    }\r\n    checkControlOverlap(options) {\r\n        const stopSet = new Set();\r\n        for (const def of this.splitDefs(options.stop).systemTypes) {\r\n            if (def.__system)\r\n                stopSet.add(def);\r\n        }\r\n        for (const def of this.splitDefs(options.restart).systemTypes) {\r\n            if (!def.__system)\r\n                continue;\r\n            if (stopSet.has(def)) {\r\n                throw new CheckError(`Request to both stop and restart system ${def.name}`);\r\n            }\r\n        }\r\n    }\r\n    processDeferredControls() {\r\n        if (!this.deferredControls.size)\r\n            return;\r\n        for (const [system, state] of this.deferredControls.entries()) {\r\n            switch (state) {\r\n                case RunState.STOPPED:\r\n                    system.stop();\r\n                    break;\r\n                case RunState.RUNNING:\r\n                    system.restart();\r\n                    break;\r\n            }\r\n        }\r\n        this.deferredControls.clear();\r\n    }\r\n}\n\nconst MAGIC_COOKIE = {};\r\n/**\r\n * A container for entities, components, and systems, and the sole entry point to all functionality.\r\n * Normally you'll create just one world for your game or app.\r\n */\r\nclass World {\r\n    __dispatcher;\r\n    /**\r\n     * Creates a world that contains entities, components and systems.  All systems will be\r\n     * instantiated and initialized before the returned promise resolves.\r\n     *\r\n     * You cannot add more component or system types once the world has been created. You can create\r\n     * multiple worlds but they will not share entities, and must not share component types.  (They\r\n     * can share system types, but each will have its own instances of them.)\r\n     *\r\n     * @param options The options with which to initialize the world.\r\n     *\r\n     * @returns A promise of a new world to do with as you please.\r\n     */\r\n    static async create(options = {}) {\r\n        const world = new World(options, MAGIC_COOKIE);\r\n        await world.__dispatcher.initialize();\r\n        return world;\r\n    }\r\n    static defineEnum(name, ...componentTypes) {\r\n        if (typeof name === 'function') {\r\n            componentTypes.unshift(name);\r\n            name = '';\r\n        }\r\n        name = name || '<anonymous>';\r\n        return new ComponentEnum(name, componentTypes);\r\n    }\r\n    /**\r\n     * This is a private constructor, please use the World.create() method instead.\r\n     */\r\n    constructor(options, magicCookie) {\r\n        {\r\n            if (magicCookie !== MAGIC_COOKIE) {\r\n                throw new CheckError(`Don't call World constructor directly; use World.create instead`);\r\n            }\r\n        }\r\n        this.__dispatcher = new Dispatcher(options);\r\n    }\r\n    /**\r\n     * Executes a function that creates and updates entities.  The function gets executed in the\r\n     * context of a no-op system so it can access all its convenience methods.  You can only invoke\r\n     * this method when the world is not executing, e.g. during initial setup or between frames.\r\n     *\r\n     * @param callback The function to execute.  It receives a system as the sole argument, which it\r\n     * can use to create new entities.  You can retain references to these entities within the\r\n     * function but you must be careful not to let them leak out, as the entity objects are merely\r\n     * handles that will be reassigned without warning.  (The entities themselves will persist, of\r\n     * course.)\r\n     */\r\n    build(callback) {\r\n        {\r\n            if (this.__dispatcher.state !== State.setup &&\r\n                (typeof process === 'undefined' || process.env.NODE_ENV !== 'test')) {\r\n                throw new CheckError('This method cannot be called after the world has started executing');\r\n            }\r\n        }\r\n        this.__dispatcher.executeFunction(callback);\r\n    }\r\n    /**\r\n     * Creates a new entity and add it to the world.  The entity is not returned -- if you need that,\r\n     * use `build` instead.\r\n     *\r\n     * @param initialComponents The types of the components to add to the new entity, optionally\r\n     * interleaved with their initial properties.\r\n     */\r\n    createEntity(...initialComponents) {\r\n        {\r\n            if (this.__dispatcher.state !== State.setup &&\r\n                (typeof process === 'undefined' || process.env.NODE_ENV !== 'test')) {\r\n                throw new CheckError('This method cannot be called after the world has started executing');\r\n            }\r\n        }\r\n        this.__dispatcher.createEntity(initialComponents);\r\n    }\r\n    /**\r\n     * Executes all the systems defined during the world's creation.  The systems will be executed as\r\n     * ordered by their constraints, *not* in the order they were defined.  See\r\n     * {@link System.schedule} for details.\r\n     *\r\n     * @param time The time of this frame's execution.  This will be set on every system's `time`\r\n     * property and defaults to the time when `execute` was called.  It's not used internally so you\r\n     * can pass in any numeric value that's expected by your systems.\r\n     *\r\n     * @param delta The duration since the last frame's execution.  This will be set on every system's\r\n     * `delta` property and default to the duration since the previous call to `execute`. It's not\r\n     * used internally so you can pass in any numeric value that's expected by your systems.\r\n     */\r\n    execute(time, delta) {\r\n        return this.__dispatcher.execute(time, delta);\r\n    }\r\n    /**\r\n     * Controls the running state of systems by stopping or restarting them.  Stopped systems won't\r\n     * update their queries and generally won't consume resources.  Restarting a system is a\r\n     * potentially expensive operation so you should only use this facility for major state changes,\r\n     * e.g. between scenes.  Restarted systems will not backfill any reactive queries with events that\r\n     * happened while they were stopped.\r\n     *\r\n     * You can call this method at any time but the control instructions will only be applied between\r\n     * frames.\r\n     *\r\n     * @param options The control instructions.\r\n     */\r\n    control(options) {\r\n        this.__dispatcher.control(options);\r\n    }\r\n    /**\r\n     * Creates an executor that allows you to run a subset of all defined systems in a frame, or run\r\n     * some of them multiple times.  You can switch which executor you use between frames or even\r\n     * interleave running becsy's default execution strategy with your own executors.  However, if\r\n     * there are systems that won't be running for a while (because they're not in any of your\r\n     * executor's groups) you must still stop them explicitly or you'll run out of reserved buffer\r\n     * space.\r\n     *\r\n     * Creating an executor is a potentially expensive operation so you should create them all up\r\n     * front for the various combinations of system groups you might want to run.\r\n     *\r\n     * @param groups All the possible groups of systems that this executor might want to run.  The\r\n     * groups must be a subset of the world's defined groups.  Every group must be executed regularly\r\n     * at least once every few frames, otherwise you'll likely overflow reserved buffer space.  (This\r\n     * is true even if the groups overlap, as execution is tracked at a group level, not for\r\n     * individual systems.)\r\n     *\r\n     * @returns A frame executor that lets you manually run system groups within a frame.\r\n     */\r\n    createCustomExecutor(...groups) {\r\n        return new FrameImpl(this.__dispatcher, groups);\r\n    }\r\n    /**\r\n     * Terminates this world once the current frame (if any) completes.  All workers will be\r\n     * terminated and no further executions will be allowed.\r\n     */\r\n    async terminate() {\r\n        await this.__dispatcher.terminate();\r\n    }\r\n    get stats() {\r\n        return this.__dispatcher.stats;\r\n    }\r\n    /**\r\n     * Returns whether this world is alive and capable of execution (true), or has been terminated\r\n     * (false).\r\n     */\r\n    get alive() {\r\n        return this.__dispatcher.state !== State.done;\r\n    }\r\n}\n\nexport { CanceledError, Query, System, Type, World, co, component, field, system };\n//# sourceMappingURL=index.js.map\n"],"names":["ENTITY_ID_BITS","ENTITY_ID_MASK","MAX_NUM_ENTITIES","COMPONENT_ID_MASK","MAX_NUM_COMPONENTS","InternalError","Error","constructor","message","super","CheckError","encoder","TextEncoder","decoder","TextDecoder","throwNotWritable","binding","type","name","checkInvalid","component","__invalid","Type","defaultValue","shared","this","internallyIndexed","static","NumberType","NumberArray","defineElastic","field","bufferKey","id","seq","data","updateBuffer","dispatcher","buffers","register","capacity","newData","Object","defineProperty","writableMaster","enumerable","configurable","get","writableIndex","set","value","readonlyMaster","readonlyIndex","defineFixed","VectorType","Class","stride","elementNames","elements","Array","length","fill","masterWritableAccessor","masterReadonlyAccessor","undefined","writable","writableAccessor","create","seal","readonlyAccessor","i","__becsyComponent","StaticStringType","choices","choicesIndex","Map","TypedArray","Uint8Array","Uint16Array","Uint32Array","index","result","DynamicStringType","maxUtf8Length","lengthsStride","bytesStride","lengths","bytes","size","BYTES_PER_ELEMENT","buffer","decode","encodedString","encode","byteLength","STALE_REF_BIT","EMPTY_ARRAY","BackrefsType","fieldName","trackDeletedBackrefs","refField","__binding","fields","find","aField","ref","refFields","indexer","registerSelector","selectorId","registry","includeRecentlyDeleted","getBackrefs","writableEntityId","readonlyEntityId","boolean","Boolean","uint8","int8","Int8Array","uint16","int16","Int16Array","uint32","int32","Int32Array","float32","Float32Array","float64","Float64Array","vector","staticString","dynamicString","pool","clearRef","final","targetId","internalIndex","stale","trackRefChange","borrowTemporarily","hasShape","__id","Alive","oldId","newId","backrefs","object","weakObject","finalizers","initFinalizers","deref","weakRef","WeakRef","trackedWrites","writeLog","FinalizationRegistry","trackWrite","Binding","storage","elastic","shapeSpec","readonlyInstance","writableInstance","shapeOffset","offset","shapeMask","mask","shapeValue","filter","initDefault","Function","default","map","JSON","stringify","join","backrefFieldInits","init","concat","resetWritableInstance","entityId","resetReadonlyInstance","checkTypeDefined","PackedStorage","maxEntities","growSpares","growCapacity","acquireIndex","spares","Math","min","releaseIndex","stats","forComponent","ArrayType","elementSizeChanged","updateSpares","bind","maxSpares","max","CompactStorage","findIndex","firstEmpty","updateIndex","initComponent","values","key","schema","__allocate","assimilateComponentType","typeId","entry","push","gatherFields","options","defaultComponentStorage","initialCapacity","restrictedToMainThread","every","__bind","defineAndAllocateComponentType","storageManager","__free","dissimilateComponentType","declareSingleton","EntityImpl","__registry","__sortKey","__valid","alive","__checkValid","ordinal","entityOrdinals","add","__checkMask","setShape","numEntities","addAll","args","enums","Set","arg","enum","has","remove","__checkHas","currentType","getEnumShape","clearShape","removeAll","types","hasSomeOf","hasAllOf","hasAnyOtherThan","typeSet","countHas","count","hasWhich","enumeration","read","write","delete","clearAllRefs","hold","holdEntity","isSame","other","kind","checkMask","executingSystem","allowRecentlyDeleted","system","accessMasks","isMaskFlagSet","extendMaskAndSetFlag","useValues","flagOffset","oldLength","EMPTY_TUPLE","Log","maxEntries","configParamName","corral","staging","typeCounters","localProcessingAllowed","sortedByComponentType","numComponentTypes","corralLength","throwCapacityExceeded","commit","pointer","generation","corralGeneration","corralIndex","copyToData","sortCorral","soleTypeId","soleTypeCount","numNonZeroTypes","corralAndHeaderLength","source","firstSegmentLength","subarray","createPointer","copyPointer","hasUpdatesSince","checkPointer","processSince","startPointer","endPointer","checkPointers","endIndex","endGeneration","processAndCommitSince","countSince","startIndex","startGeneration","Bitset","ceil","unset","clear","ArrayEntityList","orderBy","entities","maxOrderKey","sorted","entity","orderKey","sort","a","b","PackedArrayEntityList","lookupTable","borrow","return","pop","QueryFlavor","transientFlavorsMask","added","removed","changed","addedOrChanged","changedOrRemoved","addedChangedOrRemoved","changedFlavorsMask","shapeFlavorsMask","QueryBox","results","flavors","withMask","withValues","withAnyRecords","withoutMask","withoutEnumTypes","trackWritesMask","hasTransientResults","hasChangedResults","hasShapeResults","hasMatchTracking","currentEntities","processedEntities","changedEntities","query","__results","__systemName","complete","some","record","lastMatches","minLength","hasTrackers","item","current","allocateTransientResultLists","shapeQueries","writeQueries","allocateResult","clearTransientResults","clearAllResults","clearProcessedEntities","handleShapeUpdate","oldMatch","newMatch","matchShape","handleWrite","componentFlagOffset","componentFlagMask","QueryBuilder","__callback","__userQuery","__query","__system","__lastTypes","__lastWasWithAny","__build","e","and","but","also","transformer","with","withAny","without","using","usingAll","slice","trackWrites","enumType","__types","trackMatches","update","readMask","updateMask","createMask","writeMask","trackMask","planner","readers","writers","check","categorize","shapeQueriesByComponent","writeQueriesByComponent","includes","Query","__checkList","flavor","now","window","performance","Date","ScheduleBuilder","__schedule","__systems","__dispatcher","systems","allSystems","defaultGroup","onMainThread","__checkNoLaneAssigned","mainLane","onOneThread","createLane","onManyThreads","replicatedLane","stateless","lane","before","systemTypes","thisSet","getSystems","graph","addEdge","after","inAnyOrderWith","denyEdge","beforeReadersOf","componentTypes","componentType","afterReadersOf","beforeWritersOf","afterWritersOf","inAnyOrderWithReadersOf","inAnyOrderWithWritersOf","Schedule","SystemGroupImpl","__contents","__plan","__executed","__scheduleBuilder","__collectSystems","systemsByClass","__buildSchedule","schedule","buildCallback","FrameImpl","groups","executing","time","delta","group","systemGroups","async","lastTime","startFrame","allExecuted","completeCycle","completeFrame","execute","CanceledError","canceled","currentCoroutine","CoroutineImpl","__generator","__fn","__supervisor","__cancellers","__blocker","__scope","__done","__awaited","__error","__value","__firstRun","__checkCancelation","canceller","cancel","__step","isReady","next","error","throw","cancelMatching","done","markAwaited","waitForFrames","frames","waitForSeconds","seconds","targetTime","waitUntil","condition","cancelIf","scope","cancelIfComponentMissing","cancelIfCoroutineStarted","coroutineFn","registerCancelIfStarted","coDecorator","self","Symbol","iterator","target","descriptor","coroutine","start","checkCurrentCoroutine","Supervisor","coroutines","mutuallyExclusiveCoroutines","apply","processedLength","accessRecentlyDeletedData","splice","targetCoroutine","startingCoroutine","cancelMatchingKey","requestingCoroutine","hasRequesting","RunState","SingletonPlaceholder","access","initialValues","AttachPlaceholder","System","__queryBuilders","__attachPlaceholders","__singletonPlaceholders","builder","attach","systemType","placeholder","createEntity","initialComponents","toggle","initialize","finalize","prototype","singleton","q","SystemBox","toString","state","RUNNING","propsAssigned","weight","shapeLogPointer","shapeLog","forSystem","attachedSystems","singletonComponentDefs","flatMap","singletonStandingWrites","assignProps","props","assign","buildQueries","hasNegativeQueries","hasWriteQueries","hasTransientQueries","buildSchedule","staticScheduler","__staticScheduler","finishConstructing","writeLogPointer","replacePlaceholders","openSystem","prop","targetSystemType","targetSystem","prepare","trackStandingWrites","time1","time2","time3","time4","runQueries","lastQueryUpdateDuration","lastExecutionDuration","lastCoroutinesDuration","ranQueriesLastFrame","shapesChanged","writesMade","__updateShapeQueries","__updateWriteQueries","queries","log","runLength","runHeader","skip","j","stop","STOPPED","restart","ComponentEnum","from","UnsharedPool","maxItems","ArrayBuffer","take","RangeError","mark","peekSinceMark","refill","newLength","fillWithDescendingIntegers","first","lowerBound","SharedAtomicPool","Atomics","sub","UnsharedShapeArray","array","numBits","shapes","syncThreads","isSet","shapeShift","match","positiveMask","positiveValues","matchNot","negativeMask","matchAny","trackingMask","lastMatch","ok","masked","AtomicSharedShapeArray","load","or","SYSTEM_ERROR_TYPES","EvalError","ReferenceError","SyntaxError","TypeError","URIError","AggregateError","EntityPool","borrowed","borrowCounts","temporarilyBorrowedIds","returnTemporaryBorrows","Registry","allocationItems","numShapeBits","staleShapes","removedShapes","entityIdPool","heldEntities","validators","reshapedEntityIds","validateSystem","nextEntityOrdinal","removalLog","prevRemovalPointer","oldRemovalPointer","maxLimboComponents","prepareComponentTypesAndEnums","ShapeArrayClass","threaded","initializeComponentTypes","bitIndex","shift","removeBiggestNoLargerThan","typeOrEnum","validate","aliveBinding","enumTypes","typeNames","anonymousTypeCounter","__internal","log2","unshift","maxSize","k","releaseComponentTypes","createComponents","flush","lastExecutingSystem","validateShapes","processRemovalLog","invalidateDeletedHeldEntities","systemSuffix","componentNames","numDeletedEntities","componentId","clearRefs","oldType","logEntry","trackingMasks","negativeTypes","computeMovingAverage","average","ComponentStats","_numEntities","toLocaleString","SystemStats","worker","_lastQueryUpdateDuration","averageQueryUpdateDuration","_lastExecutionDuration","averageExecutionDuration","_lastCoroutinesDuration","averageCoroutinesDuration","Stats","_maxEntities","_maxLimboComponents","_maxRefChangesPerFrame","_maxShapeChangesPerFrame","_maxWritesPerFrame","components","maxRefChangesPerFrame","maxShapeChangesPerFrame","maxWritesPerFrame","componentStats","systemStats","keys","compStats","Action","ACTION_MASK","UNREFERENCE_AND_RELEASE","Tracker","targetEntityId","selector","trackStale","tags","entityIndex","clearing","sourceType","matchType","matchSeq","sourceSeq","tag","sourceId","sourceTypeId","MAX_NUM_FIELDS","trackReference","fieldSeq","trackChanges","checkUpdateMask","getEntityIndex","addEntity","addTag","makeTag","trackUnreference","removeTag","removeEntity","indexEntities","isArray","indexOf","trackBackrefsChange","lastEntity","lastTag","targetType","targetTypes","RefIndexer","refLog","refLogPointer","refLogStatsPointer","selectorIdsBySourceKey","selectors","trackers","sourceFieldSeq","selectorSourceKey","getOrCreateTracker","sourceInternalIndex","oldTargetId","newTargetId","unreference","release","action","UNREFERENCE","RELEASE","pushRefLogEntry","REFERENCE","getTracker","processEntry","staleTracker","tracker","local","entryPart1","entryPart2","Item","arrayTypeToKind","arrayKindToType","Buffers","items","changes","filler","needBiggerBuffer","needNewArray","newItem","SharedArrayBuffer","arrayKind","makePatch","patch","applyPatch","patchItem","entries","addFieldSchema","practicalOptions","makeVectorDecorator","fn","Graph","vertices","numVertices","edges","paths","vertexIndexMap","sealed","sortedVertices","dependencyCounts","traversalCounts","numTraversedVertices","topologicallySortedVertices","sortTopologically","getEdgeIndex","setEdge","sourceToTarget","targetToSource","absWeight","abs","hasEdge","hasPath","hasEdgeBetweenIds","derivePaths","checkForCycles","simplify","countDependencies","cycles","findCycles","x","y","cycle","u","blocked","stack","s","unblock","w","circuit","v","f","componentVertices","findLeastStronglyConnectedComponent","minId","leastComponent","preorder","p","assigned","counter","search","induceSubgraph","subvertices","subgraph","vertex","edgeIndex","edgeCounts","n","weight1","weight2","traverse","completedVertex","traversedVertices","printMatrix","matrix","lines","line","Plan","SimplePlan","process","console","Promise","resolve","reject","rejected","initSystem","finalizeSystem","ThreadedPlan","Lane","merge","Planner","lanes","laneCount","organize","addComponentEntitlementDependencies","assignSystemsToLanes","reader","writer","initSystemLanes","mergeAccessorsOfUnsharedComponentTypes","mergeAttachedSystems","pruneEmptyLanes","reduceLanes","threads","forEach","attachedSystem","maxNumLanes","pairs","laneA","laneB","independence","computeIndependence","numLanes","pair1","pair2","tangledPair","combinedLane","discardedLane","pair","computeIndependentWeight","otherLane","independentWeight","otherWeight","otherSystem","Build","Validate","State","Dispatcher","executingSyncFrame","shapeLogFramePointer","writeLogFramePointer","buildSystem","deferredControls","defs","componentTypes$1","componentEnums","systemTypes$1","splitDefs","createSystems","createBuildSystem","createValidateSystem","createSingletons","box","setup","systemClasses","SystemClass","createSingleGroupFrame","frame","accepted","componentTypesSet","lastDefWasSystem","def","flat","Infinity","nestedComponentTypes","nestedSystemTypes","nestedSystemGroups","addUniqueComponentType","designator","begin","end","executeFunction","run","finish","gatherFrameStats","processDeferredControls","control","checkControlOverlap","deferRequestedRunState","stopSet","MAGIC_COOKIE","World","world","magicCookie","build","callback","createCustomExecutor","terminate"],"sourceRoot":""}