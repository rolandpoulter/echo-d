{"version":3,"file":"lib.echo-d.min.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,GACjB,CATD,CASqB,oBAAXK,OAAyBA,OAA2B,oBAAXC,OAAyBA,OAAyB,oBAATC,KAAuBA,KAAOC,MAAM,I,mBCRhI,IAAIC,EAAsB,CCA1BA,EAAwB,CAACR,EAASS,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAEX,EAASU,IAC5EE,OAAOC,eAAeb,EAASU,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFT,EAAyBR,IACH,oBAAXqB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeb,EAASqB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeb,EAAS,aAAc,CAAEuB,OAAO,GAAO,G,26DCFvD,SAASC,IACZ,OAAOC,YAAYC,WAAaD,YAAYD,KAChD,CAQO,SAASG,EAAiBC,EAAGC,GAChC,GAAIC,MAAMC,QAAQH,IAAME,MAAMC,QAAQF,GAClC,OAAOD,EAAEI,OAAOH,GAEf,GAAIC,MAAMC,QAAQH,GAAI,CACvB,MAAMK,EAAK,IAAIJ,EAAEK,YAAYN,EAAEO,QAC/BF,EAAGG,IAAIR,GACPA,EAAIK,CACR,MACK,GAAIH,MAAMC,QAAQF,GAAI,CACvB,MAAMQ,EAAK,IAAIT,EAAEM,YAAYL,EAAEM,QAC/BE,EAAGD,IAAIP,GACPA,EAAIQ,CACR,CACA,MAAMC,EAAI,IAAIV,EAAEM,YAAYN,EAAEO,OAASN,EAAEM,QAKzC,OAJIG,EAAEF,MACFE,EAAEF,IAAIR,GACNU,EAAEF,IAAIP,EAAGD,EAAEO,SAERG,CACX,CAOO,SAASC,KAAmBC,GAC/B,MAAMC,EAAQ,CAAC,EACf,IAAK,MAAML,KAAOI,EACd,GAAIJ,EACA,IAAK,MAAMM,KAAKN,EACZK,EAAMC,IAAK,EAIvB,OAAO9B,OAAO+B,KAAKF,EACvB,CAQO,SAASG,EAAUC,EAAMC,GAC5B,GAA0B,mBAAfD,EAAKJ,MACZ,OAAOI,EAAKJ,MAAMI,GAEtB,MAAMJ,EAAQ,IAAIM,IAClB,IAAK,MAAML,KAAKG,EACZJ,EAAMO,IAAIN,GACd,IAAK,MAAMA,KAAKI,EACZL,EAAMO,IAAIN,GACd,OAAOD,CACX,CAQO,SAASQ,EAAeJ,EAAMC,GACjC,GAA+B,mBAApBD,EAAKK,WACZ,OAAOL,EAAKK,WAAWL,GAE3B,MAAMK,EAAa,IAAIH,IACvB,IAAK,MAAML,KAAKG,EACPC,EAAKK,IAAIT,IACVQ,EAAWF,IAAIN,GACvB,OAAOQ,CACX,CAQO,SAASE,EAAiBP,EAAMC,GACnC,GAAiC,mBAAtBD,EAAKQ,aACZ,OAAOR,EAAKQ,aAAaR,GAE7B,MAAMQ,EAAe,IAAIN,IACzB,IAAK,MAAML,KAAKG,EACRC,EAAKK,IAAIT,IACTW,EAAaL,IAAIN,GACzB,OAAOW,CACX,CASO,SAASC,EAAaC,EAAOhC,EAAOiC,EAAW,CAACd,GAAMA,IACzD,IAAIe,EAAM,EACNC,EAAOH,EAAMpB,OACjB,KAAOsB,EAAMC,GAAM,CACf,MAAMC,EAAOF,EAAMC,IAAU,EAEnBF,EADGD,EAAMI,IAEXpC,EACJkC,EAAME,EAAM,EAGZD,EAAOC,CAEf,CACA,OAAOF,CACX,CASO,SAASG,EAAaL,EAAOM,EAAQL,EAAW,CAACd,GAAMA,IAC1D,IAAIoB,EAAO,EACPC,EAAQR,EAAMpB,OAAS,EAC3B,KAAO2B,GAAQC,GAAO,CAClB,MAAMJ,EAAOG,EAAOC,IAAW,EAEzBrB,EAAIc,EADGD,EAAMI,IAEnB,GAAIjB,IAAMmB,EACN,MAAO,CAACF,EAAKG,GAERpB,EAAImB,EACTC,EAAOH,EAAM,EAGbI,EAAQJ,EAAM,CAEtB,CACA,MAAO,EAAE,EAAGG,EAChB,CAQO,SAASE,EAAW5B,EAAK6B,EAAS,GACrC,MAAMC,EAAQ,CAAC,EACf,IAAIC,EAAIF,EACR,GAAI7B,EACA,IAAK,MAAMM,KAAKN,EACZ8B,EAAMxB,GAAKyB,IAGnB,OAAOD,CACX,CAOO,SAASE,EAAaC,GACzB,MAAO,CAACA,GAASC,OAAQD,GAASE,QACtC,CAQO,SAASC,EAASC,EAAOC,GAC5B,GAAIA,IAAaC,KAAY7C,MAAMC,QAAQ0C,IAAUA,EAAMtC,OAAS,EAChE,MAAO,CAACsC,GAEZ,MAAMG,EAAQ,GACd,IAAIC,EAAO,GACPV,EAAI,EAIR,IAAK,MAAMzB,KAAK+B,EACRN,GAAKO,IACLE,EAAME,KAAKD,GACXA,EAAO,GACPV,EAAI,GAERU,EAAKC,KAAKpC,GACVyB,IAKJ,OAHIU,EAAK1C,OAAS,GACdyC,EAAME,KAAKD,GAERD,CACX,CAOO,SAASG,EAAOrC,GACnB,MAAMsC,SAAWtC,EACjB,GAAU,WAANsC,EAAgB,CAChB,IAAKtC,EACD,MAAO,OAEN,GAAIZ,MAAMC,QAAQW,GACnB,MAAO,OAEf,CACA,OAAOsC,CACX,CAQO,SAASC,EAAcC,EAAMC,GAChC,OAAOC,EAAqBF,EAAMC,EACtC,CASO,SAASC,EAAqBF,EAAMC,GACvC,MAAME,EAAQN,EAAOG,GAErB,OADcH,EAAOI,IAEjB,IAAK,SACL,IAAK,SACD,MAAc,WAAVE,GAAgC,WAAVA,EACf,EAAC,EAAOF,GAEZ,EAAC,EAAMD,EAAOC,GAEzB,IAAK,QAAS,CACV,GAAc,UAAVE,EACA,MAAO,EAAC,EAAOF,GAEnB,MAAMG,EAAS,GACf,IAAIC,GAAW,EACf,IAAK,IAAIpB,EAAI,EAAGA,EAAIgB,EAAKhD,OAAQgC,GAAK,EAAG,CACrC,MAAO7B,EAAGf,GAAS6D,EAAqBF,EAAKf,GAAIgB,EAAKhB,IACtDmB,EAAOnB,GAAK5C,GACF,IAANe,IACAiD,GAAW,EAEnB,CACA,MAAO,CAACA,EAAUD,EACtB,CACA,IAAK,SAAU,CACX,GAAc,WAAVD,EACA,MAAO,EAAC,EAAOF,GAEnB,MAAMK,EAAS,CAAC,EAChB,IAAID,GAAW,EACf,IAAK,MAAME,KAAKN,EAAM,CAClB,MAAO7C,EAAGf,GAAS6D,EAAqBF,EAAKO,GAAIN,EAAKM,KAC5C,IAANnD,IACAiD,GAAW,GAEfC,EAAOC,GAAKlE,CAChB,CACA,MAAO,CAACgE,EAAUC,EACtB,CACA,QACI,MAAO,EAAC,EAAOL,GAE3B,C,mEC/RO,MAAMO,EAAU,CACnB,aACA,SACA,YACA,QACA,kBACA,aACA,eACA,WACA,cACA,YACA,cACA,kBACA,gBACA,eACA,cACA,cACA,kBACA,eACA,aACA,SACA,UAGA,mBAKSC,EAAmB,CAC5B,QACA,WACA,QACA,SACA,WACA,WACA,WACA,QAKSC,EAAiBrD,EAAgBmD,EAASC,GAI1CE,EAAU,EAIVC,EAAc9B,EAAW0B,EAASG,GAIlCE,EAAuB/B,EAAW2B,EAAkBD,EAAQvD,OAAS0D,GAIrE,EAAqB7B,EAAW4B,EAAgBC,GAIhD,EAA0B,CACnCG,WAAY,CAAEC,QAAS,EAAGC,SAAU,GACpCC,gBAAiB,CAAEF,QAAS,EAAGG,QAAS,GACxCC,aAAc,EACdC,gBAAiB,EACjBC,gBAAiB,CAAEN,QAAS,EAAGG,QAAS,IAK/BI,EAAiB,CAC1BC,uBAAuB,EACvBC,gBAAgB,EAChBC,gBAAgB,EAChBC,aAAa,EACbC,gBAAgB,EAChBC,kBAAkB,EAClBC,UAAU,EACVC,qBAAqB,EACrBC,WAAW,EACXC,YAAY,EACZC,gBAAgB,EAChBC,eAAe,EACf1C,SAAU,IACV2C,aAAa,EACbC,QAAS,CAKLC,SAAU,CAAEC,KAAM,YAEtBC,MAAO,CACHC,MAAO,MACPC,SAAU,MACVC,MAAO,CAAC,MAAO,GACfC,OAAQ,OACRN,SAAU,CAAC,MAAO,GAClBO,SAAU,CAAC,MAAO,GAClBC,SAAU,CAAC,MAAO,GAClBC,KAAM,CAAC,MAAO,GACdC,KAAM,CAAC,MAAO,KAMTC,EAAuB,CAChCC,KAAM,CACFC,QAAQ,EACRC,UAAU,EACVC,YAAY,EACZC,QAAQ,EACRC,SAAS,IACR,KACLhB,MAAM,EACNiB,SAAS,EACTC,UAAW,KAKFC,EAAmB,CAC5BjB,OAAO,EACPC,UAAU,EACVC,OAAO,EACPC,QAAQ,EACRN,UAAU,EACVO,UAAU,EACVC,UAAU,EACVC,MAAM,EACNC,MAAM,GAKH,SAASW,IAAkB,CAQ3B,SAASC,EAAkBC,EAAIC,GAClC,OAAOD,CACX,CAUO,SAASE,EAAuBzH,EAAO4C,EAAGsD,EAAO/G,GACpD,MAAM8G,EAAOC,EAAM/G,GACnB,OAAIoB,MAAMC,QAAQyF,GACPjG,EAAM0H,MAAM9E,EAAIqD,EAAK,IAAKrD,EAAI,GAAKqD,EAAK,IAE5CjG,EAAM4C,EACjB,CASO,SAAS+E,EAAuB3H,EAAO4H,EAAQC,GAClD,OAAO7H,CACX,CChLO,MAAM8H,EACT9F,MACArB,YAAYqB,EAAQ,KAAM+F,EAAW,CAAC,GAClC/I,KAAKgD,MAAQA,CACjB,CAIAgG,QACIhJ,KAAKgD,MAAQ,IACjB,CAIAiG,QACI,OAAO,IAAIH,EAAM9I,KAAKgD,MAC1B,CAOAxC,IAAI0I,GAAU,CAQdtG,IAAIsG,EAAQC,GACR,OAAO,CACX,CAQAC,OAAOF,EAAQC,GAAO,CAQtBtH,IAAIqH,EAAQC,GACR,OAAO,IACX,CASAE,MAAMd,EAAIe,EAAUtI,GAIhB,OAHIsI,GACAtJ,KAAKoJ,OAAOE,EAAUf,GAEnBvI,KAAK6B,IAAIb,EAAOuH,EAC3B,CAOAgB,MAAMC,GACF,MAAO,EACX,ECtEG,MAAMC,UAAwBX,EACjCnH,YAAYqB,EAAQ,CAAC,EAAG+F,EAAW,CAAC,GAChCW,MAAM1G,EACV,CAIAgG,QACIhJ,KAAKgD,MAAQ,CAAC,CAClB,CAIAiG,QACI,OAAO,IAAIH,EAAM9I,KAAKgD,MAC1B,CAOAxC,IAAIQ,GACA,OAAOhB,KAAKgD,MAAMhC,EACtB,CAQA4B,IAAI5B,EAAOuH,GACP,MAAMoB,EAAM3J,KAAKgD,MAAMhC,GACvB,SAAI2I,IAAOA,EAAI/G,IAAI2F,GAIvB,CAQAa,OAAOpI,EAAOuH,GACV,MAAMoB,EAAM3J,KAAKgD,MAAMhC,GACvB,GAAI2I,GAAOA,EAAI/G,IAAI2F,GAEf,OADAoB,EAAIC,OAAOrB,IACJ,CAEf,CAQA1G,IAAIb,EAAOuH,GAEP,OADAvI,KAAKgD,MAAMhC,GAAShB,KAAKgD,MAAMhC,IAAU,IAAIwB,KACzCxC,KAAKgD,MAAMhC,GAAO4B,IAAI2F,KAG1BvI,KAAKgD,MAAMhC,GAAOyB,IAAI8F,IACf,EACX,CAQArG,MAAM/B,EAAK0J,GACP,OAAO,IAAIJ,EAAgB,IACpBzJ,KAAKgD,MACR,CAAC7C,GAAMkC,EAAUrC,KAAKgD,MAAM7C,GAAM0J,EAAM7G,MAAM7C,KAEtD,CAQAwC,WAAWxC,EAAK0J,GACZ,OAAO,IAAIJ,EAAgB,IACpBzJ,KAAKgD,MACR,CAAC7C,GAAMuC,EAAe1C,KAAKgD,MAAM7C,GAAM0J,EAAM7G,MAAM7C,KAE3D,CAQA2C,aAAa3C,EAAK0J,GACd,OAAO,IAAIJ,EAAgB,IACpBzJ,KAAKgD,MACR,CAAC7C,GAAM0C,EAAiB7C,KAAKgD,MAAM7C,GAAM0J,EAAM7G,MAAM7C,KAE7D,CAOAoJ,MAAMA,GACF,MAAQO,KAAMC,EAAK,QAAEC,GAEhBT,GAAS,CAAC,EACf,IAAIU,EAAU,IAAIzH,IAClB,GAAIuH,EACA,IAAK,MAAM5J,KAAO4J,EAAO,CACrB,MAAMJ,EAAM3J,KAAKgD,MAAM7C,GACnBwJ,IACAM,EAAU5H,EAAU4H,EAASN,GAErC,CAEJ,GAAIK,EACA,IAAK,MAAM7J,KAAO6J,EAAS,CACvB,MAAML,EAAM3J,KAAKgD,MAAM7C,GACnBwJ,IACAM,EAAUvH,EAAeuH,EAASN,GAE1C,CAEJ,OAAOM,CACX,EC5EG,MAAMC,UAAoBpB,EAC7BnH,YAAYqB,EAAQ,GAAI+F,EAAW,CAAC,GAChCW,MAAM1G,EACV,CAIAgG,QACIhJ,KAAKgD,MAAQ,EACjB,CAIAiG,QACI,OAAO,IAAIiB,EAAYlK,KAAKgD,MAChC,CAOAxC,IAAIQ,GACA,MAAMmJ,EAAOnK,KAAKgD,MAAMoH,MAAMD,GAASA,EAAK,KAAOnJ,IACnD,OAAImJ,EACOA,EAAK,GAET,EACX,CAQAvH,IAAI5B,EAAOuH,GACP,MAAM4B,EAAOnK,KAAKgD,MAAMoH,MAAMD,GAASA,EAAK,KAAOnJ,IACnD,YAAWqJ,IAAP9B,IACS4B,IAETA,IAE4B,IADhBA,EAAK,GACNG,QAAQ/B,EAG3B,CAOAa,OAAOpI,EAAOuH,GACV,MAAMxB,EA7Ed,SAAwB/D,EAAOhC,EAAOuH,GAClC,IAAKvF,EACD,MAAO,EAAE,GAAI,GAEjB,MAAME,EAAMH,EAAaC,EAAOhC,GAAQmJ,GAASA,EAAK,KAChDA,EAAOnH,EAAME,GAEnB,GADUiH,IACAnJ,EAAO,CACb,MAAM2I,EAAMQ,EAAK,GACXvG,EAAI+F,EAAIY,YAAYhC,GAC1B,IAAW,IAAP3E,EAKA,OAJA+F,EAAIa,OAAO5G,EAAG,GACK,IAAf+F,EAAI/H,QACJoB,EAAMwH,OAAOtH,EAAK,GAEf,CAACA,EAAKU,EAErB,CACA,MAAO,EAAE,GAAI,EACjB,CA0DwB6G,CAAezK,KAAKgD,MAAOhC,EAAOuH,GAClD,OAAOxB,CAEX,CAQAlF,IAAIb,EAAOuH,GACP,MAAMxB,EA1Hd,SAAwB/D,EAAOhC,EAAOuH,GAClC,IAAKvF,EACD,MAAO,CAAC,EAAG,GAEf,MAAME,EAAMH,EAAaC,EAAOhC,GAAQmJ,GAASA,EAAK,KAChDA,EAAOnH,EAAME,GAEnB,GADUiH,IACAnJ,EAWL,CACD,MAAM2I,EAAM,CAACpB,GAEb,OADAvF,EAAMwH,OAAOtH,EAAK,EAAG,CAAClC,EAAO2I,IACtB,CAACzG,EAAK,EACjB,CAfiB,CACb,MAAMyG,EAAMQ,EAAK,GAEjB,IAAW,IADDR,EAAIW,QAAQ/B,GAGlB,OADAoB,EAAIpF,KAAKgE,GACF,CAACrF,EAAKyG,EAAI/H,OAAS,EAKlC,CAMA,MAAO,EAAE,GAAI,EACjB,CAkGwB8I,CAAe1K,KAAKgD,MAAOhC,EAAOuH,GAClD,OAAOxB,CACX,CAOAwC,MAAMA,GAEF,OAAOvJ,KAAKQ,IAAI+I,EACpB,EC3IG,MAAMoB,UAAqB7B,EAC9BnH,YAAYqB,EAAQ,IAAI,SAAE4H,EAAW,GAAM,CAAC,GACxClB,MAAM1G,GACNhD,KAAK4K,SAAWA,CACpB,CAIA5B,QACIhJ,KAAKgD,MAAQ,EACjB,CAIAiG,QACI,OAAO,IAAI0B,EAAa3K,KAAKgD,MACjC,CAOAxC,IAAIQ,GACA,MAAM6J,EAAO7K,KAAK6K,KAAK7J,GACvBhB,KAAKgD,MAAM6H,GAAQ7K,KAAKgD,MAAM6H,IAAS,GAEvC,OADY7K,KAAKgD,MAAM6H,IAIhB,EACX,CAQAjI,IAAI5B,EAAOuH,GACP,MAAMsC,EAAO7K,KAAK6K,KAAK7J,GACvBhB,KAAKgD,MAAM6H,GAAQ7K,KAAKgD,MAAM6H,IAAS,GACvC,MAAMlB,EAAM3J,KAAKgD,MAAM6H,GACvB,YAAWR,IAAP9B,IACSoB,IAETA,IAC4B,IAArBA,EAAIW,QAAQ/B,EAG3B,CAMAsC,KAAK7J,GACD,OAAqB,IAAjBA,EAAMY,OACC5B,KAAK8K,OAAO9J,EAAM,GAAIA,EAAM,IAEhChB,KAAK+K,OAAO/J,EAAM,GAAIA,EAAM,GAAIA,EAAM,GACjD,CAOA8J,OAAOE,EAAI,EAAGC,EAAI,GAEd,OAAc,SADHC,KAAKC,OAAOH,EAAI,KAAQhL,KAAK4K,UACR,SADwBM,KAAKC,OAAOF,EAAI,KAAQjL,KAAK4K,SAEzF,CAQAG,OAAOC,EAAI,EAAGC,EAAI,EAAGG,EAAI,GAErB,OAAc,SADHF,KAAKC,OAAOH,EAAI,KAAQhL,KAAK4K,UACR,SADwBM,KAAKC,OAAOF,EAAI,KAAQjL,KAAK4K,UACnC,SADmDM,KAAKC,OAAOC,EAAI,KAAQpL,KAAK4K,SAEtI,CAOAxB,OAAOpI,EAAOuH,GACV,MAAMsC,EAAO7K,KAAK6K,KAAK7J,GACvBhB,KAAKgD,MAAM6H,GAAQ7K,KAAKgD,MAAM6H,IAAS,GACvC,MAAMlB,EAAM3J,KAAKgD,MAAM6H,IAChBQ,GAAShI,EAAasG,EAAKpB,GAOlC,OANe,IAAX8C,GACA1B,EAAIa,OAAOa,EAAO,GAEH,IAAf1B,EAAI/H,eACG5B,KAAKgD,MAAM6H,GAEf,CAACA,EAAMQ,EAClB,CAQAxJ,IAAIb,EAAOuH,GACP,MAAMsC,EAAO7K,KAAK6K,KAAK7J,GACvBhB,KAAKgD,MAAM6H,GAAQ7K,KAAKgD,MAAM6H,IAAS,GACvC,MAAMlB,EAAM3J,KAAKgD,MAAM6H,IAChBQ,EAAO9H,GAAQF,EAAasG,EAAKpB,GAIxC,OAHe,IAAX8C,GACA1B,EAAIa,OAAOjH,EAAM,EAAGgF,GAEjB,CAACsC,EAAMQ,EAClB,CAOA9B,MAAMA,GACF,IAAI+B,EAAU,GACd,MAAMlL,EAAIJ,KAAK4K,SAEf,GAAa,IADiB,IAAjBrB,EAAM3H,OAAe,EAAI,GACtB,CACZ,MAAOoJ,EAAGC,GAAK1B,EACf,IAAK,IAAIgC,EAAU,GAAJnL,EAAOmL,EAAS,EAAJnL,EAAQA,EAAGmL,GAAMnL,EACxC,IAAK,IAAIoL,EAAU,GAAJpL,EAAOoL,EAAS,EAAJpL,EAAQA,EAAGoL,GAAMpL,EAAG,CAC3C,MAAMuJ,EAAM3J,KAAKgD,MAAMhD,KAAK8K,OAAOE,EAAIO,EAAIN,EAAIO,SACnCnB,IAARV,IACA2B,EAAUA,EAAQ7J,OAAOkI,GAEjC,CAER,KACK,CACD,MAAOqB,EAAGC,EAAGG,GAAK7B,EAClB,IAAK,IAAIgC,EAAU,GAAJnL,EAAOmL,EAAS,EAAJnL,EAAQA,EAAGmL,GAAMnL,EACxC,IAAK,IAAIoL,EAAU,GAAJpL,EAAOoL,EAAS,EAAJpL,EAAQA,EAAGoL,GAAMpL,EACxC,IAAK,IAAIqL,EAAU,GAAJrL,EAAOqL,EAAS,EAAJrL,EAAQA,EAAGqL,GAAMrL,EAAG,CAC3C,MAAMuJ,EAAM3J,KAAKgD,MAAMhD,KAAK+K,OAAOC,EAAIO,EAAIN,EAAIO,EAAIJ,EAAIK,SAC3CpB,IAARV,IACA2B,EAAUA,EAAQ7J,OAAOkI,GAEjC,CAGZ,CACA,OAAO2B,CACX,ECxJG,MAAMI,EACTC,QACAC,MAOAjK,YAAYgK,EAASE,GACjB7L,KAAK2L,QAAUA,EACf3L,KAAK4L,MAAQC,GAASD,OAAS,CAAC,CACpC,CAWAhG,gBAAgB2C,EAAIpI,EAAK2L,EAAUC,EAAWzF,GAAiB,GAC3D,OAAOtG,KAAKgG,gBAAgBuC,EAAIpI,EAAK2L,EAAUC,EAAWzF,EAC9D,CASArD,SAASsF,EAAIpI,EAAK6L,GACd,MAAMC,EAAcjM,KAAK4L,MAAMrD,KAAMpI,GACrC,OAAI8L,QACOD,EAEJC,CACX,CAOAC,MAAML,GAEF,OADA7L,KAAK4L,MAAQC,GAASD,OAAS,CAAC,EACzB5L,IACX,CAWAgG,gBAAgBuC,EAAIpI,EAAK2L,EAAUK,EAAY7F,GAAiB,GAC5DtG,KAAK4L,MAAMrD,GAAMvI,KAAK4L,MAAMrD,IAAO,CAAC,EACpC,MAAM6D,EAAwBpM,KAAK2L,QAAQtC,MAAMgD,eAAe9D,GAC1D+D,EAAW,GACXC,EAA2BC,IAC7B,GAAIA,QAAqD,CACrDxM,KAAK4L,MAAMrD,GAAIpI,GAAO2L,EACtB,MAAMW,EAAUzM,KAAK2L,QAAQtC,MAAMqD,eAAenE,EAAIpI,EAAK2L,GAI3D,OAHIxF,GAAkBmG,aAAmBE,SACrCL,EAAS/H,KAAKkI,GAEXX,CACX,CACA,IAAIc,EAAa5M,KAAK4L,MAAMrD,GAC5B,MAAMsE,EAAgB,CAAC1M,EAAK2M,EAAMC,EAAOC,KACrC,IAAIC,EAAUD,EACd,IAAKD,EACD,MAAO,CAACD,EAAMG,GAElB,MAAMC,EAAW1I,EAAOuI,EAAM5M,IACxBgN,EAAW3I,EAAOyI,GACxB,GAAIC,IAAaC,EAGb,OAFAL,EAAK3M,GAAO8M,EAEL,CADPH,EAAOA,EAAK3M,GACE8M,GAElB,OAAQE,GACJ,IAAK,SACL,IAAK,SAAU,CACX,MAEMC,EADKH,EADAF,EAAM5M,GAIjB2M,EAAK3M,GAAOiN,EACZ,KACJ,CACA,IAAK,QACDN,EAAOA,EAAK3M,GACZ4M,EAAQA,EAAM5M,GACd,IAAK,IAAIyD,EAAI,EAAGA,EAAIqJ,EAAQrL,OAAQgC,GAAK,EAIrCiJ,EAAcjJ,EAAEyJ,WAAYP,EAAMC,EAAOE,EAAQrJ,IAErD,MACJ,IAAK,SACDkJ,EAAOA,EAAK3M,GACZ4M,EAAQA,EAAM5M,GACd,IAAK,MAAM+E,KAAK+H,EAIZJ,EAAc3H,EAAG4H,EAAMC,EAAOE,EAAQ/H,IAE1C,MAIJ,QACI4H,EAAK3M,GAAO8M,EAIpB,OAFAH,EAAOA,EAAK3M,GACZ8M,EAAUA,EAAQ9M,GACX,CAAC2M,EAAME,EAAQ,GAEzBJ,EAAYd,GAAYe,EAAc1M,EAAKyM,EAAYJ,EAAcV,GACtE,MAAMW,EAAUzM,KAAK2L,QAAQtC,MAAMqD,eAAenE,EAAIpI,EAAK2L,GAI3D,OAHIxF,GAAkBmG,aAAmBE,SACrCL,EAAS/H,KAAKkI,GAEXX,CAAQ,EAEnB,OAAIxF,GAAkB8F,aAAiCO,QAC5C,IAAIA,SAAQ,CAACW,EAASC,KACzBnB,EAAsBoB,MAAMhB,IACxBD,EAAwBC,GACA,IAApBF,EAAS1K,OACF+K,QAAQc,IAAInB,GAAUkB,MAAK,IAAMF,EAAQxB,IAAWyB,GAExDD,EAAQxB,KACjB,IAGHS,EAAwBH,EACnC,ECvIG,MAAMsB,EACTC,SACAC,UACAC,aACAC,cAIAnM,YAAYiM,EAAY,GAAIE,GAAgB,EAAOH,EAAW,GAAIE,GAAe,GAC7E7N,KAAK2N,SAAWA,EAChB3N,KAAK4N,UAAYA,EACjB,IAAK,MAAMG,KAAW/N,KAAK2N,SACvB,IAAK,MAAMK,KAAYhO,KAAK4N,UACxBG,EAAQC,GAGhBhO,KAAK6N,aAAeC,EACpB9N,KAAK8N,cAAgBD,EACrB7N,KAAKiO,SACT,CAIAA,UACQjO,KAAK6N,cAAgB7N,KAAK8N,eAC1B9N,KAAKgJ,OAEb,CAIAA,QACIhJ,KAAK2N,SAAW,GAChB3N,KAAK4N,UAAY,GACjB5N,KAAK6N,cAAe,EACpB7N,KAAK8N,eAAgB,CACzB,CAOAI,KAAKL,GAAe,EAAMC,GAAgB,GACtC9N,KAAK6N,aAAeA,EACpB7N,KAAK8N,cAAgBA,EACrB9N,KAAKiO,SACT,CAQAE,OAAOJ,EAASF,GAAe,GAC3B7N,KAAK2N,SAASpJ,KAAKwJ,GACnB,IAAK,MAAMC,KAAYhO,KAAK4N,UACxBG,EAAQC,GAEZhO,KAAK6N,aAAeA,EACpB7N,KAAKiO,SACT,CAOAG,KAAKpN,EAAO8M,GAAgB,GACxB9N,KAAK4N,UAAUrJ,KAAKvD,GACpB,IAAK,MAAM+M,KAAW/N,KAAK2N,SACvBI,EAAQ/M,GAEZhB,KAAK8N,cAAgBA,EACrB9N,KAAKiO,SACT,CAMAI,cAAcN,GACV,MAAM1C,EAAQrL,KAAK2N,SAASrD,QAAQyD,IACrB,IAAX1C,GACArL,KAAK2N,SAASnD,OAAOa,EAAO,EAEpC,CAMAiD,eAAeN,GACX,MAAM3C,EAAQrL,KAAK4N,UAAUtD,QAAQ0D,IACtB,IAAX3C,GACArL,KAAK4N,UAAUpD,OAAOa,EAAO,EAErC,EChHG,MAAMkD,EACTC,MACA7K,MAMAhC,YAAY8M,EAAS,CAAC,GAClB,MAAQD,MAAOvG,EAAU,IAAOwG,EAChCzO,KAAKwO,MAAQvG,EACbjI,KAAK2D,MAAQF,EAAWwE,EAC5B,CAOAxF,IAAIiM,GACA,GAAIA,EAAQ,CACR,GAAIrO,OAAOM,UAAUC,eAAeC,KAAKb,KAAK2D,MAAO+K,GACjD,OAAO1O,KAAK2D,MAAM+K,GAEjB,CACD,MAAMC,EAAM3O,KAAKwO,MAAM5M,OAGvB,OAFA5B,KAAKwO,MAAMG,GAAOD,EAClB1O,KAAK2D,MAAM+K,GAAUC,EACdA,CACX,CACJ,CACA,OAAO,IACX,CAMAC,SAASC,EAAU,CAAC,GAChB,IAAK,MAAMC,KAAezO,OAAO0O,QAAQF,GACrC7O,KAAKgP,MAAMF,EAEnB,CAOAG,MAAMjL,GACF,IAAIqH,EACAqD,EACJ,cAAe1K,GACX,IAAK,SACDqH,EAAQrH,EACR0K,EAAS1O,KAAKwO,MAAMnD,IAAU,GAC9B,MACJ,IAAK,SACDqD,EAAS1K,EACTqH,EAAQhL,OAAOM,UAAUC,eAAeC,KAAKb,KAAK2D,MAAO+K,GAAU1O,KAAK2D,MAAM+K,IAAW,EAGjG,MAAO,CAACA,EAAQrD,EACpB,CAOAjB,KAAKsE,GACD,OAAO1O,KAAK2D,MAAM+K,EACtB,CAOAlO,IAAI6K,GACA,OAAOrL,KAAKwO,MAAMnD,EACtB,CAMA6D,aACI,OAAOlP,KAAKwO,KAChB,CAMAW,iBACI,OAAOnP,KAAK2D,KAChB,CAMAqL,MAAMF,GACF,MAAOJ,EAAQrD,GAASyD,EACxB9O,KAAKwO,MAAMnD,GAASqD,EACpB1O,KAAK2D,MAAM+K,GAAUrD,CACzB,CAMAa,MAAMxI,EAAQ0L,EAAe,IACzB,GAAI1L,EAAS,EAAG,CACZ,MAAM,OAAE9B,GAAWwN,GACb,MAAEZ,GAAUxO,MACZ,MAAE2D,GAAU3D,KAClB,IAAK,IAAI4D,EAAI,EAAGA,EAAIhC,EAAQgC,IAAK,CAC7B,MAAM8K,EAASU,EAAaxL,GACtByH,EAAQzH,EAAIF,EAClB8K,EAAMnD,GAASqD,EACf/K,EAAM+K,GAAUrD,CACpB,CACJ,MAEIrL,KAAKwO,MAAQY,EACbpP,KAAK2D,MAAQF,EAAW2L,EAEhC,EAWG,SAASC,EAAchE,EAAOM,EAAS2D,GAC1C,GAAqB,iBAAVjE,EAAoB,CAC3B,MAAM,QAAEkE,GAAYD,GACd,UAAEE,GAAcD,EAChBb,EAASc,EAAUnE,EAAOM,EAAS2D,GACzC,IAAKZ,EACD,MAAO,GAEXrD,EAAQqD,CACZ,CACA,OAAOrD,CACX,CASO,SAASoE,EAAkBf,EAAQ/C,EAAS2D,GAC/C,GAAsB,iBAAXZ,EAAqB,CAC5B,MAAM,QAAEa,GAAYD,GACd,UAAEI,GAAcH,EAChBlE,EAAQqE,EAAUhB,EAAQ/C,EAAS2D,GACzC,GAAqB,iBAAVjE,EACP,OAAOA,CAEf,CACA,OAAOqD,CACX,CAUO,SAASiB,EAA0BxP,EAAKa,EAAO2K,EAAS2D,GAC3D,GAAsB,MAAlBnP,EAAIyP,OAAO,GAAY,CACvB,MAAM,QAAEL,GAAYD,GACd,UAAEE,GAAcD,EAChBM,EAAgB7O,IAClB,IAAIO,MAAMC,QAAQR,GAGb,CACD,cAAeA,GACX,IAAK,SAAU,CACX,MAAM0N,EAASc,EAAUxO,EAAO2K,EAAS2D,GACrCZ,IACA1N,EAAQ0N,GAEZ,KACJ,CACA,IAAK,SACD,IAAK,MAAMvO,KAAOa,EACdA,EAAMb,GAAO0P,EAAa7O,EAAMb,IAI5C,OAAOa,CACX,CAlBIA,EAAQA,EAAM8O,IAAID,EAkBtB,EAEJ,OAAOA,EAAa7O,EACxB,CACA,OAAOA,CACX,CAUO,SAAS+O,EAA8B5P,EAAKa,EAAO2K,EAAS2D,GAC/D,GAAsB,MAAlBnP,EAAIyP,OAAO,GAAY,CACvB,MAAM,QAAEL,GAAYD,GACd,UAAEI,GAAcH,EAChBM,EAAgB7O,IAClB,IAAIO,MAAMC,QAAQR,GAGb,CACD,cAAeA,GACX,IAAK,SAAU,CACX,MAAM0N,EAASgB,EAAU1O,EAAO2K,EAAS2D,GACnB,iBAAXZ,IACP1N,EAAQ0N,GAEZ,KACJ,CACA,IAAK,SACD,IAAK,MAAMvO,KAAOa,EACdA,EAAMb,GAAO0P,EAAa7O,EAAMb,IAI5C,OAAOa,CACX,CAlBIA,EAAQA,EAAM8O,IAAID,EAkBtB,EAEJ,OAAOA,EAAa7O,EACxB,CACA,OAAOA,CACX,CCpPO,MAAMgP,EAAsB,CAACC,EAAS5P,SAAW,cAA2B4P,EAQ/ExK,WAAWzB,EAAS2H,EAAS2D,GACzBA,EAAUY,GAAQC,OAAOb,EAAStP,MAClC,MAAM,WAAEoQ,EAAU,sBAAElK,GAA0BoJ,EAC9C,IAAIe,EACAC,EAAO,EACP/O,MAAMC,QAAQwC,IACdqM,EAAQrM,EAAQ,GAChBsM,EAAOtM,EAAQ,IAAM,GAGrBqM,EAAQrM,EAEZ,IAAIuE,EAAK6H,EAAWC,GAAO9H,GAAIoD,GAC3BpD,SAA0C,KAAPA,IAGnCrC,IACAqC,EAAK8G,EAAc9G,EAAIoD,EAAS2D,GACrB,KAAP/G,KAIH8H,GAAO9H,KACR8H,EAAM9H,GAAKA,GAEfoD,EAAQlG,WAAW8C,EAAI8H,EAAOC,EAAMhB,IACxC,CAQAzH,OAAO7D,EAAS2H,EAAS2D,GACrBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,UAAEuQ,EAAS,YAAElK,EAAW,eAAEC,EAAc,SAAEnC,EAAQ,eAAEiC,EAAc,mBAAEoK,GAAuBlB,EACjG,IAAKjJ,EACD,OAEJ,MAAMoK,EAAcpM,IAEhB,IAAK,MAAMC,KAAQD,EACfkM,EAAU,CAACC,EAAmBE,YAAapM,GAC/C,EAEEqM,EAAYhF,EAAQiF,UAAUxK,EAAiBpC,EAAU,KAAMG,GACjEmC,EACAqK,EAAUxC,OAAOsC,GAAY,GAG7BA,EAAWE,EAEnB,CAQAD,YAAY1M,EAAS2H,EAAS2D,GAC1BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C2L,EAAQ+E,YAAY1M,EAASsL,EACjC,CAQAuB,YAAYtI,EAAIoD,EAAS2D,GACrBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,YAAE8G,EAAW,WAAEsJ,EAAU,sBAAElK,GAA0BoJ,EAEvD/G,OADJA,EAAK6H,EAAW7H,EAAIoD,KAC0B,KAAPpD,IAGnCrC,GAEW,MADXqC,EAAK8G,EAAc9G,EAAIoD,EAAS2D,KAKpC3D,EAAQkF,YAAYtI,EAAIzB,GAC5B,CAQAgK,WAAWvI,EAAIoD,EAAS2D,GACpBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,YAAE8G,EAAW,WAAEsJ,EAAU,sBAAElK,GAA0BoJ,EAEvD/G,OADJA,EAAK6H,EAAW7H,EAAIoD,KAC0B,KAAPpD,IAGnCrC,GAEW,MADXqC,EAAK8G,EAAc9G,EAAIoD,EAAS2D,KAKpC3D,EAAQmF,WAAWvI,EAAIzB,GAC3B,GAMG,MAAMiK,UAAqBf,MAElC,MAAMgB,EAAmB,IAAID,EAIhBxB,GAAU,CAInB9J,WAAYuL,EAAiBvL,WAI7BoC,OAAQmJ,EAAiBnJ,OAIzB6I,YAAaM,EAAiBN,YAI9BG,YAAaG,EAAiBH,YAI9BC,WAAYE,EAAiBF,YAEjC,MCtJaG,GAA0B,CAAChB,EAAS5P,SAAW,cAA+B4P,EAQvFrK,gBAAgB5B,EAAS2H,EAAS2D,GAC9BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,sBAAEkG,EAAqB,MAAEgB,EAAK,UAAER,GAAc4I,EACpD,IAAK/G,EAAIpI,EAAKa,GAASgD,EACnBsM,EAAO5J,EAAY1C,EAAQ,GAAK,EACpC,GAAIuE,SAA0C,KAAPA,GAAnCA,MACApI,GAA6C,KAARA,EADzC,CAIA,GAAI+F,EAAuB,CAEvB,GADAqC,EAAK8G,EAAc9G,EAAIoD,EAAS2D,IAC3B/G,EACD,OAGJ,GADApI,EAAMkP,EAAclP,EAAKwL,EAAS2D,IAC7BnP,EACD,OAEJ,MAAM8G,EAAOC,EAAM/G,GACnB,GAAI8G,IAASA,IAASiK,QAAUjK,EAAK,KAAOiK,UACxClQ,EAAQ2O,EAA0BxP,EAAKa,EAAO2K,EAAS2D,IAClDtO,GACD,MAGZ,CACA,OAAO2K,EAAQ/F,gBAAgB2C,EAAIpI,EAAKa,EAAOsP,EAAMhB,EAlBrD,CAmBJ,CAQAvH,WAAW/D,EAAS2H,EAAS2D,GACzBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,UAAEuQ,EAAS,YAAElK,EAAW,eAAEC,EAAc,SAAEnC,EAAQ,eAAEiC,EAAc,mBAAEoK,GAAuBlB,EACjG,IAAKjJ,EACD,OAEJ,MAAM8K,EAAkB9M,IAGpB,IAAK,MAAMC,KAAQD,EACfkM,EAAU,CACNC,EAAmBY,gBACnB9M,GAER,EAEE+M,EAAgB1F,EAAQ2F,cAAclL,EAAiBpC,EAAU,KAAMG,GACzEmC,EACA+K,EAAclD,OAAOgD,GAAgB,GAGrCA,EAAeE,EAEvB,CAQAD,gBAAgBpN,EAAS2H,EAAS2D,GAC9BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C2L,EAAQyF,gBAAgBpN,EAASsL,EACrC,CAQAvJ,gBAAgB/B,EAAS2H,EAAS2D,GAC9BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,sBAAEkG,GAA0BoJ,EAClC,IAAK/G,EAAIpI,GAAO6D,EAChB,GAAIuE,SAA0C,KAAPA,GAAnCA,MACApI,GAA6C,KAARA,EADzC,CAIA,GAAI+F,EAAuB,CAEvB,GADAqC,EAAK8G,EAAc9G,EAAIoD,EAAS2D,IAC3B/G,EACD,OAGJ,GADApI,EAAMkP,EAAclP,EAAKwL,EAAS2D,IAC7BnP,EACD,MAER,CACAwL,EAAQ5F,gBAAgBwC,EAAIpI,EAAKmP,EAXjC,CAYJ,CAQAtJ,gBAAgBhC,EAAS2H,EAAS2D,GAC9BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,sBAAEkG,EAAqB,MAAEgB,EAAK,UAAER,GAAc4I,EACpD,IAAK/G,EAAIpI,EAAKa,GAASgD,EACnBsM,EAAO5J,EAAY1C,EAAQ,GAAK,EACpC,GAAIuE,SAA0C,KAAPA,GAAnCA,MACApI,GAA6C,KAARA,EADzC,CAIA,GAAI+F,EAAuB,CAEvB,GADAqC,EAAK8G,EAAc9G,EAAIoD,EAAS2D,IAC3B/G,EACD,OAGJ,GADApI,EAAMkP,EAAclP,EAAKwL,EAAS2D,IAC7BnP,EACD,OAEJ,MAAM8G,EAAOC,EAAM/G,GACnB,GAAI8G,IAASA,IAASiK,QAAUjK,EAAK,KAAOiK,UACxClQ,EAAQ2O,EAA0BxP,EAAKa,EAAO2K,EAAS2D,IAClDtO,GACD,MAGZ,CACA,OAAO2K,EAAQ3F,gBAAgBuC,EAAIpI,EAAKa,EAAOsP,EAAMhB,EAlBrD,CAmBJ,GAMG,MAAMiC,WAAyBN,OAEtC,MAAMO,GAAuB,IAAID,GAIpB,GAAU,CAInB3L,gBAAiB4L,GAAqB5L,gBAItCmC,WAAYyJ,GAAqBzJ,WAIjCqJ,gBAAiBI,GAAqBJ,gBAItCrL,gBAAiByL,GAAqBzL,gBAItCC,gBAAiBwL,GAAqBxL,iBAE1C,MCrLayL,GAAa,IAAIC,IAAI,CAI9B,CAAC,MAAOR,QACR,CAAC,MAAOS,QACR,CAAC,OAAQC,SACT,CAAC,MAAOF,KACR,CAAC,MAAOlP,KACR,CAAC,MAAOjB,SAECsQ,GAAa,IAAIH,IAAI,CAC9B,CAAC,KAAMI,WACP,CAAC,MAAOC,YACR,CAAC,OAAQC,mBACT,CAAC,MAAOC,YACR,CAAC,OAAQC,aACT,CAAC,MAAOC,YACR,CAAC,OAAQC,aACT,CAAC,MAAOC,cACR,CAAC,MAAOC,gBCHCC,GAAW,CACpBC,OAAQtI,EACRuI,QAAS9H,GAEN,SAAS+H,GAAmBC,EAAQ,CAAC,EAAGC,EAAU,CAAC,EAAGtD,EAAU,CAAC,GACpE,MAAM,OAAEzH,EAAS,GAAE,SAAEC,EAAW,GAAE,WAAEC,EAAa,CAAC,EAAC,OAAEC,EAAS,CAAC,GAAM4K,GAAW,CAAC,GAC3E,MAAE1L,EAAQ,CAAC,EAAC,QAAEH,EAAU,CAAC,GAE1BuI,EACLqD,EAAM9K,OAASA,GAAU,GACzB8K,EAAM7K,SAAWA,GAAY,GAC7B6K,EAAM5K,WAAaA,GAAc,CAAC,EAClC4K,EAAM3K,OAASA,GAAU,CAAC,EAC1B2K,EAAMzL,MAAQA,EACdyL,EAAME,UAAY,CAAC,EACnB,IAAK,IAAI1S,KAAO+G,EAAO,CACnB,IAAI4L,EAAW5L,EAAM/G,GACjBoB,MAAMC,QAAQsR,GACdA,EAAWrB,GAAWjR,IAAIsS,EAAS,KAAOjB,GAAWrR,IAAIsS,EAAS,IAEzC,iBAAbA,IACZA,EAAWrB,GAAWjR,IAAIsS,IAAajB,GAAWrR,IAAIsS,IAElC,mBAAbA,GACHA,IACAH,EAAME,UAAU1S,GAAO2S,EAGnC,CACAH,EAAMI,gBAAkB,IAAItJ,EAC5BkJ,EAAM5L,QAAU,CAAC,EACjB,IAAK,IAAI5G,KAAO4G,EAAS,CACrB,MAAM,KAAEE,GAASF,EAAQ5G,GACnB6S,EAAYT,GAAStL,GACvB+L,IACAL,EAAM5L,QAAQ5G,GAAO,CACjB0H,OAAQ,IAAImL,EAAU,GAAIjM,EAAQ5G,IAClC2H,SAAU,IAAIkL,EAAU,GAAIjM,EAAQ5G,KAGhD,CACA,OAAOwS,CACX,CAaO,MAAMM,GAOTtR,YAAYiR,EAAU,CAAC,EAAGtD,EAAU,CAAC,GACjCoD,GAAmB1S,KAAM4S,EAAStD,EACtC,CAOA4D,aAAa3K,GACT,MAAMV,EAAS7H,KAAK6H,OACpB,OAAO7H,KAAKmT,UAAUtL,EAAQU,EAClC,CAOA6K,iBAAiB7K,EAAIpI,GACjB,MAAM4L,EAAY/L,KAAK+H,WAAWQ,GAAIpI,UAC/BH,KAAK+H,WAAWQ,GAAIpI,GAC3BH,KAAKqT,sBAAsB9K,EAAIpI,EAAK4L,EACxC,CAOAuH,cAAc/K,GACV,MAAMT,EAAW9H,KAAK8H,SACtB,OAAO9H,KAAKmT,UAAUrL,EAAUS,EACpC,CAQA4K,UAAUI,EAAMhL,GACZ,MAAO8C,GAAShI,EAAakQ,EAAMhL,GACnC,OAAe,IAAX8C,IACAkI,EAAK/I,OAAOa,EAAO,IACZ,EAGf,CAOAgB,eAAe9D,GAEX,OADAvI,KAAK+H,WAAWQ,GAAMvI,KAAK+H,WAAWQ,IAAO,CAAC,EACvCvI,KAAK+H,WAAWQ,EAC3B,CAQAiL,cAAcjL,EAAIpI,GAEd,OADAH,KAAK+H,WAAWQ,GAAMvI,KAAK+H,WAAWQ,IAAO,CAAC,EACvCvI,KAAK+H,WAAWQ,GAAIpI,EAC/B,CAOAsT,WAAWlL,GACP,OAAOvI,KAAKgI,OAAOO,EACvB,CAQAmL,UAAUnL,EAAI8C,GACVrL,KAAKgI,OAAOO,GAAMvI,KAAKgI,OAAOO,IAAO,GACrC,MAAM8H,EAAQrQ,KAAKgI,OAAOO,GAAI8C,GAC9B,OAAI9J,MAAMC,QAAQ6O,GACP,CAAC,IAAKA,EAAM,GAAI9H,MAAM8H,EAAM,IAEhC,IAAKA,EAAO9H,KACvB,CAQAqI,UAAUrH,EAAQ,KAAMpF,EAAWC,KAC/B,GAAc,OAAVmF,EAAgB,CAChB,IAAI+B,EAAU,CAAC,EACf,IAAK,IAAInL,KAAOoJ,EAAO,CACnB,MAAM8B,EAAQrL,KAAK+G,QAAQ5G,GACvBkL,GACeA,EAAMxD,OAAO0B,MAAMA,EAAMpJ,IACjCwT,SAASpL,IACZ+C,EAAQ/C,IAAM,CAAI,GAG9B,CAEA,OAAOtE,EADK5D,OAAO+B,KAAKkJ,GACHnH,EACzB,CACA,OAAOF,EAASjE,KAAK6H,OAAQ1D,EACjC,CAQAmN,cAAc/H,EAAQ,KAAMpF,EAAWC,KACnC,IAAIqK,EAASzO,KAAK+H,WAClB,GAAc,OAAVwB,EAAgB,CAChB,MAAM+B,EAAU,CAAC,EACjB,IAAK,IAAInL,KAAOoJ,EACZ+B,EAAQnL,GAAOH,KAAK+H,WAAW5H,GAEnCsO,EAASnD,CACb,CAGA,OADcrH,EADF5D,OAAO+B,KAAKqM,GACItK,GACf2L,KAAKxL,IACd,MAAMyD,EAAa,CAAC,EACpB,IAAK,IAAIQ,KAAMjE,EACXyD,EAAWQ,GAAMkG,EAAOlG,GAE5B,OAAOR,CAAU,GAEzB,CAQA6L,YAAYrK,EAAQ,KAAMpF,EAAWC,KACjC,GAAc,OAAVmF,EAAgB,CAChB,IAAI+B,EAAU,CAAC,EACf,IAAK,IAAInL,KAAOoJ,EAAO,CACnB,MAAM8B,EAAQrL,KAAK+G,QAAQ5G,GACvBkL,GACeA,EAAMvD,SAASyB,MAAMA,EAAMpJ,IACnCwT,SAASpL,IACZ+C,EAAQ/C,IAAM,CAAI,GAG9B,CAEA,OAAOtE,EADK5D,OAAO+B,KAAKkJ,GACHnH,EACzB,CACA,OAAOF,EAASjE,KAAK8H,SAAU3D,EACnC,CAMA0P,UAAUtK,EAAQ,KAAMpF,EAAWC,KAC/B,IAAIqK,EAASzO,KAAKgI,OAClB,GAAc,OAAVuB,EAAgB,CAChB,MAAM+B,EAAU,CAAC,EACjB,IAAK,IAAInL,KAAOoJ,EACZ+B,EAAQnL,GAAOH,KAAKgI,OAAO7H,GAE/BsO,EAASnD,CACb,CAGA,OADcrH,EADF5D,OAAO+B,KAAKqM,GACItK,GACf2L,KAAKxL,IACd,MAAM0D,EAAS,CAAC,EAChB,IAAK,IAAIO,KAAMjE,EACX0D,EAAOO,GAAMkG,EAAOlG,GAExB,OAAOP,CAAM,GAErB,CAOA8L,QAAQvL,GAEJ,OAA+B,IADhBvI,KAAK6H,OACNyC,QAAQ/B,EAC1B,CAOAwL,SAASxL,GAEL,OAAiC,IADhBvI,KAAK8H,SACNwC,QAAQ/B,EAC5B,CAOAyL,UAAUnM,GAEN,OADA7H,KAAK6H,OAASA,EACPA,CACX,CAOAoM,cAAclM,GAEV,OADA/H,KAAK+H,WAAaA,EACXA,CACX,CAOAmM,YAAYpM,GAER,OADA9H,KAAK8H,SAAWA,EACTA,CACX,CAOAqM,UAAUnM,GAEN,OADAhI,KAAKgI,OAASA,EACPA,CACX,CAOAoM,WAAW7L,GACP,MAAMV,EAAS7H,KAAK6H,OACpB,OAAO7H,KAAKqU,QAAQxM,EAAQU,EAChC,CAQAmE,eAAenE,EAAIpI,EAAKa,GACpB,MAAM+K,EAAY/L,KAAK+H,WAAWQ,GAAIpI,GACtCH,KAAK+H,WAAWQ,GAAIpI,GAAOa,EAC3BhB,KAAKsU,sBAAsB/L,EAAIpI,EAAK4L,EAAW/K,EACnD,CAOAuT,YAAYhM,GACR,MAAMT,EAAW9H,KAAK8H,SACtB,OAAO9H,KAAKqU,QAAQvM,EAAUS,EAClC,CAQA8L,QAAQd,EAAMhL,GACV,MAAO8C,EAAO9H,GAAQF,EAAakQ,EAAMhL,GACzC,OAAe,IAAX8C,IACAkI,EAAK/I,OAAOjH,EAAM,EAAGgF,IACd,EAGf,CAQAiM,WAAWjM,EAAI8H,EAAOC,EAAO,GACzB,MAAMtI,EAAShI,KAAKgI,OACpBA,EAAOO,GAAMP,EAAOO,IAAO,GAC3B,MAAM8C,EAAQrD,EAAOO,GAAI3G,OAKzB,OAJIyO,EAAM9H,KAAOA,UACN8H,EAAM9H,GAEjBP,EAAOO,GAAIhE,KAAK+L,EAAO,CAACD,EAAOC,GAAQD,GAChChF,CACX,CAOAoJ,gBAAgBlL,GACZ,OAAOvJ,KAAK+S,gBAAgBxJ,MAAMA,EACtC,CASA8J,sBAAsB9K,EAAIpI,EAAK4L,GAE3B,GADA/L,KAAK+S,gBAAgB3J,OAAOb,EAAIpI,GAC5BH,KAAK+G,QAAQ5G,GAAM,CACnB,MAAMkL,EAAQrL,KAAK+G,QAAQ5G,GACvBH,KAAK8T,QAAQvL,GACb8C,EAAMxD,OAAOuB,OAAOb,EAAIwD,GAGxBV,EAAMvD,SAASsB,OAAOb,EAAIwD,EAElC,CACJ,CAUAuI,sBAAsB/L,EAAIpI,EAAK4L,EAAW/K,GAEtC,GADAhB,KAAK+S,gBAAgBlR,IAAI0G,EAAIpI,GACzBH,KAAK+G,QAAQ5G,GAAM,CACnB,MAAMkL,EAAQrL,KAAK+G,QAAQ5G,GACvBH,KAAK8T,QAAQvL,GACb8C,EAAMxD,OAAOwB,MAAMd,EAAIwD,EAAW/K,GAGlCqK,EAAMvD,SAASuB,MAAMd,EAAIwD,EAAW/K,EAE5C,CACJ,EChbG0T,eAAeC,GAAQhJ,EAAS2D,EAASgB,EAAOrP,KACnDqO,EAAUA,aAAmBY,GAAUZ,EAAU,IAAIY,GAAQZ,GAC7D,MAAM,UAAEiB,EAAS,mBAAEC,EAAkB,sBAAEtK,EAAqB,eAAEC,EAAc,UAAEO,EAAS,SAAEF,EAAQ,oBAAEC,EAAmB,eAAEH,EAAc,MAAEY,EAAK,gBAAE0N,EAAe,cAAEC,GAAkBvF,GAC5K,QAAEpH,EAAO,UAAEC,EAAS,KAAEP,EAAI,KAAEX,EAAI,UAAE6N,GAAcD,EACtD,IAAKlJ,EAAQoJ,QACT,MAAO,GAKX,MAAMC,EAAQ,GAId,IAAIC,EAAa,GACjB,MAAM,QAAEC,EAAU,CAAC,EAAC,QAAEC,EAAU,CAAC,EAAC,QAAElN,EAAU,GAAE,QAAEmN,EAAU,CAAC,GAAMzJ,EAAQoJ,QACrE1L,EAAQsC,EAAQtC,MAMhBgM,EAActR,IACZmE,GAAW+M,EAAWrT,SACtBoT,EAAMzQ,KAAK,CAACR,KAAWkR,IACvBA,EAAa,GACjB,EAQEK,EAAeZ,MAAO3Q,EAAQC,KAC5BkE,GAEA+M,EAAaA,EAAWxT,OAAOuC,GAC3BiR,EAAWrT,QAAUuG,GACrBkN,EAAWtR,KAIXmC,IACAnC,EAAS0L,EAAkB1L,EAAQ4H,EAAS2D,UAE1CiB,EAAU,CAACxM,EAAQC,GAAUiD,GACvC,EAQEsO,EAAgB7G,IACdxI,IACAwI,EAASe,EAAkBf,EAAQ/C,EAAS2D,IAEzCZ,GAEL8G,EAAmBd,MAAOe,EAAoB,CAAC,EAAGC,KACpD,MAAMC,EAASlP,EAAsB,CAAC,EAAI,KAC1C,IAAK,MAAM8B,KAAOkN,GAAqB,CAAC,EAAI,CAExC,GAAI1N,OADezB,QAAuB+C,EAAMgD,eAAe9D,GAAMc,EAAMgD,eAAe9D,IAEtF,MAEJ,MAAMqN,EAAoBH,EAAoBA,EAAkBlN,GAAM,CAAC,EACvE,IAAK,MAAMpI,KAAQyV,GAAqB,CAAC,EAAI,CACzC,GAAId,IAAcA,EAAU3U,GACxB,MAEJ,MAAM8G,EAAOC,EAAM/G,IAAQ,KACrB0V,EAAO5O,EAAO4K,GAAWrR,IAAIe,MAAMC,QAAQyF,GAAQA,EAAK,GAAKA,GAAQ,KAC3E,IAAI6O,EAAQ,KACRH,IACAG,EAAQH,EAAOxV,GAAOwV,EAAOxV,IAAQ,CACjCA,MACAwJ,IAAKzD,EAAwB,IAAIkM,YAAY,GAAK,GAClD2D,QAAQ,EACRC,OAAQH,EAAO,IAAIA,EAAK,GAAK,GAC7BI,MAAO,IAAI7D,YAAY,KAG/B,IAAIpR,EAAQsF,QAAuB+C,EAAMmK,cAAcjL,EAAIpI,GAAOkJ,EAAMmK,cAAcjL,EAAIpI,GAEtFqG,GAAYmF,EAAQE,SAAsB,YAAV6J,IAChC1U,EAAQ2K,EAAQE,QAAQ5I,SAASsF,EAAIpI,EAAKa,IAE1CkF,IACAlF,EAAQ+O,EAA8B5P,EAAKa,EAAO2K,EAAS2D,IAE/D,MAAM4G,EAAMX,EAAahN,GACnB4N,EAAOZ,EAAapV,GAC1B,GAAIwV,EAAQ,CACRG,EAAMnM,IAAMzD,EACN9E,EAAiB0U,EAAMnM,IAAK,CAACuM,IAC7BJ,EAAMnM,IAAIlI,OAAO,CAAC8G,IACpB2N,IAAQ3N,IACRuN,EAAMC,QAAS,GAEnBD,EAAME,OAASH,EACTzU,EAAiB0U,EAAME,OAAQpB,EAAgB5T,EAAOkG,EAAO/G,IAC7D2V,EAAME,OAAOvU,OAAOmT,EAAgB5T,EAAOkG,EAAO/G,IACpDuG,IACAoP,EAAMG,MAAQ7U,EAAiB0U,EAAMG,MAAO,CAACzP,GAAY8J,EAAOA,KAEpE,QACJ,CACA,MAAMtM,EAAU,CAACkS,EAAKC,EAAMnV,GACxB0F,GACA1C,EAAQO,KAAKiC,GAAY8J,EAAOA,GAEhC9J,QACM8O,EAAa9E,EAAmB5K,gBAAiB5B,SAGjDsR,EAAa9E,EAAmBxK,gBAAiBhC,EAE/D,CAEJ,CACA,GAAI2R,EACA,IAAK,MAAMxV,KAAOwV,EAAQ,CACtB,MAAMG,EAAQH,EAAOxV,GACfiW,EAAYlQ,GAAyB4P,EAAMC,OAAS,IAAI3D,YAAY0D,EAAMnM,KAAOmM,EAAMnM,IACvF1C,EAAOC,EAAM/G,IAAQ,KACrB0V,EAAO5O,EAAO4K,GAAWrR,IAAIe,MAAMC,QAAQyF,GAAQA,EAAK,GAAKA,GAAQ,KACrEoP,EAAeR,EAAO,IAAIA,EAAKC,EAAME,QAAUF,EAAME,OAC3D,IAAIpS,EAAI,EACR,MAAM8D,EAAO0O,EAAUxU,OACvB,KAAOgC,EAAI8D,EAAM9D,GAAKuE,EAAW,CAC7B,MAAMnE,EAAU,CACZoS,EAAU1N,MAAM9E,EAAGA,EAAIuE,GACvB2N,EAAM3V,IACNkW,EAAa3N,MAAM9E,EAAGA,EAAIuE,IAE9B,GAAIzB,EAAW,CACX,MAAM4P,EAAc,IAAIlE,YAAY0D,EAAMG,MAAMvN,MAAM9E,EAAGA,EAAIuE,IAC7DnE,EAAQO,KAAK+R,EACjB,CACI9P,QACM8O,EAAa9E,EAAmB5K,gBAAiB5B,SAGjDsR,EAAa9E,EAAmBxK,gBAAiBhC,EAE/D,CACJ,CAEJqR,EAAW7O,EAAWgK,EAAmB5K,gBAAkB4K,EAAmBxK,gBAAgB,EAOlG,IAAK4B,IAASA,EAAKE,SAAU,CACzB,IAAK,MAAM3H,KAAO+U,EAAQpN,UAAY,GAAI,CACtC,MAAMqO,EAAOZ,EAAapV,SACpBmV,EAAa9E,EAAmB+F,aAAcJ,EACxD,CACAd,EAAW7E,EAAmB+F,cAC9BrB,EAAQpN,SAAW,EACvB,CAMA,IAAKF,IAASA,EAAKC,OAAQ,CACvB,IAAK,MAAMU,KAAO2M,EAAQrN,QAAU,CAAC,EAAI,CACrC,MAAMqO,EAAMX,EAAahN,SACnB+M,EAAa9E,EAAmBM,WAAYoF,EACtD,CACAb,EAAW7E,EAAmBM,YAC9BoE,EAAQrN,OAAS,CAAC,CACtB,CAMA,IAAKD,IAASA,EAAKE,SAAU,CACzB,IAAK,MAAM3H,KAAOgV,EAAQrN,UAAY,GAAI,CACtC,MAAMqO,EAAOZ,EAAapV,SACpBmV,EAAa9E,EAAmBgG,aAAcL,EACxD,CACAd,EAAW7E,EAAmBgG,cAC9BrB,EAAQrN,SAAW,EACvB,CAMA,IAAKF,IAASA,EAAKC,OAAQ,CACvB,IAAK,MAAMU,KAAO4M,EAAQtN,QAAU,CAAC,EAAI,CACrC,MAAMqO,EAAMX,EAAahN,SACnB+M,EAAa9E,EAAmBK,YAAaqF,EACvD,CACAb,EAAW7E,EAAmBK,aAC9BsE,EAAQtN,OAAS,CAAC,CACtB,CAMA,IAAKD,IAASA,EAAKG,WAAY,CAC3B,IAAK,MAAMQ,KAAO4M,EAAQpN,YAAc,CAAC,EAAI,CACzC,MAAMA,EAAaoN,GAASpN,WAAaoN,EAAQpN,WAAWQ,GAAM,KAClE,IAAKR,EACD,MAEJ,MAAMmO,EAAMX,EAAahN,GACzB,IAAK,MAAMpI,KAAO4H,EAAY,CAC1B,GAAI+M,IAAcA,EAAU3U,GACxB,MAEJ,MACM6D,EAAU,CAACkS,EADJX,EAAapV,UAEpBmV,EAAa9E,EAAmBzK,gBAAiB/B,EAC3D,CAEJ,CACAqR,EAAW7E,EAAmBzK,iBAC9BoP,EAAQpN,WAAa,CAAC,CAC1B,CAMA,IAAKH,IAASA,EAAKG,WAAY,CAC3B,MAAM0E,EAAU+I,EAAiBN,EAAQnN,WAAY,WACrDmN,EAAQnN,WAAa,CAAC,QAChB0E,CACV,CAMA,IAAK7E,IAASA,EAAKG,WAAY,CAC3B,MAAM0E,EAAU+I,EAAiBJ,EAAQrN,WAAY,WACrDqN,EAAQrN,WAAa,CAAC,QAChB0E,CACV,CAMA,IAAK7E,IAASA,EAAKI,OAAQ,CACvB,IAAK,MAAMO,KAAO2M,EAAQlN,QAAU,CAAC,EAAI,CAErC,MAAMyO,EAAgBvB,GAASlN,OAAUkN,EAAQlN,OAAOO,IAAO,GAAM,GACrE,IAAK,IAAI3E,EAAI,EAAGA,EAAI6S,EAAc7U,OAAQgC,GAAK,EAAG,CAC9C,MAAMyH,EAAQoL,EAAc7S,GACtBI,EAAUsC,QAAuB+C,EAAMqK,UAAUnL,EAAI8C,GAAShC,EAAMqK,UAAUnL,EAAI8C,GAClFqL,EAAUnV,MAAMC,QAAQwC,GACxBqM,EAAQqG,EAAU1S,EAAQ,GAAKA,EAC/B2S,EAAQD,EAAU1S,EAAQ,GAAKsM,QAC/BgF,EAAa9E,EAAmB/K,WAAYiR,GAAWvQ,EAAiB,CAACkK,EAAOsG,GAAStG,EACnG,CAEJ,CACAgF,EAAW7E,EAAmB/K,YAC9ByP,EAAQlN,OAAS,CAAC,CACtB,CAMA,IAAKJ,IAASA,EAAKK,QAAS,CACxB,IAAK,MAAM2O,KAAY3O,EAAS,CAC5B,GAAIC,EACA+M,EAAW1Q,KAAKqS,OAEf,CACD,MAAM9S,EAAU,CAAC0M,EAAmBqG,YAAaD,SAC3CrG,EAAUzM,EAASmD,EAC7B,CACIgO,EAAWrT,QAAUuG,GAAa8M,EAAWrT,SAC7CoT,EAAM8B,QAAQ,CAACtG,EAAmBqG,aAAapV,OAAOwT,IACtDA,EAAa,GAErB,CACI/M,GAAW+M,EAAWrT,SACtBoT,EAAM8B,QAAQ,CAACtG,EAAmBqG,aAAapV,OAAOwT,IACtDA,EAAa,IAEjBtJ,EAAQoJ,QAAQ9M,QAAU,EAC9B,CAMA,GAAIC,GAAW8M,EAAMpT,OACjB,IAAK,IAAIgC,EAAI,EAAGA,EAAIoR,EAAMpT,OAAQgC,GAAK,EAAG,CACtC,MAAMmT,EAAa/B,EAAMpR,GACrBmT,SACMxG,EAAU,CAACC,EAAmBwE,MAAO+B,GAOnD,CAEJ,OAAO/B,CACX,CC5TO,SAASgC,GAAgBjT,EAAQkT,GAIpC,OAHIA,GAAoC,iBAAXlT,GAAuBkT,EAAelT,KAC/DA,EAASkT,EAAelT,IAErBA,CACX,CAOO,SAASmT,GAAiBvL,EAAS2D,GACtCA,EAAUA,aAAmBY,GAAUZ,EAAU,IAAIY,GAAQZ,GAC7D,MAAM,QAAEC,EAAO,eAAE0H,GAAmB3H,EACpC,OAAQvL,IACJA,EAASiT,GAAgBjT,EAAQkT,GACjC,MAAMlJ,EAAW/J,IACTuL,EAAQxL,IACRwL,EAAQxL,GAAQC,EAAS2H,EAAS2D,EACtC,EAIJ,OADAvB,EAAQhK,OAASA,EACVgK,CAAO,CAEtB,CAQO,SAASoJ,GAAWrT,EAAS6H,EAAS2D,GAEzC,MAAM8H,EAAgBF,GAAiBvL,EADvC2D,EAAUA,aAAmBY,GAAUZ,EAAU,IAAIY,GAAQZ,IAEzD/N,MAAMC,QAAQsC,GACdsT,EAActT,EAAQ,GAAtBsT,CAA0BtT,EAAQ,IAE7BA,GACLsT,EAActT,EAAQC,OAAtBqT,CAA8BtT,EAAQE,QAE9C,CACO,MAAM+J,GAAUsJ,GAQhB,SAASA,GAAYvT,EAAS6H,EAAS2D,GAC1CA,EAAUA,aAAmBY,GAAUZ,EAAU,IAAIY,GAAQZ,GAC7D,MAAM,wBAAEgI,EAAuB,UAAE5Q,EAAS,eAAEP,GAAmBmJ,EACzD8H,EAAgBF,GAAiBvL,EAAS2D,GAC1CiI,EAAW,CAACvT,EAAS+J,EAASrK,EAAS,KAEzC,MAAMK,EAASgK,EAAQhK,OACvB,IAAIyT,EAAcF,EAAwBvT,IAAW,EACjDyT,GAAsC,iBAAhBA,IAElBA,EADAA,EAAY3R,SAAWa,EACT8Q,EAAY3R,QAErB2R,EAAY7R,UAAYQ,EACfqR,EAAY7R,SAGZ6R,EAAY9R,SAGlC,IAAK,IAAI9B,EAAIF,EAAQE,EAAII,EAAQpC,OAAQgC,GAAK4T,EAEtB,IAAhBA,EACAzJ,EAAQ/J,EAAQJ,GAAI+H,EAAS2D,GAExBgI,GACLvJ,EAAQ/J,EAAQ0E,MAAM9E,EAAGA,EAAI4T,GAAc7L,EAAS2D,EAK5D,EAEJ,GAAI/N,MAAMC,QAAQsC,GAEdyT,EAASzT,EADOsT,EAActT,EAAQ,IACX,QAE1B,GAAIA,EAAS,CACd,MAAMiK,EAAUqJ,EAActT,EAAQC,QACtCwT,EAASzT,EAAQE,QAAS+J,EAC9B,CACJ,CAIO,MAAM0J,GACT9L,QACA2D,QASA3N,YAAYgK,EAAS2D,EAASC,EAASmI,EAAWzE,IAC9CjT,KAAKsP,QAAUY,GAAQC,OAAOb,EAASC,GACvCvP,KAAK2L,QAAUgM,GAAQxH,OAAOxE,EAAS2D,EAASoI,EACpD,CAMAE,IAAI9T,EAAS+T,GACT,OAAOV,GAAWrT,EAAS9D,KAAK2L,QAASkM,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QACvG,CAMAyI,KAAKjU,EAAS+T,GACV,OAAOR,GAAYvT,EAAS9D,KAAK2L,QAASkM,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QACxG,CAIA4H,mBACI,OAAOA,GAAiBlX,KAAK2L,QAAS3L,KAAKsP,QAC/C,CAMA0H,gBAAgBjT,GACZ,OAAOiT,GAAgBjT,EAAQ/D,KAAKsP,QAAQ2H,eAChD,CAQAtC,QAAQkD,EAAevH,EAAOrP,KAC1B,OAAO0T,GAAQ3U,KAAK2L,QAASkM,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QAASgB,EACpG,CAOAQ,WAAWvI,EAAIsP,GACX,OAAO7X,KAAK2L,QAAQmF,WAAWvI,EAAIsP,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QACjG,CAOAuB,YAAYtI,EAAIsP,GACZ,OAAO7X,KAAK2L,QAAQkF,YAAYtI,EAAIsP,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QAClG,CASA7J,WAAW8C,EAAI8H,EAAOC,EAAOrP,IAAO4W,GAChC,OAAO7X,KAAK2L,QAAQlG,WAAW8C,EAAI8H,EAAOC,EAAMuH,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QAC9G,CAOAiH,aAAahO,EAAIsP,GACb,OAAO7X,KAAK2L,QAAQ4K,aAAahO,EAAIsP,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QACnG,CAOAkH,aAAajO,EAAIsP,GACb,OAAO7X,KAAK2L,QAAQ6K,aAAajO,EAAIsP,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QACnG,CAUAtJ,gBAAgBuC,EAAIpI,EAAKa,EAAOsP,EAAOrP,IAAO4W,GAC1C,OAAO7X,KAAK2L,QAAQ3F,gBAAgBuC,EAAIpI,EAAKa,EAAOsP,EAAMuH,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QACxH,CAUA1J,gBAAgB2C,EAAIpI,EAAKa,EAAOsP,EAAOrP,IAAO4W,GAC1C,OAAO7X,KAAK2L,QAAQ/F,gBAAgB2C,EAAIpI,EAAKa,EAAOsP,EAAMuH,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QACxH,CAQAvJ,gBAAgBwC,EAAIpI,EAAK0X,GACrB,OAAO7X,KAAK2L,QAAQ5F,gBAAgBwC,EAAIpI,EAAK0X,EAAgB7X,KAAKsP,QAAQwI,OAAOD,GAAiB7X,KAAKsP,QAC3G,CAOAmF,gBAAgBlL,GACZ,OAAOvJ,KAAK2L,QAAQtC,MAAMoL,gBAAgBlL,EAC9C,EAEJ,YCtPayO,GAAqB,CAAC/H,EAAS5P,SAAW,cAA0B4P,EAQ7E+E,MAAMhR,EAAS2H,EAAS2D,GAEpB+H,GAAYrT,EAAS2H,EADrB2D,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAEhD,GAKG,MAAMiY,WAAoBD,OAEjC,MAIa,GAAU,CAInBhD,OARoB,IAAIiD,IAQDjD,OAE3B,MC5BakD,GAAuB,CAACjI,EAAS5P,SAAW,cAA4B4P,EAQjFsG,aAAahO,EAAIoD,EAAS2D,GACtBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,YAAE8G,EAAW,sBAAEZ,GAA0BoJ,EAC3C/G,SAA0C,KAAPA,IAGnCrC,GAEW,MADXqC,EAAK8G,EAAc9G,EAAIoD,EAAS2D,KAKpC3D,EAAQ4K,aAAahO,EAAIzB,GAC7B,CAQAgB,SAAS9D,EAAS2H,EAAS2D,GACvBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,UAAEuQ,EAAS,YAAElK,EAAW,eAAEC,EAAc,SAAEnC,EAAQ,eAAEiC,EAAc,mBAAEoK,GAAuBlB,EACjG,IAAKjJ,EACD,OAEJ,MAAM8R,EAAgB9T,IAClB,IAAK,MAAMC,KAAQD,EACfkM,EAAU,CAACC,EAAmB4H,cAAe9T,GACjD,EAEE+T,EAAc1M,EAAQiI,YAAYxN,EAAiBpC,EAAU,KAAMG,GACrEmC,EACA+R,EAAYlK,OAAOgK,GAAc,GAGjCA,EAAaE,EAErB,CAQAD,cAAcpU,EAAS2H,EAAS2D,GAC5BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C2L,EAAQyM,cAAcpU,EAASsL,EACnC,CAQAkH,aAAajO,EAAIoD,EAAS2D,GACtBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,YAAE8G,EAAW,sBAAEZ,GAA0BoJ,EAC3C/G,SAA0C,KAAPA,IAGnCrC,GAEW,MADXqC,EAAK8G,EAAc9G,EAAIoD,EAAS2D,KAKpC3D,EAAQ6K,aAAajO,EAAIzB,GAC7B,GAMG,MAAMwR,WAAsBJ,OAEnC,MAAMK,GAAoB,IAAID,GAIjB,GAAU,CAInB/B,aAAcgC,GAAkBhC,aAIhCzO,SAAUyQ,GAAkBzQ,SAI5BsQ,cAAeG,GAAkBH,cAIjC5B,aAAc+B,GAAkB/B,cAEpC,MC7GagC,GAAuB,CAACvI,EAAS5P,SAAW,cAA4B4P,EAQjFP,UAAUhB,EAAQ/C,EAAS2D,GAEvB,OADAA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MACrC2L,EAAQ+D,UAAUhB,EAAQY,EACrC,CAQAmJ,YAAYzU,EAAS2H,EAAS2D,GAC1BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,UAAEuQ,EAAS,mBAAEC,GAAuBlB,EAC1C,OAAO3D,EAAQ8M,YAAYzU,EAASsL,GAAUR,IAC1CyB,EAAU,CAACC,EAAmBqG,YAAa/H,GAAa,GAEhE,CAQAU,UAAUnE,EAAOM,EAAS2D,GAEtB,OADAA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MACrC2L,EAAQ6D,UAAUnE,EAAOiE,EACpC,CAQAuH,YAAY7S,EAAS2H,EAAS2D,GAC1BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C2L,EAAQkL,YAAY7S,EAASsL,EACjC,CAQAxJ,aAAa9B,EAAS2H,EAAS2D,GAC3BA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAO0D,EAAQuE,GAAWjE,EACtBA,GAAWA,EAAQpC,QACnB+J,EAAQ+M,aAAahV,EAAQuE,EAASqH,EAE9C,CAQAZ,OAAOA,EAAQ/C,EAAS2D,GACpBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,QAAEuP,EAAO,UAAEgB,EAAS,YAAElK,EAAW,mBAAEmK,EAAkB,sBAAEtK,GAA0BoJ,EACvF,IAAKjJ,IAAgBH,EACjB,OAEJ,MAAMyS,EAAchN,EAAQiN,aAAe,CAAC,EAC5C,IAAIvN,EAAQhL,OAAOM,UAAUC,eAAeC,KAAK8X,EAAajK,GAAUiK,EAAYjK,IAAW,GAChF,IAAXrD,IACAA,EAAQkE,EAAQG,UAAUhB,EAAQ/C,EAAS2D,KAEhC,IAAXjE,GACAkF,EAAU,CAACC,EAAmBqG,YAAa,CAACnI,EAAQrD,IAE5D,CAQApD,QAAQ4Q,EAAGlN,EAAS2D,GAChBA,EAAUA,EAAUY,GAAQC,OAAOb,EAAStP,MAC5C,MAAM,UAAEuQ,EAAS,YAAElK,EAAW,SAAElC,EAAQ,mBAAEqM,EAAkB,sBAAEtK,GAA0BoJ,EACxF,IAAKjJ,IAAgBH,EACjB,OAEJ,MAAM+B,EAAU0D,EAAQmN,YACxB,GAAI7Q,GAAWA,EAAQrG,OAAQ,CAE3B,MAAMyC,EAAQJ,EAASgE,EAAS9D,GAChC,IAAIP,EAAI,EAER,IAAK,MAAMU,KAAQD,EACfkM,EAAU,CAACC,EAAmB1K,aAAclC,EAAGU,IAC/CV,GAAKO,CAEb,CACJ,GAKG,MAAM4U,WAAsBP,OAEnC,MAAMQ,GAAoB,IAAID,GAIjB,GAAU,CAInBrJ,UAAWsJ,GAAkBtJ,UAI7B+I,YAAaO,GAAkBP,YAI/BjJ,UAAWwJ,GAAkBxJ,UAI7BqH,YAAamC,GAAkBnC,YAI/B/Q,aAAckT,GAAkBlT,aAIhC4I,OAAQsK,GAAkBtK,OAI1BzG,QAAS+Q,GAAkB/Q,SAE/B,MClJO,SAASgR,GAAkBhJ,EAAS5P,QACvC,OAAO2P,EAAoBiB,GAAwB+G,GAAmBE,GAAqBM,GAAqBvI,MACpH,CAIO,MAAMiJ,GAAa,IACnBC,MACAC,MACAC,MACAC,MACA5K,IAKA,MAAM6K,WAAoBN,OAEjC,MAAMO,GAAkB,IAAID,GAIf,GAAU,CAInB9T,WAAY+T,GAAgB/T,WAI5BoC,OAAQ2R,GAAgB3R,OAIxB6I,YAAa8I,GAAgB9I,YAI7BG,YAAa2I,GAAgB3I,YAI7BC,WAAY0I,GAAgB1I,WAI5BlL,gBAAiB4T,GAAgB5T,gBAIjCmC,WAAYyR,GAAgBzR,WAI5BqJ,gBAAiBoI,GAAgBpI,gBAIjCrL,gBAAiByT,GAAgBzT,gBAIjCC,gBAAiBwT,GAAgBxT,gBAIjCgP,MAAOwE,GAAgBxE,MAIvBuB,aAAciD,GAAgBjD,aAI9BzO,SAAU0R,GAAgB1R,SAI1BsQ,cAAeoB,GAAgBpB,cAI/B5B,aAAcgD,GAAgBhD,aAI9B9G,UAAW8J,GAAgB9J,UAI3B+I,YAAae,GAAgBf,YAI7BjJ,UAAWgK,GAAgBhK,UAI3BqH,YAAa2C,GAAgB3C,YAI7B/Q,aAAc0T,GAAgB1T,aAI9B4I,OAAQ8K,GAAgB9K,OAIxBzG,QAASuR,GAAgBvR,SAE7B,MCrHO,MAAMiI,GACTX,QACA+H,wBACApR,sBACA+Q,eACA9Q,eACAC,eACAoK,mBACAJ,WACAqJ,gBACA1S,QACAV,YACAC,eACAC,iBACAC,SACAC,oBACAC,UACAC,WACAC,eACAC,cACA6S,SACAvV,SACAoM,UACAzJ,YACAI,MACA0N,gBACA+E,aACA9E,cACA+E,aASAC,cAAcvK,EAAU,CAAC,EAAGwK,GACxB,OAAOxK,aAAmBY,GAAUZ,EAAU,IAAIY,GAAQZ,EAASwK,EACvE,CAOAnY,YAAY2N,EAAU,CAAC,EAAGwK,EAAc,MACpC,MAAM,QAAEvK,EAAUuK,GAAe,GAAc,wBAAExC,EAA0B,EAAiC,sBAAEpR,EAAwB,wBAA8C,eAAE+Q,EAAiB,EAAwB,eAAE9Q,EAAiB,iBAAuC,eAAEC,EAAiB,iBAAuC,mBAAEoK,EAAqB,EAA4B,WAAEJ,EAAa,EAA2B,gBAAEqJ,EAAkB,EAAgC,QAAE1S,EAAU,UAAgC,YAAEV,EAAc,cAAoC,eAAEC,EAAiB,iBAAuC,iBAAEC,EAAmB,mBAAyC,SAAEC,EAAW,WAAiC,oBAAEC,EAAsB,sBAA4C,UAAEC,EAAY,YAAkC,WAAEC,EAAa,aAAmC,eAAEC,EAAiB,iBAAuC,cAAEC,EAAgB,gBAAsC,SAAE6S,EAAW,KAAI,SAAEvV,EAAW,WAAiC,UAAEoM,EAAY,EAAuB,YAAEzJ,EAAc,cAAoC,MAAEI,EAAQ,QAA8B,gBAAE0N,EAAkB,EAAgC,aAAE+E,EAAe,CAAC,EAAG9E,cAAekF,EAAyB,CAAC,EAAC,aAAEH,EAAe,MAEj0CtK,EACCuF,EAAgB,IACf,KACAkF,GAEPlF,EAAcC,UAAaiF,GAAwBjF,UAE7C,IACK,KACCiF,GAAwBjF,WAAa,CAAC,GAH5C,KAKN9U,KAAKuP,QAAUA,EACfvP,KAAKsX,wBAA0BA,EAC/BtX,KAAKkG,sBAAwBA,EAC7BlG,KAAKiX,eAAiBA,EACtBjX,KAAKmG,eAAiBA,EACtBnG,KAAKoG,eAAiBA,EACtBpG,KAAKwQ,mBAAqBA,EAC1BxQ,KAAKoQ,WAAaA,EAClBpQ,KAAKyZ,gBAAkBA,EACvBzZ,KAAK+G,QAAUA,EACf/G,KAAKqG,YAAcA,EACnBrG,KAAKsG,eAAiBA,EACtBtG,KAAKuG,iBAAmBA,EACxBvG,KAAKwG,SAAWA,EAChBxG,KAAKyG,oBAAsBA,EAC3BzG,KAAK0G,UAAYA,EACjB1G,KAAK2G,WAAaA,EAClB3G,KAAK4G,eAAiBA,EACtB5G,KAAK6G,cAAgBA,EACrB7G,KAAK0Z,SAAWA,EAChB1Z,KAAKmE,SAAWA,EAChBnE,KAAKuQ,UAAYA,EACjBvQ,KAAK8G,YAAcA,EACnB9G,KAAKkH,MAAQA,EACblH,KAAK4U,gBAAkBA,EACvB5U,KAAK2Z,aAAeA,EACpB3Z,KAAK6U,cAAgBA,EACrB7U,KAAK4Z,aAAeA,CAExB,CAOA3Q,QACI,OAAO,IAAIiH,GAAQ,IAAKlQ,MAAQA,KAAKuP,QACzC,CAOAuI,OAAOxI,EAAS0K,EAAaha,KAAKuP,SAC9B,OAAO,IAAIW,GAAQ,IAAKlQ,QAASsP,GAAW0K,EAChD,EC3GG,MAAMC,GACTC,MAMAvY,YAAYuY,EAAQ,CAAC,GACjBla,KAAKka,MAAQA,CACjB,CASAtU,gBAAgB2C,EAAIpI,EAAKmQ,GACrB,OAAOtQ,KAAKgG,gBAAgBuC,EAAIpI,EAAKmQ,EACzC,CAOApE,MAAMgO,EAAQ,CAAC,GACXla,KAAKka,MAAQA,CACjB,CASAlU,gBAAgBuC,EAAIpI,EAAKmQ,GACrB,GAAI6J,MAAM7J,GACN,OAAO,EAIX,GAFAtQ,KAAKka,MAAQla,KAAKka,OAAS,CAAC,EAC5Bla,KAAKka,MAAM3R,GAAMvI,KAAKka,MAAM3R,IAAO,CAAC,EAE3B,iBADMvI,KAAKka,MAAM3R,GAAIpI,GAC1B,CACI,GAAIia,SAASpa,KAAKka,MAAM3R,GAAIpI,KAASH,KAAKka,MAAM3R,GAAIpI,IAAQmQ,EAAM,CAC9D,MAAM+J,EAAY,EAClB,QAAI/J,EAAQrP,IAAQoZ,IAGpBra,KAAKka,MAAM3R,GAAIpI,GAAOmQ,EACf,GACX,CACA,OAAO,CAAK,CAIZ,OADAtQ,KAAKka,MAAM3R,GAAIpI,GAAOmQ,GACf,CAEnB,EC3DG,MAAMgK,GAIT3Y,YAAY6E,GAAW,GACnBxG,KAAKkV,QAAU,CACXrN,OAAQ,CAAC,EACTE,WAAY,CAAC,EACbD,SAAU,GACVE,OAAQ,CAAC,GAEbhI,KAAKmV,QAAU,CACXtN,OAAQ,CAAC,EACTE,WAAY,CAAC,EACbD,SAAU,IAEd9H,KAAKoV,QAAU,CACXrN,WAAY,CAAC,GAEjB/H,KAAKiI,QAAU,GACfjI,KAAKwG,SAAWA,CACpB,CAOAf,WAAW8C,EAAI8C,GACXrL,KAAKkV,QAAQlN,OAAOO,GAAMvI,KAAKkV,QAAQlN,OAAOO,IAAO,GACrDvI,KAAKkV,QAAQlN,OAAOO,GAAIhE,KAAK8G,EACjC,CAQAzF,gBAAgB2U,EAAahS,EAAIpI,GAC7B,OAAOH,KAAKgG,gBAAgBuU,EAAahS,EAAIpI,EACjD,CAMAoW,aAAahO,GACTvI,KAAKkV,QAAQpN,SAASvD,KAAKgE,EAC/B,CAMAsI,YAAYtI,GACRvI,KAAKmV,QAAQtN,OAAOU,IAAM,CAC9B,CAOAxC,gBAAgBwC,EAAIpI,GAChBH,KAAKmV,QAAQpN,WAAWQ,GAAMvI,KAAKmV,QAAQpN,WAAWQ,IAAO,CAAC,EAC9DvI,KAAKmV,QAAQpN,WAAWQ,GAAIpI,IAAO,CACvC,CAMAqW,aAAajO,GACTvI,KAAKmV,QAAQrN,SAASvD,KAAKgE,EAC/B,CAIA2D,QACIlM,KAAK2B,aACT,CAMAmP,WAAWvI,GACPvI,KAAKkV,QAAQrN,OAAOU,IAAM,CAC9B,CAQAvC,gBAAgBuU,EAAahS,EAAIpI,GAC7B,MAAM4U,EAA0B,YAAhBwF,EAA4Bva,KAAKkV,QAAUlV,KAAKoV,QAChE,GAAIL,EAAS,CACT,GAGgB,YAAhBwF,GACOva,KAAKkV,QAAQnN,WAAWQ,IACxBvI,KAAKkV,QAAQnN,WAAWQ,GAAIpI,GAE/B,OAEJ4U,EAAQhN,WAAWQ,GAAMwM,EAAQhN,WAAWQ,IAAO,CAAC,EACpDwM,EAAQhN,WAAWQ,GAAIpI,IAAO,CAClC,CACJ,CAMAuP,UAAUZ,GACN9O,KAAKiI,QAAQ1D,KAAKuK,EACtB,CAMA0L,eAAe9W,EAAQuE,GACnB,GAAIvE,EAAS,EAAG,CACZ,MAAM,OAAE9B,GAAWqG,GACXA,QAASwS,GAAaza,KAC9B,IAAK,IAAI4D,EAAI,EAAGA,EAAIhC,EAAQgC,IAAK,CAC7B,MAAM5C,EAAQiH,EAAQrE,GAChByH,EAAQzH,EAAIF,EAClB+W,EAASpP,GAAS,CAACrK,EAAOqK,EAC9B,CACJ,MAEIrL,KAAKiI,QAAUA,EAAQ6H,KAAI,CAAC3N,EAAGyB,IAAM,CAACzB,EAAGyB,IAEjD,EC/HG,MAAM+T,GASTkC,cAAclO,EAAS2D,EAASoI,EAAWzE,IACvC,OAAItH,aAAmBgM,GACZhM,EAEJ,IAAIgM,GAAQhM,EAAS2D,EAASoI,EACzC,CAQA/V,YAAYgK,EAAU,CAAC,EAAG2D,EAASoI,EAAWzE,IAC1C,MAAM,OAAEyH,EAAS,KAAI,MAAErR,EAAQ,KAAI,MAAE6Q,EAAQ,KAAI,QAAErO,EAAU,KAAI,QAAE5D,EAAU,KAAI,QAAE8M,EAAU,MAExFpJ,EACL2D,EAAUY,GAAQC,OAAOb,EAASA,GAASC,SAAW2J,IACtD,MAAM,UAAExS,EAAS,SAAEF,EAAQ,WAAEG,EAAU,sBAAET,EAAqB,eAAEE,EAAc,mBAAEoK,EAAkB,aAAEmJ,EAAY,QAAE5S,EAAO,MAAEG,GAAWoI,EAElItP,KAAKka,MADLxT,EACa,IAAIuT,GAAQC,GAGZ,KAGbla,KAAK6L,QADLrF,EACe,IAAIkF,EAAQ1L,KAAM6L,GAGlB,KAEf3F,EACI+B,EACAjI,KAAKiI,QAAU,IAAIsG,EAAQtG,IAG3BjI,KAAKiI,QAAU,IAAIsG,EACnBvO,KAAKiI,QAAQ2G,SAAS4B,IAI1BxQ,KAAKiI,QAAU,KAGfjI,KAAK+U,QADLpO,EACe,KAGAoO,GAAW,IAAIuF,GAAQ9T,GAE1CxG,KAAK0a,OAASA,EACd1a,KAAKqJ,MAAQA,GAAS,IAAIqO,OAASrN,EAAW,IACtCsP,GAAgB,CAAC,EACrBzS,QACAH,QAASX,EAAiBW,EAAU,MAG5C,CAMIc,aACA,MAAMA,EAAS7H,KAAK4Q,UAAU,KAAMxM,KACpC,OAAIyD,aAAkB6F,EACX7F,EAEJA,EAAO,EAClB,CAQA+I,UAAUrH,EAAOpF,GACb,OAAOnE,KAAKqJ,MAAMuH,UAAUrH,EAAOpF,EACvC,CAOA2M,WAAWvI,EAAI+G,GACX,MAAM,YAAExI,EAAW,eAAER,EAAc,SAAEoT,GAAapK,EAC5CqL,EAAiB3a,KAAKqJ,MAAM+K,WAAW7L,GACvCqS,EAAsBC,IACnBA,KAGA/T,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQjE,WAAWvI,GAExBvI,KAAK0a,QACL1a,KAAK0a,OAAOtM,KAAK,aAAc7F,GAE/BmR,GACAA,IACJ,EAEJ,OAAIpT,GAAkBqU,aAA0BhO,SAC5CgO,EAAenN,KAAKoN,GACbD,IAEXC,EAAmBD,GACZA,EACX,CAOA9J,YAAYtI,EAAI+G,GACZ,MAAM,YAAExI,EAAW,eAAER,EAAc,SAAEoT,GAAapK,EAC5CwL,EAAmB9a,KAAKqJ,MAAM6J,aAAa3K,GAC3CwS,EAAuB5F,IACrBA,KACKrO,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQlE,YAAYtI,GAEzBvI,KAAK0a,QACL1a,KAAK0a,OAAOtM,KAAK,cAAe7F,GAEhCmR,GACAA,IAER,EAEJ,OAAIpT,GAAkBwU,aAA4BnO,SAC9CmO,EAAiBtN,KAAKuN,GACfD,IAEXC,EAAoBD,GACbA,EACX,CAOApK,YAAY1M,EAASsL,GACjB,MAAM,QAAEC,EAAO,eAAEjJ,EAAc,SAAEoT,GAAapK,EACxC0L,EAAc1L,EAAQwI,OAAO,CAC/B4B,SAAU,OAERpN,EAAW,GACjB,IAAK,MAAM/D,KAAMvE,EAAS,CACtB,MAAMyI,EAAU8C,EAAQuB,WAAWvI,EAAIvI,KAAMgb,GACzC1U,GAAkBmG,aAAmBE,SACrCL,EAAS/H,KAAKkI,EAEtB,CACA,MAAMwO,EAAsB,KACpBvB,GACAA,GACJ,EAEJ,GAAIpT,GAAkBgG,EAAS1K,OAAS,EAAG,CACvC,MAAM6L,EAAMnB,EAAS1K,OAAS+K,QAAQc,IAAInB,GAAYK,QAAQW,QAAQ,IAEtE,OADAG,EAAID,KAAKyN,GACFxN,CACX,CACAwN,GACJ,CAMInT,eACA,MAAMA,EAAW9H,KAAK4T,YAAY,KAAMxP,KACxC,OAAI0D,aAAoB4F,EACb5F,EAEJA,EAAS,EACpB,CAQA8L,YAAYrK,EAAOpF,GACf,OAAOnE,KAAKqJ,MAAMuK,YAAYrK,EAAOpF,EACzC,CAOAoS,aAAahO,EAAI+G,GACb,MAAM,YAAExI,EAAW,eAAER,EAAc,SAAEoT,GAAapK,EAC5CuL,EAAQ7a,KAAKqJ,MAAMkL,YAAYhM,GAC/B2S,EAAwBL,IACtBA,KACK/T,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQwB,aAAahO,GAE1BvI,KAAK0a,QACL1a,KAAK0a,OAAOtM,KAAK,eAAgB7F,GAEjCmR,GACAA,IAER,EAEJ,OAAIpT,GAAkBuU,aAAiBlO,SACnCkO,EAAMrN,KAAK0N,GACJL,IAEXK,EAAqBL,GACdA,EACX,CAOArE,aAAajO,EAAI+G,GACb,MAAM,YAAExI,EAAW,eAAER,EAAc,SAAEoT,GAAapK,EAC5C6F,EAAUnV,KAAKqJ,MAAMiK,cAAc/K,GACnC4S,EAAwBhG,IACtBA,KACKrO,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQyB,aAAajO,GAE1BvI,KAAK0a,QACL1a,KAAK0a,OAAOtM,KAAK,eAAgB7F,GAEjCmR,GACAA,IAER,EAEJ,OAAIpT,GAAkB6O,aAAmBxI,SACrCwI,EAAQ3H,KAAK2N,GACNhG,IAEXgG,EAAqBhG,GACdA,EACX,CAOAiD,cAAcpU,EAASsL,GACnB,MAAM,QAAEC,EAAO,eAAEjJ,EAAc,SAAEoT,GAAapK,EACxC0L,EAAc1L,EAAQwI,OAAO,CAC/B4B,SAAU,OAERpN,EAAW,GACjB,IAAK,MAAM/D,KAAMvE,EAAS,CACtB,MAAMyI,EAAU8C,EAAQgH,aAAahO,EAAIvI,KAAMgb,GAC3C1U,GAAkBmG,aAAmBE,SACrCL,EAAS/H,KAAKkI,EAEtB,CACA,MAAM2O,EAAwB,KACtB1B,GACAA,GACJ,EAEJ,GAAIpT,GAAkBgG,EAAS1K,OAAS,EAAG,CACvC,MAAM6L,EAAMnB,EAAS1K,OAAS+K,QAAQc,IAAInB,GAAYK,QAAQW,QAAQ,IAEtE,OADAG,EAAID,KAAK4N,GACF3N,CACX,CACA2N,GACJ,CAMIrT,iBACA,MAAMA,EAAa/H,KAAKsR,cAAc,KAAMlN,KAC5C,OAAI2D,aAAsB2F,EACf3F,EAEJA,EAAW,EACtB,CAQAuJ,cAAc/H,EAAOpF,GACjB,OAAOnE,KAAKqJ,MAAMiI,cAAc/H,EAAOpF,EAC3C,CAUAyB,gBAAgB2C,EAAIpI,EAAKa,EAAOsP,EAAO,EAAGhB,GACtC,MAAM,QAAEC,EAAO,YAAEzI,EAAW,eAAER,EAAc,oBAAEG,EAAmB,gBAAEgT,EAAe,MAAEvS,EAAK,SAAEwS,GAAapK,EAClG+L,EAAgC,KAC9B3B,GACAA,GACJ,EAEJ,GAAInY,MAAMC,QAAQ+G,IAAOA,aAAc6J,YAAa,CAChD,IAAK3L,EACD,MAAM,IAAI6U,MAAM,uEAEpB,MAAMC,EAAkBjM,EAAQwI,OAAO,CAAE4B,SAAU,OAC7CpN,EAAW,GACjB,IAAK,IAAI1I,EAAI,EAAGA,EAAI2E,EAAG3G,OAAQgC,IAAK,CAChC,MAAM4X,EAAM/B,EAAgBzY,EAAO4C,EAAGsD,EAAO/G,GACvCsM,EAAU8C,EAAQ3J,gBAAgB,CAAC2C,EAAG3E,GAAIzD,EAAKqb,EAAKlL,GAAOtQ,KAAMub,GACnEjV,GAAkBmG,aAAmBE,SACrCL,EAAS/H,KAAKkI,EAEtB,CACA,GAAInG,GAAkBgG,EAAS1K,OAAS,EAAG,CACvC,MAAM6L,EAAMnB,EAAS1K,OAAS+K,QAAQc,IAAInB,GAAYK,QAAQW,QAAQ,IAEtE,OADAG,EAAID,KAAK6N,GACF5N,CACX,CAEA,YADA4N,GAEJ,CACA,MAAMI,EAAwBzb,KAAKqJ,MAAMmK,cAAcjL,EAAIpI,GACrDub,EAA4BC,IAC9B,MAAMpB,OAAsC,IAAjBoB,EAA+B,UAAY,UACtE,GAAI3b,KAAKka,QACgBla,KAAKka,MAAMtU,gBAAgB2C,EAAIpI,EAAKmQ,KACnCtQ,KAAK6L,QACvB,OAGR,IAAI+P,EACgB,YAAhBrB,EACAqB,EAAY5a,GAII,CAAE4a,GAAalX,EAAciX,EAAc3a,GAE/D,IAAIyL,EAAU,KAEVA,EADAzM,KAAK6L,QACK7L,KAAK6L,QAAQjG,gBAAgB2C,EAAIpI,EAAKyb,EAAW5a,EAAOsF,GAGxDtG,KAAKqJ,MAAMqD,eAAenE,EAAIpI,EAAKyb,GAEjD,MAAMC,EAAiC,MAC9B/U,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQnP,gBAAgB2U,EAAahS,EAAIpI,GAE9CH,KAAK0a,QACL1a,KAAK0a,OAAOtM,KAAK,kBAAmB7F,EAAIpI,GAE5Ckb,GAA+B,EAEnC,GAAI/U,GAAkBmG,aAAmBE,QAErC,OADAF,EAAQe,KAAKqO,GACNpP,EAEXoP,GAAgC,EAEpC,OAAIvV,GAAkBmV,aAAiC9O,SACnD8O,EAAsBjO,KAAKkO,GACpBD,IAEXC,EAAyBD,GAClBA,EACX,CAUAzV,gBAAgBuC,EAAIpI,EAAKa,EAAOsP,EAAO,EAAGhB,GACtC,MAAM,QAAEC,EAAO,YAAEzI,EAAW,eAAER,EAAc,oBAAEG,EAAmB,gBAAEgT,EAAe,MAAEvS,EAAK,SAAEwS,GAAapK,EAClGwM,EAAgC,KAC9BpC,GACAA,GACJ,EAEJ,GAAInY,MAAMC,QAAQ+G,IAAOA,aAAc6J,YAAa,CAChD,IAAK3L,EACD,MAAM,IAAI6U,MAAM,uEAEpB,MAAMC,EAAkBjM,EAAQwI,OAAO,CAAE4B,SAAU,OAC7CpN,EAAW,GACjB,IAAK,IAAI1I,EAAI,EAAGA,EAAI2E,EAAG3G,OAAQgC,IAAK,CAChC,MAAM4X,EAAM/B,EAAgBzY,EAAO4C,EAAGsD,EAAO/G,GACvCsM,EAAU8C,EAAQvJ,gBAAgB,CAACuC,EAAG3E,GAAIzD,EAAKqb,EAAKlL,GAAOtQ,KAAMub,GACnEjV,GAAkBmG,aAAmBE,SACrCL,EAAS/H,KAAKkI,EAEtB,CACA,GAAInG,GAAkBgG,EAAS1K,OAAS,EAAG,CACvC,MAAM6L,EAAMnB,EAAS1K,OAAS+K,QAAQc,IAAInB,GAAYK,QAAQW,QAAQ,IAEtE,OADAG,EAAID,KAAKsO,GACFrO,CACX,CAEA,YADAqO,GAEJ,CACA,MAAML,EAAwBzb,KAAKqJ,MAAMmK,cAAcjL,EAAIpI,GACrDoM,EAA2BoP,IAC7B,GAAIA,IAAiB3a,EAAO,CACxB,GAAIhB,KAAKka,QACgBla,KAAKka,MAAMlU,gBAAgBuC,EAAIpI,EAAKmQ,KACnCtQ,KAAK6L,QACvB,OAGR,IAAIY,EAAU,KAEVA,EADAzM,KAAK6L,QACK7L,KAAK6L,QAAQ7F,gBAAgBuC,EAAIpI,EAAKa,EAAO2a,EAAcrV,GAG3DtG,KAAKqJ,MAAMqD,eAAenE,EAAIpI,EAAKa,GAEjD,MAAM+a,EAAiC,KACnC,IAAKjV,GAAe9G,KAAK+U,QAAS,CAC9B,MAAMwF,OAAsC,IAAjBoB,EAA+B,UAAY,UACtE3b,KAAK+U,QAAQ/O,gBAAgBuU,EAAahS,EAAIpI,EAClD,CACIH,KAAK0a,QACL1a,KAAK0a,OAAOtM,KAAK,kBAAmB7F,EAAIpI,GAE5C2b,GAA+B,EAEnC,GAAIxV,GAAkBmG,aAAmBE,QAErC,OADAF,EAAQe,KAAKuO,GACNtP,EAEXsP,GACJ,GAEJ,OAAIzV,GAAkBmV,aAAiC9O,SACnD8O,EAAsBjO,KAAKjB,GACpBkP,IAEXlP,EAAwBkP,GACjBA,EACX,CAQA1V,gBAAgBwC,EAAIpI,EAAKmP,GACrB,MAAM,YAAExI,EAAW,eAAER,EAAc,SAAEoT,GAAapK,EAC5CmM,EAAwBzb,KAAKqJ,MAAMmK,cAAcjL,EAAIpI,GACrD6b,EAA2BL,SACRtR,IAAjBsR,GAA+C,OAAjBA,KAC9B3b,KAAKqJ,MAAM+J,iBAAiB7K,EAAIpI,IAC3B2G,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQhP,gBAAgBwC,EAAIpI,GAEjCH,KAAK0a,QACL1a,KAAK0a,OAAOtM,KAAK,kBAAmB7F,EAAIpI,GAExCuZ,GACAA,KAEG,GAIf,OAAIpT,GAAkBmV,aAAiC9O,QAC5C,IAAIA,SAAQ,CAACW,EAASC,KACzBkO,EAAsBjO,MAAMmO,IACxBrO,EAAQ0O,EAAwBL,GAAc,GAC/CpO,EAAO,IAGXyO,EAAwBP,EACnC,CAOArK,gBAAgBpN,EAASsL,GACrB,MAAM,QAAEC,EAAO,eAAEjJ,EAAc,iBAAEC,EAAgB,SAAEmT,GAAapK,EAC1D0L,EAAc1L,EAAQwI,OAAO,CAC/BhR,aAAcP,EACdmT,SAAU,OAERpN,EAAW,GACjB,IAAK,MAAM/D,KAAOvE,GAAW,CAAC,EAC1B,IAAK,MAAM7D,KAAO6D,EAAQuE,GAAK,CAC3B,MACM0T,EAAc,CAAC1T,EAAIpI,EADX6D,EAAQuE,GAAIpI,IAEpBsM,EAAU8C,EAAQvJ,gBAAgBiW,EAAajc,KAAMgb,GAC/BvO,aAAmBE,SAC3CL,EAAS/H,KAAKkI,EAEtB,CAEJ,MAAMyP,EAA0B,KACxBxC,GACAA,GACJ,EAEJ,GAAIpT,GAAkBgG,EAAS1K,OAAS,EAAG,CACvC,MAAM6L,EAAMnB,EAAS1K,OAAS+K,QAAQc,IAAInB,GAAYK,QAAQW,QAAQ,IAEtE,OADAG,EAAID,KAAK0O,GACFzO,CACX,CACAyO,GACJ,CAMIlU,aACA,MAAMA,EAAShI,KAAK6T,UAAU,KAAMzP,KACpC,OAAI4D,aAAkB0F,EACX1F,EAEJA,EAAO,EAClB,CAQA6L,UAAUtK,EAAOpF,GACb,OAAOnE,KAAKqJ,MAAMwK,UAAUtK,EAAOpF,EACvC,CASAsB,WAAW8C,EAAI8H,EAAOC,EAAO,EAAGhB,GAC5B,MAAM,YAAExI,EAAW,eAAER,EAAc,eAAEH,EAAc,SAAEuT,GAAapK,EAClEgB,EAAOnK,EAAiBmK,GAAQrP,IAAQ,EACxC,MAAMkb,EAAiBnc,KAAKqJ,MAAMmL,WAAWjM,EAAI8H,EAAOC,GAClDsK,EAAsBvP,KACnBvE,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQtP,WAAW8C,EAAI8C,GAE5BrL,KAAK0a,QACL1a,KAAK0a,OAAOtM,KAAK,aAAc7F,EAAI8H,EAAOhF,EAAOiF,GAEjDoJ,GACAA,GACJ,EAEJ,OAAIpT,GAAkB6V,aAA0BxP,SAC5CwP,EAAe3O,KAAKoN,GACbuB,IAEXvB,EAAmBuB,GACZA,EACX,CAMIrD,kBACA,OAAO9Y,KAAKiI,SAASiH,YACzB,CAMI0J,kBACA,OAAO5Y,KAAKiI,SAASkH,gBACzB,CAMAiN,WAAWnU,GACPjI,KAAKiI,SAASiE,MAAMjE,EACxB,CAQAuH,UAAUnE,EAAOiE,GACb,MAAM,QAAEC,GAAYD,EACdZ,EAAS1O,KAAKiI,SAASzH,IAAI6K,GACjC,OAAKqD,GACmBa,EAAQkJ,YAAY/J,EAAQ1O,KAAMsP,GACnC,EAG3B,CAQAI,UAAUhB,EAAQY,GACd,GAAqB,OAAjBtP,KAAKiI,QACL,OAAO,KAEX,MAAM,QAAEsH,EAAO,eAAE3I,EAAc,YAAEE,EAAW,SAAE4S,GAAapK,EACrDqJ,EAAc3Y,KAAK4Y,aAAe,CAAC,EACzC,IAAIvN,EAAQhL,OAAOM,UAAUC,eAAeC,KAAK8X,EAAajK,GAAUiK,EAAYjK,IAAW,EAgB/F,OAfe,IAAXrD,IACIzE,GACAyE,EAAQrL,KAAKiI,QAAQxF,IAAIiM,KAAY,GAChC5H,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQrF,UAAU,CAAChB,EAAQrD,IAEhCqO,GACAA,KAGCnK,EAAQkJ,cAEbpN,EADoBkE,EAAQkJ,YAAY/J,EAAQ1O,KAAMsP,GAClC,MAGb,IAAXjE,EACO,KAEJA,CACX,CASAoN,YAAYzU,EAASsL,EAAS+M,GAC1B,GAAqB,OAAjBrc,KAAKiI,QACL,OAAO,KAEX,MAAM,eAAErB,EAAc,YAAEE,EAAW,SAAE4S,GAAapK,EAC5CR,EAAc9O,KAAKiI,QAAQgH,MAAMjL,GACvC,GAAI8K,EAAY,KAA0B,IAApBA,EAAY,GAC1BuN,GACAA,EAAQvN,QAIZ,GAAIlI,EAAgB,CAChB,MAAMyE,EAAQrL,KAAKiI,QAAQxF,IAAIqM,EAAY,IAC3CA,EAAY,GAAKzD,GACZvE,GAAe9G,KAAK+U,SACrB/U,KAAK+U,QAAQrF,UAAUZ,GAEvB4K,GACAA,GAER,CAEJ,OAAO5K,CACX,CAOA+H,YAAY7S,EAASsL,GACjB,GAAqB,OAAjBtP,KAAKiI,QACL,OAAO,KAEX,MAAM,eAAErB,EAAc,cAAEC,EAAa,YAAEC,EAAW,SAAE4S,GAAapK,EACjEtP,KAAKiI,QAAQ+G,MAAMhL,IACd4C,GAAkBC,KAAmBC,GAAe9G,KAAK+U,SAC1D/U,KAAK+U,QAAQrF,UAAU1L,GAEvB0V,GACAA,GAER,CAOAhB,aAAahV,EAAS,EAAGuE,EAASqH,GAC9B,GAAqB,OAAjBtP,KAAKiI,QACL,OAAO,KAEX,MAAM,eAAErB,EAAc,cAAEC,EAAa,YAAEC,EAAW,SAAE4S,GAAapK,EACjEtP,KAAKiI,QAAQiE,MAAMxI,EAAQuE,IACtBrB,GAAkBC,KAAmBC,GAAe9G,KAAK+U,SAC1D/U,KAAK+U,QAAQyF,eAAe9W,EAAQuE,GAEpCyR,GACAA,GAER,CAIA4C,aACQtc,KAAK+U,SACL/U,KAAK+U,QAAQ7I,QAEblM,KAAKka,OACLla,KAAKka,MAAMhO,QAEXlM,KAAK6L,SACL7L,KAAK6L,QAAQK,OAErB,EC/vBG,MAAMqQ,WAAsBhD,GAI/B1R,SAAW,CAIXE,aAAe,CAIfD,WAAa,CAIb4G,SAAW,CAIXzG,UAAY,EAKT,MAAM,GAAU,IAIhBuU,GAIH3U,OAAQ,KAIRE,WAAY,KAIZD,SAAU,KAIV4G,OAAQ,KAIRzG,QAAS,MAEb,MC6CA,M","sources":["webpack://echoD/webpack/universalModuleDefinition","webpack://echoD/webpack/bootstrap","webpack://echoD/webpack/runtime/define property getters","webpack://echoD/webpack/runtime/hasOwnProperty shorthand","webpack://echoD/webpack/runtime/make namespace object","webpack://echoD/./lib/utils.js","webpack://echoD/./lib/constants.js","webpack://echoD/./lib/indexes/index.js","webpack://echoD/./lib/indexes/components.js","webpack://echoD/./lib/indexes/sorted.js","webpack://echoD/./lib/indexes/spatial.js","webpack://echoD/./lib/changes.js","webpack://echoD/./lib/emitter.js","webpack://echoD/./lib/symbols.js","webpack://echoD/./lib/actions/actor.js","webpack://echoD/./lib/actions/component.js","webpack://echoD/./lib/types.js","webpack://echoD/./lib/storage.js","webpack://echoD/./lib/updater.js","webpack://echoD/./lib/handler.js","webpack://echoD/./lib/actions/core.js","webpack://echoD/./lib/actions/entity.js","webpack://echoD/./lib/actions/symbol.js","webpack://echoD/./lib/node.js","webpack://echoD/./lib/options.js","webpack://echoD/./lib/ordered.js","webpack://echoD/./lib/pending.js","webpack://echoD/./lib/context.js","webpack://echoD/./lib/client.js","webpack://echoD/./lib/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echoD\"] = factory();\n\telse\n\t\troot[\"echoD\"] = factory();\n})(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @returns {number} The current time in milliseconds.\n */\nexport function now() {\n    return performance.timeOrigin + performance.now();\n}\n/**\n * Concatenates two typed arrays or arrays.\n *\n * @param {TypedArray | any[]} a - The first typed array or array.\n * @param {TypedArray | any[]} b - The second typed array or array.\n * @returns {TypedArray | any[]} The concatenated typed array or array.\n */\nexport function concatTypedArray(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.concat(b);\n    }\n    else if (Array.isArray(a)) {\n        const a_ = new b.constructor(a.length);\n        a_.set(a);\n        a = a_;\n    }\n    else if (Array.isArray(b)) {\n        const b_ = new a.constructor(b.length);\n        b_.set(b);\n        b = b_;\n    }\n    const c = new a.constructor(a.length + b.length);\n    if (c.set) {\n        c.set(a);\n        c.set(b, a.length);\n    }\n    return c;\n}\n/**\n * Creates a union of multiple sets or arrays.\n *\n * @param {...Array<SetOrArray<any>>} sets - The sets or arrays to be united.\n * @returns {Array<string>} The union of the sets or arrays.\n */\nexport function unionSetOrArray(...sets) {\n    const union = {};\n    for (const set of sets) {\n        if (set) {\n            for (const v of set) {\n                union[v] = true;\n            }\n        }\n    }\n    return Object.keys(union);\n}\n/**\n * Creates an union of two sets.\n *\n * @param {SetExperimental} setA - The first set.\n * @param {SetExperimental} setB - The second set.\n * @returns {Set<any>} The union of the sets.\n */\nexport function unionSets(setA, setB) {\n    if (typeof setA.union === 'function') {\n        return setA.union(setA);\n    }\n    const union = new Set();\n    for (const v of setA)\n        union.add(v);\n    for (const v of setB)\n        union.add(v);\n    return union;\n}\n/**\n * Creates an difference of the two sets.\n *\n * @param {SetExperimental} setA - The first set.\n * @param {SetExperimental} setB - The second set.\n * @returns {Set<any>} The difference of the sets.\n */\nexport function differenceSets(setA, setB) {\n    if (typeof setA.difference === 'function') {\n        return setA.difference(setA);\n    }\n    const difference = new Set();\n    for (const v of setA)\n        if (!setB.has(v))\n            difference.add(v);\n    return difference;\n}\n/**\n * Creates an intersection of the two sets.\n *\n * @param {SetExperimental} setA - The first set.\n * @param {SetExperimental} setB - The second set.\n * @returns {Set<any>} The intersection of the sets.\n */\nexport function intersectionSets(setA, setB) {\n    if (typeof setA.intersection === 'function') {\n        return setA.intersection(setA);\n    }\n    const intersection = new Set();\n    for (const v of setA)\n        if (setB.has(v))\n            intersection.add(v);\n    return intersection;\n}\n/**\n * binaryInsert finds the index of where a value should be inserted into a sorted array.\n *\n * @param {any[]} items - The sorted array\n * @param {any} value - The value to insert\n * @param {Function} getValue - The function to get the value from the item\n * @returns {number} The index of where the value should be inserted\n */\nexport function binaryInsert(items, value, getValue = (v) => v) {\n    let low = 0;\n    let high = items.length;\n    while (low < high) {\n        const mid = (low + high) >>> 1;\n        const item = items[mid];\n        const v = getValue(item);\n        if (v < value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\n/**\n * binarySearch finds the index of a value in a sorted array.\n *\n * @param {any[]} items - The sorted array\n * @param {any} target - The value to find\n * @param {Function} getValue - The function to get the value from the item\n * @returns {number[]} The index of the value\n */\nexport function binarySearch(items, target, getValue = (v) => v) {\n    let left = 0;\n    let right = items.length - 1;\n    while (left <= right) {\n        const mid = (left + right) >>> 1;\n        const item = items[mid];\n        const v = getValue(item);\n        if (v === target) {\n            return [mid, left];\n        }\n        else if (v < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    return [-1, left];\n}\n/**\n * Creates an enum from a set or an array.\n *\n * @param {SetOrArray<any>} set - The set or array from which the enum is to be created.\n * @param {number} offset - The starting value of the enum.\n * @returns {Record<string, number>} The created enum.\n */\nexport function createEnum(set, offset = 0) {\n    const _enum = {};\n    let i = offset;\n    if (set) {\n        for (const v of set) {\n            _enum[v] = i++;\n        }\n    }\n    return _enum;\n}\n/**\n * Creates a tuple from a message.\n *\n * @param {{ action?: any, payload?: any }} message - The message from which the tuple is to be created.\n * @returns {Array<any>} The created tuple.\n */\nexport function messageTuple(message) {\n    return [message?.action, message?.payload];\n}\n/**\n * Split an array into pages\n *\n * @param {Iterable<any> | any[]} array - The array to be split into pages.\n * @param {number} pageSize - The size of each page.\n * @returns {any[][]} The array of pages.\n */\nexport function paginate(array, pageSize) {\n    if (pageSize === Infinity && Array.isArray(array) && array.length > 0) {\n        return [array];\n    }\n    const pages = [];\n    let page = [];\n    let i = 0;\n    // if (!Array.isArray(array)) {\n    //   throw new Error('paginate: array must be an array');\n    // }\n    for (const v of array) {\n        if (i >= pageSize) {\n            pages.push(page);\n            page = [];\n            i = 0;\n        }\n        page.push(v);\n        i++;\n    }\n    if (page.length > 0) {\n        pages.push(page);\n    }\n    return pages;\n}\n/**\n * Determines the type of a value.\n *\n * @param {any} v - The value whose type is to be determined.\n * @returns {string} The type of the value.\n */\nexport function typeOf(v) {\n    const t = typeof v;\n    if (t === 'object') {\n        if (!v) {\n            return 'null';\n        }\n        else if (Array.isArray(v)) {\n            return 'array';\n        }\n    }\n    return t;\n}\n/**\n * Combines two values.\n *\n * @param {any} objA - The first value.\n * @param {any} objB - The second value.\n * @returns {[boolean, any]} A tuple where the first element is a boolean indicating whether the values were combined, and the second element is the combined value.\n */\nexport function combineValues(objA, objB) {\n    return recursiveCombination(objA, objB);\n}\n/**\n * Recursively combines two objects or arrays and returns the result.\n * If the combination is successful, it returns a tuple with a boolean indicating success and the combined object/array.\n * If the combination fails, it returns a tuple with a boolean indicating failure and the second object/array.\n * @param objA - The first object/array to combine.\n * @param objB - The second object/array to combine.\n * @returns A tuple with a boolean indicating success/failure and the combined object/array.\n */\nexport function recursiveCombination(objA, objB) {\n    const typeA = typeOf(objA);\n    const typeB = typeOf(objB);\n    switch (typeB) {\n        case 'bigint':\n        case 'number': {\n            if (typeA !== 'number' && typeA !== 'bigint') {\n                return [false, objB];\n            }\n            return [true, objA + objB];\n        }\n        case 'array': {\n            if (typeA !== 'array') {\n                return [false, objB];\n            }\n            const newArr = [];\n            let combined = true;\n            for (let i = 0; i < objB.length; i += 1) {\n                const [c, value] = recursiveCombination(objA[i], objB[i]);\n                newArr[i] = value;\n                if (c === false) {\n                    combined = false;\n                }\n            }\n            return [combined, newArr];\n        }\n        case 'object': {\n            if (typeA !== 'object') {\n                return [false, objB];\n            }\n            const newObj = {};\n            let combined = true;\n            for (const k in objB) {\n                const [c, value] = recursiveCombination(objA[k], objB[k]);\n                if (c === false) {\n                    combined = false;\n                }\n                newObj[k] = value;\n            }\n            return [combined, newObj];\n        }\n        default:\n            return [false, objB];\n    }\n}\n","import { unionSetOrArray, createEnum } from './utils.js';\n/**\n * An array of action names.\n */\nexport const Actions = [\n    'actorInput',\n    'actors',\n    'addSymbol',\n    'batch',\n    'changeComponent',\n    'components',\n    'createEntity',\n    'entities',\n    'fetchSymbol',\n    'getSymbol',\n    'mergeActors',\n    'mergeComponents',\n    'mergeEntities',\n    'mergeSymbols',\n    'mergeSymbol',\n    'removeActor',\n    'removeComponent',\n    'removeEntity',\n    'spawnActor',\n    'symbol',\n    'symbols',\n    // 'tick',\n    // 'tock',\n    'upsertComponent'\n];\n/**\n * An array of common component names.\n */\nexport const CommonComponents = [\n    'asset',\n    'collider',\n    'color',\n    'hidden',\n    'position',\n    'rotation',\n    'velocity',\n    'spin'\n];\n/**\n * A set of default symbols, which is the union of Actions and CommonComponents.\n */\nexport const DefaultSymbols = unionSetOrArray(Actions, CommonComponents);\n/**\n * Padding for the enum.\n */\nexport const padEnum = 0; // 10;\n/**\n * An enum of action names.\n */\nexport const enumActions = createEnum(Actions, padEnum);\n/**\n * An enum of common component names.\n */\nexport const enumCommonComponents = createEnum(CommonComponents, Actions.length + padEnum);\n/**\n * An enum of default symbols.\n */\nexport const enumDefaultSymbols = createEnum(DefaultSymbols, padEnum);\n/**\n * An object that maps action names to their payload sizes.\n */\nexport const batchActionPayloadSizes = {\n    actorInput: { default: 1, rollback: 2 },\n    changeComponent: { default: 3, ordered: 4 },\n    mergeSymbols: 2,\n    removeComponent: 2,\n    upsertComponent: { default: 3, ordered: 4 }\n};\n/**\n * Default options for the application.\n */\nexport const defaultOptions = {\n    compressStringsAsInts: true,\n    enableRollback: !true,\n    enableQuerying: !true,\n    isAuthority: true,\n    isAsyncStorage: false,\n    isComponentRelay: true,\n    isDiffed: false,\n    isGroupedComponents: !true,\n    isOrdered: !true,\n    isReadOnly: false,\n    isSymbolLeader: false,\n    isSymbolRelay: false,\n    pageSize: 100,\n    skipPending: false,\n    indexes: {\n        // asset: { type: 'sorted' },\n        // collider: { type: 'sorted' },\n        // color: { type: 'sorted' },\n        // hidden: { type: 'sorted' },\n        position: { type: 'spatial' },\n    },\n    types: {\n        asset: 'str',\n        collider: 'str',\n        color: ['ui8', 4],\n        hidden: 'bool',\n        position: ['f32', 3],\n        rotation: ['f32', 3],\n        velocity: ['f32', 3],\n        spin: ['f32', 3],\n        size: ['f32', 3],\n    }\n};\n/**\n * Default options for updates.\n */\nexport const defaultUpdateOptions = {\n    mask: {\n        actors: true,\n        entities: true,\n        components: true,\n        inputs: true,\n        symbols: true\n    } && null,\n    type: true,\n    batched: true,\n    batchSize: 100\n};\n/**\n * An object that maps keys to their validity.\n */\nexport const defaultValidKeys = {\n    asset: true,\n    collider: true,\n    color: true,\n    hidden: true,\n    position: true,\n    rotation: true,\n    velocity: true,\n    spin: true,\n    size: true,\n};\n/**\n * A responder function that does nothing and returns nothing.\n */\nexport function voidResponder() { }\n/**\n * A function that retrieves the actor ID from a payload.\n *\n * @param {string} id - The payload from which the actor ID is to be retrieved.\n * @param {any} _context - The current context. This parameter is not used.\n * @returns {string | undefined} The actor ID, or undefined if it cannot be found.\n */\nexport function defaultGetActorId(id, _context) {\n    return id;\n}\n/**\n * A function that retrieves the grouped value from a payload.\n *\n * @param {any | any[]} value - The payload from which the grouped value is to be retrieved.\n * @param {number} i - The index of the payload.\n * @param {Object} types - An object containing the types.\n * @param {string} key - The key of the grouped value.\n * @returns {any} The value from the group.\n */\nexport function defaultGetGroupedValue(value, i, types, key) {\n    const type = types[key];\n    if (Array.isArray(type)) {\n        return value.slice(i * type[1], (i + 1) * type[1]);\n    }\n    return value[i];\n}\n/**\n * A function that sets the grouped value in a payload.\n *\n * @param {any} value - The payload in which the grouped value is to be set.\n * @param {Object} _types - An object containing the types.\n * @param {string} _key - The key of the grouped value.\n * @returns {any} The value from the group.\n */\nexport function defaultSetGroupedValue(value, _types, _key) {\n    return value;\n}\n","/**\n * The Index class represents an index.\n */\nexport class Index {\n    items;\n    constructor(items = null, _options = {}) {\n        this.items = items;\n    }\n    /**\n     * The clear method clears the index.\n     */\n    clear() {\n        this.items = null;\n    }\n    /**\n     * The clone method clones the index.\n     */\n    clone() {\n        return new Index(this.items);\n    }\n    /**\n     * The get method gets a value from the index.\n     *\n     * @param {any} _value - The value to get from the index.\n     * @returns {any} The value from the index.\n     */\n    get(_value) { }\n    /**\n     * The has method checks if a value is in the index.\n     *\n     * @param {any} _value - The value to check in the index.\n     * @param {any} _id - The ID of the value to check in the index.\n     * @returns {boolean} True if the value is in the index, false otherwise.\n     */\n    has(_value, _id) {\n        return false;\n    }\n    /**\n     * The remove method removes a value from the index.\n     *\n     * @param {any} _value - The value to remove from the index.\n     * @param {any} _id - The ID of the value to remove from the index.\n     * @returns {any} The value removed from the index.\n     */\n    remove(_value, _id) { }\n    /**\n     * The set method sets a value to the index.\n     *\n     * @param {any} _value - The value to set to the index.\n     * @param {any} _id - The ID to set to the index.\n     * @returns {any} The value being set.\n     */\n    set(_value, _id) {\n        return null;\n    }\n    /**\n   * The store method stores a value to the index.\n   *\n   * @param {ID} id - The ID of the value to store.\n   * @param {V} preValue - The previous value to store to the index.\n   * @param {V} value - The value to store to the index.\n   * @returns The value being stored.\n   */\n    store(id, preValue, value) {\n        if (preValue) {\n            this.remove(preValue, id);\n        }\n        return this.set(value, id);\n    }\n    /**\n     * The query method queries the index.\n     *\n     * @param {any} _query - The query to use.\n     * @returns {any[]} The result of the query.\n     */\n    query(_query) {\n        return [];\n    }\n}\n","import { Index } from './index.js';\nimport { \n// SetExperimental,\ndifferenceSets, intersectionSets, unionSets, } from '../utils.js';\n/**\n * The Index class represents an index.\n */\nexport class ComponentsIndex extends Index {\n    constructor(items = {}, _options = {}) {\n        super(items);\n    }\n    /**\n     * The clear method clears the index.\n     */\n    clear() {\n        this.items = {};\n    }\n    /**\n     * The clone method clones the index.\n     */\n    clone() {\n        return new Index(this.items);\n    }\n    /**\n     * The get method gets a value from the index.\n     *\n     * @param {any} value - The value to get from the index.\n     * @returns {any} The value from the index.\n     */\n    get(value) {\n        return this.items[value];\n    }\n    /**\n     * The has method checks if a value is in the index.\n     *\n     * @param {any} value - The value to check in the index.\n     * @param {any} id - The ID of the value to check in the index.\n     * @returns {boolean} True if the value is in the index, false otherwise.\n     */\n    has(value, id) {\n        const ids = this.items[value];\n        if (ids && ids.has(id)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The remove method removes a value from the index.\n     *\n     * @param {any} value - The value to remove from the index.\n     * @param {any} id - The ID of the value to remove from the index.\n     * @returns {any} The value removed from the index.\n     */\n    remove(value, id) {\n        const ids = this.items[value];\n        if (ids && ids.has(id)) {\n            ids.delete(id);\n            return true;\n        }\n    }\n    /**\n     * The set method sets a value to the index.\n     *\n     * @param {any} value - The value to set to the index.\n     * @param {any} id - The ID to set to the index.\n     * @returns {any} The value being set.\n     */\n    set(value, id) {\n        this.items[value] = this.items[value] || new Set();\n        if (this.items[value].has(id)) {\n            return false;\n        }\n        this.items[value].add(id);\n        return true;\n    }\n    /**\n     * The union method creates an union of two indexes.\n     *\n     * @param {string} key - The key of the index.\n     * @param {Index} other - The other index.\n     * @returns {Index} The union of the indexes.\n     */\n    union(key, other) {\n        return new ComponentsIndex({\n            ...this.items,\n            [key]: unionSets(this.items[key], other.items[key])\n        });\n    }\n    /**\n     * The difference method creates a difference of two indexes.\n     *\n     * @param {string} key - The key of the index.\n     * @param {Index} other - The other index.\n     * @returns {Index} The difference of the indexes.\n     */\n    difference(key, other) {\n        return new ComponentsIndex({\n            ...this.items,\n            [key]: differenceSets(this.items[key], other.items[key])\n        });\n    }\n    /**\n     * The intersection method creates an intersection of two indexes.\n     *\n     * @param {string} key - The key of the index.\n     * @param {Index} other - The other index.\n     * @returns {Index} The intersection of the indexes.\n     */\n    intersection(key, other) {\n        return new ComponentsIndex({\n            ...this.items,\n            [key]: intersectionSets(this.items[key], other.items[key])\n        });\n    }\n    /**\n    * The query method queries the index.\n    *\n    * @param {any} query - The query to use.\n    * @returns {any[]} The result of the query.\n    */\n    query(query) {\n        const { with: with_, without,\n        // where,\n         } = query || {};\n        let matches = new Set();\n        if (with_) {\n            for (const key of with_) {\n                const ids = this.items[key];\n                if (ids) {\n                    matches = unionSets(matches, ids);\n                }\n            }\n        }\n        if (without) {\n            for (const key of without) {\n                const ids = this.items[key];\n                if (ids) {\n                    matches = differenceSets(matches, ids);\n                }\n            }\n        }\n        return matches;\n    }\n}\n","import { Index } from './index.js';\nimport { binaryInsert } from '../utils.js';\n/**\n * binaryInsertID inserts an ID value into a sorted array.\n *\n * @param {any[]} items - The sorted array\n * @param {any} value - The value to insert\n * @param {any} id - The ID of the value to insert\n * @returns {number[]} The index of the inserted value\n */\nfunction binaryInsertID(items, value, id) {\n    if (!items) {\n        return [0, 0];\n    }\n    const low = binaryInsert(items, value, (item) => item[0]);\n    const item = items[low];\n    const v = item; // [0] || item;\n    if (v === value) {\n        const ids = item[1];\n        const i = ids.indexOf(id);\n        if (i === -1) {\n            ids.push(id);\n            return [low, ids.length - 1];\n        }\n        else {\n            // return [low, i]\n        }\n    }\n    else {\n        const ids = [id];\n        items.splice(low, 0, [value, ids]);\n        return [low, 0];\n    }\n    return [-1, -1];\n}\n/**\n * binaryRemove removes a value from a sorted array.\n *\n * @param {any[]} items - The sorted array\n * @param {any} value - The value to remove\n * @param {any} id - The ID of the value to remove\n * @returns {number[]} The index of the removed value\n */\nfunction binaryRemoveID(items, value, id) {\n    if (!items) {\n        return [-1, -1];\n    }\n    const low = binaryInsert(items, value, (item) => item[0]);\n    const item = items[low];\n    const v = item; // [0] || item;\n    if (v === value) {\n        const ids = item[1];\n        const i = ids.lastIndexOf(id);\n        if (i !== -1) {\n            ids.splice(i, 1);\n            if (ids.length === 0) {\n                items.splice(low, 1);\n            }\n            return [low, i];\n        }\n    }\n    return [-1, -1];\n}\n/**\n * SortedIndex class represents a sorted index.\n */\nexport class SortedIndex extends Index {\n    constructor(items = [], _options = {}) {\n        super(items);\n    }\n    /**\n     * The clear method clears the index.\n     */\n    clear() {\n        this.items = [];\n    }\n    /**\n     * The clone method clones the index.\n     */\n    clone() {\n        return new SortedIndex(this.items);\n    }\n    /**\n     * The get method gets a value from the index.\n     *\n     * @param {V} value - The value to get from the index.\n     * @returns {ID[]} The value from the index.\n     */\n    get(value) {\n        const item = this.items.find((item) => item[0] === value);\n        if (item) {\n            return item[1];\n        }\n        return [];\n    }\n    /**\n     * The has method checks if a value is in the index.\n     *\n     * @param {V} value - The value to check in the index.\n     * @param {ID} id - The ID of the value to check in the index.\n     * @returns {boolean} True if the value is in the index, false otherwise.\n     */\n    has(value, id) {\n        const item = this.items.find((item) => item[0] === value);\n        if (id === undefined) {\n            return !!item;\n        }\n        if (item) {\n            const ids = item[1];\n            return ids.indexOf(id) !== -1;\n        }\n        return false;\n    }\n    /**\n     * The remove method removes a value from the index.\n     *\n     * @param {T} value - The value to remove from the index.\n     * @returns {number[]} The value removed from the index.\n     */\n    remove(value, id) {\n        const indexes = binaryRemoveID(this.items, value, id);\n        return indexes;\n        // return indexes[0] === -1 || indexes[1] === -1 ? null : value \n    }\n    /**\n     * The set method sets a value to the index.\n     *\n     * @param {T} value - The value to set to the index.\n     * @param {ID} id - The ID of the value to set to the index.\n     * @returns {number[]} The index of the value being set.\n     */\n    set(value, id) {\n        const indexes = binaryInsertID(this.items, value, id);\n        return indexes;\n    }\n    /**\n     * The query method queries the manager.\n     *\n     * @param {V} query - The query to use.\n     * @returns {ID[]} The result of the query.\n     */\n    query(query) {\n        // if (query && typeof query === 'object') {}\n        return this.get(query);\n    }\n}\n","import { Index } from './index.js';\nimport { binarySearch } from '../utils.js';\n/**\n * The SpatialIndex class represents a spatial index.\n */\nexport class SpatialIndex extends Index {\n    constructor(items = [], { cellSize = 5 } = {}) {\n        super(items);\n        this.cellSize = cellSize;\n    }\n    /**\n     * The clear method clears the index.\n     */\n    clear() {\n        this.items = [];\n    }\n    /**\n     * The clone method clones the index.\n     */\n    clone() {\n        return new SpatialIndex(this.items);\n    }\n    /**\n     * The get method gets a value from the index.\n     *\n     * @param {V} value - The value to get from the index.\n     * @returns {ID[]} The value from the index.\n     */\n    get(value) {\n        const hash = this.hash(value);\n        this.items[hash] = this.items[hash] || [];\n        const ids = this.items[hash];\n        if (ids) {\n            return ids;\n        }\n        return [];\n    }\n    /**\n     * The has method checks if a value is in the index.\n     *\n     * @param {V} value - The value to check in the index.\n     * @param {ID} id - The ID of the value to check in the index.\n     * @returns {boolean} True if the value is in the index, false otherwise.\n     */\n    has(value, id) {\n        const hash = this.hash(value);\n        this.items[hash] = this.items[hash] || [];\n        const ids = this.items[hash];\n        if (id === undefined) {\n            return !!ids;\n        }\n        if (ids) {\n            return ids.indexOf(id) !== -1;\n        }\n        return false;\n    }\n    /**\n     * The hash method hashes 2D or 3D value.\n     * @param {number[]} value - The 2D or 3D value to hash.\n     * @returns {number} The hash of the value.\n     */\n    hash(value) {\n        if (value.length === 2) {\n            return this.hash2d(value[0], value[1]);\n        }\n        return this.hash3d(value[0], value[1], value[2]);\n    }\n    /**\n     * The hash2d method hashes a 2D value.\n     * @param {number} x - The X value to hash.\n     * @param {number} y - The Y value to hash.\n     * @returns {number} The hash of the 3D value.\n     */\n    hash2d(x = 0, y = 0) {\n        const ix = Math.floor((x + 1000) / this.cellSize), iy = Math.floor((y + 1000) / this.cellSize);\n        return ((ix * 73856093) ^ (iy * 19349663)); // % 5000; // 5000 is size of hash table.\n    }\n    /**\n     * The hash3d method hashes a 3D value.\n     * @param {number} x - The X value to hash.\n     * @param {number} y - The Y value to hash.\n     * @param {number} z - The Z value to hash.\n     * @returns {number} The hash of the 3D value.\n     */\n    hash3d(x = 0, y = 0, z = 0) {\n        const ix = Math.floor((x + 1000) / this.cellSize), iy = Math.floor((y + 1000) / this.cellSize), iz = Math.floor((z + 1000) / this.cellSize);\n        return ((ix * 73856093) ^ (iy * 19349663) ^ (iz * 83492791)); // % 5000; // 5000 is size of hash table.\n    }\n    /**\n     * The remove method removes a value from the index.\n     *\n     * @param {T} value - The value to remove from the index.\n     * @returns {number[]} The value removed from the index.\n     */\n    remove(value, id) {\n        const hash = this.hash(value);\n        this.items[hash] = this.items[hash] || [];\n        const ids = this.items[hash];\n        const [index] = binarySearch(ids, id);\n        if (index === -1) {\n            ids.splice(index, 1);\n        }\n        if (ids.length === 0) {\n            delete this.items[hash];\n        }\n        return [hash, index];\n    }\n    /**\n     * The set method sets a value to the index.\n     *\n     * @param {T} value - The value to set to the index.\n     * @param {ID} id - The ID of the value to set to the index.\n     * @returns {number[]} The index of the value being set.\n     */\n    set(value, id) {\n        const hash = this.hash(value);\n        this.items[hash] = this.items[hash] || [];\n        const ids = this.items[hash];\n        const [index, left] = binarySearch(ids, id);\n        if (index === -1) {\n            ids.splice(left, 0, id);\n        }\n        return [hash, index];\n    }\n    /**\n     * The query method queries the manager.\n     *\n     * @param {V} query - The query to use.\n     * @returns {ID[]} The result of the query.\n     */\n    query(query) {\n        let results = [];\n        const o = this.cellSize;\n        const dims = query.length === 2 ? 2 : 3;\n        if (dims === 2) {\n            const [x, y] = query;\n            for (let xx = -o * 2; xx < o * 2 + o; xx += o) {\n                for (let yy = -o * 2; yy < o * 2 + o; yy += o) {\n                    const ids = this.items[this.hash2d(x + xx, y + yy)];\n                    if (ids !== undefined) {\n                        results = results.concat(ids);\n                    }\n                }\n            }\n        }\n        else {\n            const [x, y, z] = query;\n            for (let xx = -o * 2; xx < o * 2 + o; xx += o) {\n                for (let yy = -o * 2; yy < o * 2 + o; yy += o) {\n                    for (let zz = -o * 2; zz < o * 2 + o; zz += o) {\n                        const ids = this.items[this.hash3d(x + xx, y + yy, z + zz)];\n                        if (ids !== undefined) {\n                            results = results.concat(ids);\n                        }\n                    }\n                }\n            }\n        }\n        return results;\n    }\n}\n","import { typeOf } from './utils.js';\n/**\n * The Changes class provides methods for managing changes in a context.\n *\n * @property {Context} context - The context in which changes are to be managed.\n * @property {Record<string, any>} diffs - The diffs of the changes.\n */\nexport class Changes {\n    context;\n    diffs;\n    /**\n     * Creates a new instance of the Changes class.\n     *\n     * @param {Context} context - The context in which changes are to be managed.\n     * @param {ChangesInput} changes - An optional initial set of changes.\n     */\n    constructor(context, changes) {\n        this.context = context;\n        this.diffs = changes?.diffs || {};\n    }\n    /**\n     * Changes a component in the current context.\n     *\n     * @param {string} id - The ID of the component to be changed.\n     * @param {string} key - The key of the property to be changed.\n     * @param {any} newValue - The new value of the property.\n     * @param {any} prevValue - The previous value of the property.\n     * @param {boolean} isAsyncStorage - Whether the storage is asynchronous.\n     * @returns {Promise<any[]>} The new value.\n     */\n    changeComponent(id, key, newValue, prevValue, isAsyncStorage = false) {\n        return this.upsertComponent(id, key, newValue, prevValue, isAsyncStorage);\n    }\n    /**\n     * Retrieves the changes of a value.\n     *\n     * @param {string} id - The ID of the component.\n     * @param {string} key - The key of the property.\n     * @param {any} storedValue - The stored value.\n     * @returns {Record<string, any>} The diffs.\n     */\n    getValue(id, key, storedValue) {\n        const diffedValue = this.diffs[id]?.[key];\n        if (diffedValue === undefined || diffedValue === null) {\n            return storedValue;\n        }\n        return diffedValue;\n    }\n    /**\n     * Resets the changes to a new set of changes or an empty object if no changes are provided.\n     *\n     * @param {ChangesInput} changes - The new set of changes.\n     * @returns {Changes} The instance of the Changes class.\n     */\n    reset(changes) {\n        this.diffs = changes?.diffs || {};\n        return this;\n    }\n    /**\n     * Updates an existing component or inserts a new one if it doesn't exist in the current context.\n     *\n     * @param {string} id - The ID of the component to be updated or inserted.\n     * @param {string} key - The key of the property to be updated or inserted.\n     * @param {any} newValue - The new value of the property.\n     * @param {any} _prevValue - The previous value of the property.\n     * @param {boolean} isAsyncStorage - Whether the storage is asynchronous.\n     * @returns {Promise<any[]>} The new value.\n     */\n    upsertComponent(id, key, newValue, _prevValue, isAsyncStorage = false) {\n        this.diffs[id] = this.diffs[id] || {};\n        const currentScopeOrPromise = this.context.store.findComponents(id);\n        const promises = [];\n        const completeUpsertComponent = (currentScope) => {\n            if (currentScope === undefined || currentScope === null) {\n                this.diffs[id][key] = newValue;\n                const promise = this.context.store.storeComponent(id, key, newValue);\n                if (isAsyncStorage && promise instanceof Promise) {\n                    promises.push(promise);\n                }\n                return newValue;\n            }\n            let diffObject = this.diffs[id];\n            const recursiveDiff = (key, diff, scope, currVal) => {\n                let nextVal = currVal;\n                if (!scope) {\n                    return [diff, nextVal];\n                }\n                const prevType = typeOf(scope[key]);\n                const nextType = typeOf(nextVal);\n                if (prevType !== nextType) {\n                    diff[key] = nextVal;\n                    diff = diff[key];\n                    return [diff, nextVal];\n                }\n                switch (nextType) {\n                    case 'bigint':\n                    case 'number': {\n                        const v1 = scope[key];\n                        const v2 = nextVal;\n                        const d = v2 - v1;\n                        // scope[key] = v2\n                        diff[key] = d;\n                        break;\n                    }\n                    case 'array':\n                        diff = diff[key];\n                        scope = scope[key];\n                        for (let i = 0; i < nextVal.length; i += 1) {\n                            // if (nextVal[i] === undefined || nextVal[i] === null) {\n                            //   nextVal[i] = []\n                            // }\n                            recursiveDiff(i.toString(), diff, scope, nextVal[i]);\n                        }\n                        break;\n                    case 'object':\n                        diff = diff[key];\n                        scope = scope[key];\n                        for (const k in nextVal) {\n                            // if (nextVal[k] === undefined || nextVal[k] === null) {\n                            //   nextVal[k] = {}\n                            // }\n                            recursiveDiff(k, diff, scope, nextVal[k]);\n                        }\n                        break;\n                    case 'string':\n                    // TODO: append with deletes?\n                    case 'boolean':\n                    default:\n                        diff[key] = nextVal;\n                }\n                diff = diff[key];\n                nextVal = nextVal[key];\n                return [diff, currVal];\n            };\n            [diffObject, newValue] = recursiveDiff(key, diffObject, currentScope, newValue);\n            const promise = this.context.store.storeComponent(id, key, newValue);\n            if (isAsyncStorage && promise instanceof Promise) {\n                promises.push(promise);\n            }\n            return newValue;\n        };\n        if (isAsyncStorage && currentScopeOrPromise instanceof Promise) {\n            return new Promise((resolve, reject) => {\n                currentScopeOrPromise.then((currentScope) => {\n                    completeUpsertComponent(currentScope);\n                    if (promises.length === 0) {\n                        return Promise.all(promises).then(() => resolve(newValue), reject);\n                    }\n                    return resolve(newValue);\n                });\n            });\n        }\n        return completeUpsertComponent(currentScopeOrPromise);\n    }\n}\nexport default Changes;\n","/**\n * Emitter\n *\n * @template T\n * @class Emitter\n * @description An Emitter is a class that emits values to its handlers.\n * @property {Function[]} handlers - The handlers of the Emitter.\n * @method emitTo - Adds a handler to the Emitter and returns the handler.\n * @method emit - Emits a value to the handlers of the Emitter.\n * @example\n * const emitter = new Emitter()\n * const handler = emitter.emitTo((value) => {\n *  console.log(value)\n * })\n * emitter.emit('Hello, world!')\n * emitter.done() // cleanup\n * // => 'Hello, world!'\n */\nexport class Emitter {\n    handlers;\n    emissions;\n    handlersDone;\n    emissionsDone;\n    /**\n     * Constructs a new Emitter object.\n     */\n    constructor(emissions = [], emissionsDone = false, handlers = [], handlersDone = false) {\n        this.handlers = handlers;\n        this.emissions = emissions;\n        for (const handler of this.handlers) {\n            for (const emission of this.emissions) {\n                handler(emission);\n            }\n        }\n        this.handlersDone = emissionsDone;\n        this.emissionsDone = handlersDone;\n        this.cleanup();\n    }\n    /**\n     * Cleans up the Emitter.\n     */\n    cleanup() {\n        if (this.handlersDone && this.emissionsDone) {\n            this.clear();\n        }\n    }\n    /**\n     * Clears all handlers and emissions from the Emitter.\n     */\n    clear() {\n        this.handlers = [];\n        this.emissions = [];\n        this.handlersDone = false;\n        this.emissionsDone = false;\n    }\n    /**\n     * Marks the Emitter as done.\n     *\n     * @param {boolean} handlersDone - Whether or not the Emitter is done emitting values.\n     * @param {boolean} emissionsDone - Whether or not the Emitter is done emitting values.\n     */\n    done(handlersDone = true, emissionsDone = true) {\n        this.handlersDone = handlersDone;\n        this.emissionsDone = emissionsDone;\n        this.cleanup();\n    }\n    /**\n     * Adds a handler to the Emitter and returns the handler.\n     *\n     * @param {Function} handler - The handler to add to the Emitter.\n     * @param {boolean} handlersDone - Whether or not the Emitter is done emitting values.\n     * @returns {Function} The handler.\n     */\n    emitTo(handler, handlersDone = false) {\n        this.handlers.push(handler);\n        for (const emission of this.emissions) {\n            handler(emission);\n        }\n        this.handlersDone = handlersDone;\n        this.cleanup();\n    }\n    /**\n     * Emits a value to the handlers of the Emitter.\n     *\n     * @param {T} value - The value to emit to the handlers of the Emitter.\n     * @param {boolean} emissionsDone - Whether or not the Emitter is done emitting values.\n     */\n    emit(value, emissionsDone = false) {\n        this.emissions.push(value);\n        for (const handler of this.handlers) {\n            handler(value);\n        }\n        this.emissionsDone = emissionsDone;\n        this.cleanup();\n    }\n    /**\n     * Removes a handler from the Emitter.\n     *\n     * @param {Function} handler - The handler to remove from the Emitter.\n     */\n    removeHandler(handler) {\n        const index = this.handlers.indexOf(handler);\n        if (index !== -1) {\n            this.handlers.splice(index, 1);\n        }\n    }\n    /**\n     * Removes an emission from the Emitter.\n     *\n     * @param {T} emission - The emission to remove from the Emitter.\n     */\n    removeEmission(emission) {\n        const index = this.emissions.indexOf(emission);\n        if (index !== -1) {\n            this.emissions.splice(index, 1);\n        }\n    }\n}\nexport default Emitter;\n","import { createEnum } from './utils.js';\n/**\n * The Symbols class represents a collection of symbols.\n */\nexport class Symbols {\n    _list;\n    _enum;\n    /**\n     * Constructs a new Symbols object.\n     *\n     * @param {object} object - An object containing an optional list of symbols.\n     */\n    constructor(object = {}) {\n        const { _list: symbols = [] } = object;\n        this._list = symbols;\n        this._enum = createEnum(symbols);\n    }\n    /**\n     * Adds a symbol to the Symbols object.\n     *\n     * @param {string} symbol - The symbol to be added.\n     * @returns {number | null} The index of the added symbol, or null if the symbol is not valid.\n     */\n    add(symbol) {\n        if (symbol) {\n            if (Object.prototype.hasOwnProperty.call(this._enum, symbol)) {\n                return this._enum[symbol];\n            }\n            else {\n                const end = this._list.length;\n                this._list[end] = symbol;\n                this._enum[symbol] = end;\n                return end;\n            }\n        }\n        return null;\n    }\n    /**\n     * Copies an enum into the Symbols object.\n     *\n     * @param {Enum} enumObj - The enum to be copied.\n     */\n    copyEnum(enumObj = {}) {\n        for (const symbolTuple of Object.entries(enumObj)) {\n            this.merge(symbolTuple);\n        }\n    }\n    /**\n     * Fetches a symbol and its index based on a payload.\n     *\n     * @param {number | string} payload - The payload, which can be either a symbol or an index.\n     * @returns {[string, number]} A tuple containing the symbol and its index.\n     */\n    fetch(payload) {\n        let index;\n        let symbol;\n        switch (typeof payload) {\n            case 'number':\n                index = payload;\n                symbol = this._list[index] || '';\n                break;\n            case 'string':\n                symbol = payload;\n                index = Object.prototype.hasOwnProperty.call(this._enum, symbol) ? this._enum[symbol] : -1;\n                break;\n        }\n        return [symbol, index];\n    }\n    /**\n     * Finds the index of a symbol.\n     *\n     * @param {string} symbol - The symbol to be found.\n     * @returns {number | undefined} The index of the symbol, or undefined if the symbol is not found.\n     */\n    find(symbol) {\n        return this._enum[symbol];\n    }\n    /**\n     * Gets the symbol at a specific index.\n     *\n     * @param {number} index - The index of the symbol.\n     * @returns {string | undefined} The symbol at the specified index, or undefined if there is no symbol at that index.\n     */\n    get(index) {\n        return this._list[index];\n    }\n    /**\n     * Returns the list of symbols.\n     *\n     * @returns {string[]} The list of symbols.\n     */\n    getSymbols() {\n        return this._list;\n    }\n    /**\n     * Returns the enum of symbols.\n     *\n     * @returns {Enum} The enum of symbols.\n     */\n    getSymbolsEnum() {\n        return this._enum;\n    }\n    /**\n     * Merges a symbol tuple into the Symbols object.\n     *\n     * @param {[string, number]} symbolTuple - The symbol tuple to be merged.\n     */\n    merge(symbolTuple) {\n        const [symbol, index] = symbolTuple;\n        this._list[index] = symbol;\n        this._enum[symbol] = index;\n    }\n    /**\n     * Resets the Symbols object with a new array of symbols.\n     *\n     * @param {string[]} symbolsArray - The new array of symbols.\n     */\n    reset(offset, symbolsArray = []) {\n        if (offset > 0) {\n            const { length } = symbolsArray;\n            const { _list } = this;\n            const { _enum } = this;\n            for (let i = 0; i < length; i++) {\n                const symbol = symbolsArray[i];\n                const index = i + offset;\n                _list[index] = symbol;\n                _enum[symbol] = index;\n            }\n        }\n        else {\n            this._list = symbolsArray;\n            this._enum = createEnum(symbolsArray);\n        }\n    }\n}\nexport default Symbols;\n/**\n * Extracts a symbol from a given index.\n *\n * @param {number | string} index - The index or symbol to be extracted.\n * @param {any} context - The context in which the symbol is to be extracted.\n * @param {any} options - The options for extracting the symbol.\n * @returns {string | number} The extracted symbol.\n */\nexport function extractSymbol(index, context, options) {\n    if (typeof index === 'number') {\n        const { actions } = options;\n        const { getSymbol } = actions;\n        const symbol = getSymbol(index, context, options);\n        if (!symbol) {\n            return '';\n        }\n        index = symbol;\n    }\n    return index;\n}\n/**\n * Ensures that a symbol is indexed.\n *\n * @param {number | string} symbol - The symbol to be indexed.\n * @param {any} context - The context in which the symbol is to be indexed.\n * @param {any} options - The options for indexing the symbol.\n * @returns {number | string} The indexed symbol.\n */\nexport function ensureSymbolIndex(symbol, context, options) {\n    if (typeof symbol === 'string') {\n        const { actions } = options;\n        const { addSymbol } = actions;\n        const index = addSymbol(symbol, context, options);\n        if (typeof index === 'number') {\n            return index;\n        }\n    }\n    return symbol;\n}\n/**\n * Recursively extracts symbols from a given value.\n *\n * @param {string} key - The key associated with the value.\n * @param {any} value - The value from which symbols are to be extracted.\n * @param {any} context - The context in which the symbols are to be extracted.\n * @param {any} options - The options for extracting symbols.\n * @returns {any} The value with extracted symbols.\n */\nexport function recursiveSymbolExtraction(key, value, context, options) {\n    if (key.charAt(0) === '$') {\n        const { actions } = options;\n        const { getSymbol } = actions;\n        const recursiveFix = (value) => {\n            if (Array.isArray(value)) {\n                value = value.map(recursiveFix);\n            }\n            else {\n                switch (typeof value) {\n                    case 'number': {\n                        const symbol = getSymbol(value, context, options);\n                        if (symbol) {\n                            value = symbol;\n                        }\n                        break;\n                    }\n                    case 'object':\n                        for (const key in value) {\n                            value[key] = recursiveFix(value[key]);\n                        }\n                        break;\n                }\n                return value;\n            }\n        };\n        return recursiveFix(value);\n    }\n    return value;\n}\n/**\n * Recursively ensures that symbols in a given value are indexed.\n *\n * @param {string} key - The key associated with the value.\n * @param {any} value - The value in which symbols are to be indexed.\n * @param {any} context - The context in which the symbols are to be indexed.\n * @param {any} options - The options for indexing symbols.\n * @returns {any} The value with indexed symbols.\n */\nexport function recursiveSymbolIndexesEnsured(key, value, context, options) {\n    if (key.charAt(0) === '$') {\n        const { actions } = options;\n        const { addSymbol } = actions;\n        const recursiveFix = (value) => {\n            if (Array.isArray(value)) {\n                value = value.map(recursiveFix);\n            }\n            else {\n                switch (typeof value) {\n                    case 'string': {\n                        const symbol = addSymbol(value, context, options);\n                        if (typeof symbol === 'number') {\n                            value = symbol;\n                        }\n                        break;\n                    }\n                    case 'object':\n                        for (const key in value) {\n                            value[key] = recursiveFix(value[key]);\n                        }\n                        break;\n                }\n                return value;\n            }\n        };\n        return recursiveFix(value);\n    }\n    return value;\n}\n","import { Options } from '../options.js';\nimport { extractSymbol } from '../symbols.js';\n/**\n * Creates a new instance of the ActorActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the ActorActions class.\n * @returns {any} - A new class that extends the provided Parent class and the ActorActions class.\n */\nexport const ActorActionsFactory = (Parent = Object) => class ActorActions extends Parent {\n    /**\n     * Handles input for a specific actor in the current context.\n     *\n     * @param {any[] | InputPayload} payload - The payload containing the actor's id and the input to be handled.\n     * @param {Context} context - The current context in which the actor input is to be handled.\n     * @param {Options | any} options - The options for handling the actor input. If an instance of Options is not provided, a new one will be created.\n     */\n    actorInput(payload, context, options) {\n        options = Options.ensure(options, this);\n        const { getActorId, compressStringsAsInts } = options;\n        let input;\n        let tick = 0;\n        if (Array.isArray(payload)) {\n            input = payload[0];\n            tick = payload[1] || 0;\n        }\n        else {\n            input = payload;\n        }\n        let id = getActorId(input?.id, context);\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        if (!input?.id) {\n            input.id = id;\n        }\n        context.actorInput(id, input, tick, options);\n    }\n    /**\n     * Retrieves actors from the current context and sends them to the responder.\n     *\n     * @param {any} payload - This parameter is not used in the function.\n     * @param {Context} context - The current context from which the actors are retrieved.\n     * @param {Options | any} options - The options for retrieving actors. If an instance of Options is not provided, a new one will be created.\n     */\n    actors(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, isAuthority, isAsyncStorage, pageSize, enableQuerying, enumDefaultSymbols } = options;\n        if (!isAuthority) {\n            return;\n        }\n        const sendActors = (pages) => {\n            // send pages to responder\n            for (const page of pages) {\n                responder([enumDefaultSymbols.mergeActors, page]);\n            }\n        };\n        const ctxActors = context.getActors(enableQuerying ? payload : null, pageSize);\n        if (isAsyncStorage) {\n            ctxActors.emitTo(sendActors, true);\n        }\n        else {\n            sendActors(ctxActors);\n        }\n    }\n    /**\n     * Merges actors into the current context.\n     *\n     * @param {any[]} payload - The payload containing the actors to be merged.\n     * @param {Context} context - The current context in which the actors are to be merged.\n     * @param {Options | any} options - The options for merging. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeActors(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        context.mergeActors(payload, options);\n    }\n    /**\n     * Removes an actor from the current context.\n     *\n     * @param {any} id - The identifier for the actor to be removed.\n     * @param {Context} context - The current context from which the actor is to be removed.\n     * @param {Options | any} options - The options for removing the actor. If an instance of Options is not provided, a new one will be created.\n     */\n    removeActor(id, context, options) {\n        options = options = Options.ensure(options, this);\n        const { skipPending, getActorId, compressStringsAsInts } = options;\n        id = getActorId(id, context);\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        context.removeActor(id, skipPending);\n    }\n    /**\n     * Spawns a new actor in the current context.\n     *\n     * @param {any} id - The identifier for the actor to be spawned.\n     * @param {Context} context - The current context in which the actor is to be spawned.\n     * @param {OptionsExtended | any} options - The options for spawning the actor. If an instance of Options is not provided, a new one will be created.\n     */\n    spawnActor(id, context, options) {\n        options = options = Options.ensure(options, this);\n        const { skipPending, getActorId, compressStringsAsInts } = options;\n        id = getActorId(id, context);\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        context.spawnActor(id, skipPending);\n    }\n};\n/**\n * Class representing actions that can be performed on actors.\n * This class encapsulates the logic for merging, spawning, removing, and handling input for actors.\n */\nexport class ActorActions extends ActorActionsFactory() {\n}\nconst __ActorActions__ = new ActorActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the ActorActions class.\n */\nexport const actions = {\n    /**\n     * Handles input for a specific actor in the current context.\n     */\n    actorInput: __ActorActions__.actorInput,\n    /**\n     * Retrieves actors from the current context.\n     */\n    actors: __ActorActions__.actors,\n    /**\n     * Merges actors into the current context.\n     */\n    mergeActors: __ActorActions__.mergeActors,\n    /**\n     * Removes an actor from the current context.\n     */\n    removeActor: __ActorActions__.removeActor,\n    /**\n     * Spawns a new actor in the current context.\n     */\n    spawnActor: __ActorActions__.spawnActor\n};\nexport default actions;\n","import { Options } from '../options.js';\nimport { extractSymbol, recursiveSymbolExtraction } from '../symbols.js';\n/**\n * Creates a new instance of the ComponentActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the ComponentActions class.\n * @returns {any} - A new class that extends the provided Parent class and the ComponentActions class.\n */\nexport const ComponentActionsFactory = (Parent = Object) => class ComponentActions extends Parent {\n    /**\n     * Changes a component in the current context.\n     *\n     * @param {any[]} payload - The payload containing the component's id, key, and the new value.\n     * @param {Context} context - The current context in which the component is to be changed.\n     * @param {Options | any} options - The options for changing the component. If an instance of Options is not provided, a new one will be created.\n     */\n    changeComponent(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { compressStringsAsInts, types, isOrdered } = options;\n        let [id, key, value] = payload;\n        let tick = isOrdered ? payload[3] : 0;\n        if (id === undefined || id === null || id === '' ||\n            key === undefined || key === null || key === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (!id) {\n                return;\n            }\n            key = extractSymbol(key, context, options);\n            if (!key) {\n                return;\n            }\n            const type = types[key];\n            if (type && (type === String || type[0] === String)) {\n                value = recursiveSymbolExtraction(key, value, context, options);\n                if (!value) {\n                    return;\n                }\n            }\n        }\n        return context.changeComponent(id, key, value, tick, options);\n    }\n    /**\n     * Retrieves components from the current context and sends them to the responder.\n     *\n     * @param {any} payload - The payload containing the request for components.\n     * @param {Context} context - The current context from which the components are retrieved.\n     * @param {Options | any} options - The options for retrieving components. If an instance of Options is not provided, a new one will be created.\n     */\n    components(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, isAuthority, isAsyncStorage, pageSize, enableQuerying, enumDefaultSymbols } = options;\n        if (!isAuthority) {\n            return;\n        }\n        const sendComponents = (pages) => {\n            // return responder([enumDefaultSymbols.mergeComponents, components])\n            // send pages to responder\n            for (const page of pages) {\n                responder([\n                    enumDefaultSymbols.mergeComponents,\n                    page\n                ]);\n            }\n        };\n        const ctxComponents = context.getComponents(enableQuerying ? payload : null, pageSize);\n        if (isAsyncStorage) {\n            ctxComponents.emitTo(sendComponents, true);\n        }\n        else {\n            sendComponents(ctxComponents);\n        }\n    }\n    /**\n     * Merges components into the current context.\n     *\n     * @param {any[]} payload - The payload containing the components to be merged.\n     * @param {Context} context - The current context in which the components are to be merged.\n     * @param {Options | any} options - The options for merging. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeComponents(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        context.mergeComponents(payload, options);\n    }\n    /**\n     * Removes a component from the current context.\n     *\n     * @param {any[]} payload - The payload containing the component's id and key to be removed.\n     * @param {Context} context - The current context from which the component is to be removed.\n     * @param {Options | any} options - The options for removing the component. If an instance of Options is not provided, a new one will be created.\n     */\n    removeComponent(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { compressStringsAsInts } = options;\n        let [id, key] = payload;\n        if (id === undefined || id === null || id === '' ||\n            key === undefined || key === null || key === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (!id) {\n                return;\n            }\n            key = extractSymbol(key, context, options);\n            if (!key) {\n                return;\n            }\n        }\n        context.removeComponent(id, key, options);\n    }\n    /**\n     * Inserts a new component or updates an existing one in the current context.\n     *\n     * @param {any[]} payload - The payload containing the component's id, key, and the new value.\n     * @param {Context} context - The current context in which the component is to be upserted.\n     * @param {OptionsExtended | any} options - The options for upserting the component. If an instance of Options is not provided, a new one will be created.\n     */\n    upsertComponent(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { compressStringsAsInts, types, isOrdered } = options;\n        let [id, key, value] = payload;\n        let tick = isOrdered ? payload[3] : 0;\n        if (id === undefined || id === null || id === '' ||\n            key === undefined || key === null || key === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (!id) {\n                return;\n            }\n            key = extractSymbol(key, context, options);\n            if (!key) {\n                return;\n            }\n            const type = types[key];\n            if (type && (type === String || type[0] === String)) {\n                value = recursiveSymbolExtraction(key, value, context, options);\n                if (!value) {\n                    return;\n                }\n            }\n        }\n        return context.upsertComponent(id, key, value, tick, options);\n    }\n};\n/**\n * Class representing actions that can be performed on components.\n * This class encapsulates the logic for merging, retrieving, and changing components.\n */\nexport class ComponentActions extends ComponentActionsFactory() {\n}\nconst __ComponentActions__ = new ComponentActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the ComponentActions class.\n */\nexport const actions = {\n    /**\n     * Changes a component in the current context.\n     */\n    changeComponent: __ComponentActions__.changeComponent,\n    /**\n     * Retrieves components from the current context.\n     */\n    components: __ComponentActions__.components,\n    /**\n     * Merges components into the current context.\n     */\n    mergeComponents: __ComponentActions__.mergeComponents,\n    /**\n     * Removes a component from the current context.\n     */\n    removeComponent: __ComponentActions__.removeComponent,\n    /**\n     * Updates an existing component or inserts a new one if it doesn't exist in the current context.\n     */\n    upsertComponent: __ComponentActions__.upsertComponent\n};\nexport default actions;\n","export const BasicTypes = new Map([\n    // ['eid', Uint32Array],\n    // ['sid', Uint32Array],\n    // ['sym', String],\n    ['str', String],\n    ['num', Number],\n    ['bool', Boolean],\n    ['map', Map],\n    ['set', Set],\n    ['arr', Array],\n]);\nexport const ArrayTypes = new Map([\n    ['i8', Int8Array],\n    ['ui8', Uint8Array],\n    ['ui8c', Uint8ClampedArray],\n    ['i16', Int16Array],\n    ['ui16', Uint16Array],\n    ['i32', Int32Array],\n    ['ui32', Uint32Array],\n    ['f32', Float32Array],\n    ['f64', Float64Array],\n]);\n","import { SortedIndex } from './indexes/sorted.js';\nimport { SpatialIndex } from './indexes/spatial.js';\nimport { ComponentsIndex } from './indexes/components.js';\nimport { BasicTypes, ArrayTypes } from './types.js';\nimport { binarySearch } from './utils.js';\nimport { paginate } from './utils.js';\n// export {\n//   StorageInterface,\n//   StorageOptions,\n//   StorageProps,\n//   Components,\n//   Types,\n//   Inputs\n// }\n/**\n * The Indexes interface represents a mapping from keys to any array.\n */\nexport const IndexMap = {\n    sorted: SortedIndex,\n    spatial: SpatialIndex,\n};\nexport function createStorageProps(props = {}, storage = {}, options = {}) {\n    const { actors = [], entities = [], components = {}, inputs = {} } = storage || {};\n    const { types = {}, indexes = {},\n    // worldOptions,\n     } = options;\n    props.actors = actors || [];\n    props.entities = entities || [];\n    props.components = components || {};\n    props.inputs = inputs || {};\n    props.types = types;\n    props.typeCtors = {};\n    for (let key in types) {\n        let TypeCtor = types[key];\n        if (Array.isArray(TypeCtor)) {\n            TypeCtor = BasicTypes.get(TypeCtor[0]) || ArrayTypes.get(TypeCtor[0]);\n        }\n        else if (typeof TypeCtor === 'string') {\n            TypeCtor = BasicTypes.get(TypeCtor) || ArrayTypes.get(TypeCtor);\n        }\n        if (typeof TypeCtor === 'function') {\n            if (TypeCtor) {\n                props.typeCtors[key] = TypeCtor;\n            }\n        }\n    }\n    props.componentsIndex = new ComponentsIndex();\n    props.indexes = {};\n    for (let key in indexes) {\n        const { type } = indexes[key];\n        const IndexCtor = IndexMap[type];\n        if (IndexCtor) {\n            props.indexes[key] = {\n                actors: new IndexCtor([], indexes[key]),\n                entities: new IndexCtor([], indexes[key]),\n            };\n        }\n    }\n    return props;\n}\n/**\n * The Storage class represents a store with actors, entities, components, and inputs.\n *\n * @property {string[]} actors - The actors in the store.\n * @property {string[]} entities - The entities in the store.\n * @property {Components} components - The components in the store.\n * @property {Inputs} inputs - The inputs in the store.\n * @property {Types} types - The types in the store.\n * @property {any} typeCtors - The type constructors in the store\n * @property {ComponentsIndex} componentsIndex - The components index in the store.\n * @property {Indexes} indexes - The indexes in the store.\n */\nexport class Storage {\n    // declare world?: any\n    /**\n     * Constructs a new Storage object.\n     *\n     * @param {StorageProps} storage - The properties of the store.\n     */\n    constructor(storage = {}, options = {}) {\n        createStorageProps(this, storage, options);\n    }\n    /**\n     * Removes an actor ID.\n     *\n     * @param {string} id - The ID of the actor to remove.\n     * @returns {boolean} True if the actor ID was removed, false otherwise.\n     */\n    destroyActor(id) {\n        const actors = this.actors;\n        return this.destroyId(actors, id);\n    }\n    /**\n     * Removes a component.\n     *\n     * @param {string} id - The ID of the component to remove.\n     * @param {string} key - The key of the component to remove.\n     */\n    destroyComponent(id, key) {\n        const prevValue = this.components[id][key];\n        delete this.components[id][key];\n        this.removeComponentsIndex(id, key, prevValue);\n    }\n    /**\n     * Removes an entity ID.\n     *\n     * @param {string} id - The ID of the entity to remove.\n     * @returns {boolean} True if the entity ID was removed, false otherwise.\n     */\n    destroyEntity(id) {\n        const entities = this.entities;\n        return this.destroyId(entities, id);\n    }\n    /**\n     * Removes an ID from a list if it exists.\n     *\n     * @param {string[]} list - The list to remove the ID from.\n     * @param {string} id - The ID to remove.\n     * @returns {boolean} True if the ID was removed, false otherwise.\n     */\n    destroyId(list, id) {\n        const [index] = binarySearch(list, id);\n        if (index !== -1) {\n            list.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Fetches a components container for an entity.\n     *\n     * @param {string} id - The ID of the entity.\n     * @returns {Components} The fetched components container.\n     */\n    findComponents(id) {\n        this.components[id] = this.components[id] || {};\n        return this.components[id];\n    }\n    /**\n     * Fetches a component.\n     *\n     * @param {string} id - The ID of the component to fetch.\n     * @param {string} key - The key of the component to fetch.\n     * @returns {any} The fetched component.\n     */\n    findComponent(id, key) {\n        this.components[id] = this.components[id] || {};\n        return this.components[id][key];\n    }\n    /**\n     * Fetches an actors inputs\n     *\n     * @param {string} id - The ID of the actor.\n     * @returns {InputPayload} The fetched inputs.\n     */\n    findInputs(id) {\n        return this.inputs[id];\n    }\n    /**\n     * Fetches an actors input\n     *\n     * @param {string} id - The ID of the actor.\n     * @param {number} index - The index of the input.\n     * @returns {InputPayload} The fetched inputs.\n     */\n    findInput(id, index) {\n        this.inputs[id] = this.inputs[id] || [];\n        const input = this.inputs[id][index];\n        if (Array.isArray(input)) {\n            return [{ ...input[0], id }, input[1]];\n        }\n        return { ...input, id };\n    }\n    /**\n     * Gets the actors.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {string[][]} The actors.\n     */\n    getActors(query = null, pageSize = Infinity) {\n        if (query !== null) {\n            let results = {};\n            for (let key in query) {\n                const index = this.indexes[key];\n                if (index) {\n                    const result = index.actors.query(query[key]);\n                    result.forEach((id) => {\n                        results[id] = true;\n                    });\n                }\n            }\n            const ids = Object.keys(results);\n            return paginate(ids, pageSize);\n        }\n        return paginate(this.actors, pageSize);\n    }\n    /**\n     * Gets the components.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {Components} The components.\n     */\n    getComponents(query = null, pageSize = Infinity) {\n        let object = this.components;\n        if (query !== null) {\n            const results = {};\n            for (let key of query) {\n                results[key] = this.components[key];\n            }\n            object = results;\n        }\n        const ids = Object.keys(object);\n        const pages = paginate(ids, pageSize);\n        return pages.map((page) => {\n            const components = {};\n            for (let id of page) {\n                components[id] = object[id];\n            }\n            return components;\n        });\n    }\n    /**\n     * Gets the entities.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {string[]} The entities.\n     */\n    getEntities(query = null, pageSize = Infinity) {\n        if (query !== null) {\n            let results = {};\n            for (let key in query) {\n                const index = this.indexes[key];\n                if (index) {\n                    const result = index.entities.query(query[key]);\n                    result.forEach((id) => {\n                        results[id] = true;\n                    });\n                }\n            }\n            const ids = Object.keys(results);\n            return paginate(ids, pageSize);\n        }\n        return paginate(this.entities, pageSize);\n    }\n    /**\n     * Gets the inputs.\n     *\n     * @returns {Inputs} The inputs.\n     */\n    getInputs(query = null, pageSize = Infinity) {\n        let object = this.inputs;\n        if (query !== null) {\n            const results = {};\n            for (let key of query) {\n                results[key] = this.inputs[key];\n            }\n            object = results;\n        }\n        const ids = Object.keys(object);\n        const pages = paginate(ids, pageSize);\n        return pages.map((page) => {\n            const inputs = {};\n            for (let id of page) {\n                inputs[id] = object[id];\n            }\n            return inputs;\n        });\n    }\n    /**\n     * Checks if an ID is an actor.\n     *\n     * @param {string} id - The ID to check.\n     * @returns {boolean} True if the ID is an actor, false otherwise.\n     */\n    isActor(id) {\n        const actors = this.actors;\n        return actors.indexOf(id) !== -1;\n    }\n    /**\n     * Checks if an ID is an entity.\n     *\n     * @param {string} id - The ID to check.\n     * @returns {boolean} True if the ID is an entity, false otherwise.\n     */\n    isEntity(id) {\n        const entities = this.entities;\n        return entities.indexOf(id) !== -1;\n    }\n    /**\n     * Sets the actors.\n     *\n     * @param {string[]} actors - The actors to set.\n     * @returns {string[]} The actors.\n     */\n    setActors(actors) {\n        this.actors = actors;\n        return actors;\n    }\n    /**\n     * Sets the components.\n     *\n     * @param {Components} components - The components to set.\n     * @returns {Components} The components.\n     */\n    setComponents(components) {\n        this.components = components;\n        return components;\n    }\n    /**\n     * Sets the entities.\n     *\n     * @param {string[]} entities - The entities to set.\n     * @returns {string[]} The entities.\n     */\n    setEntities(entities) {\n        this.entities = entities;\n        return entities;\n    }\n    /**\n     * Sets the inputs.\n     *\n     * @param {Inputs} inputs - The inputs to set.\n     * @returns {Inputs} The inputs.\n     */\n    setInputs(inputs) {\n        this.inputs = inputs;\n        return inputs;\n    }\n    /**\n     * Stores an actor ID.\n     *\n     * @param {string} id - The ID of the actor to store.\n     * @returns {boolean} True if the actor ID was stored, false otherwise.\n     */\n    storeActor(id) {\n        const actors = this.actors;\n        return this.storeId(actors, id);\n    }\n    /**\n     * Stores a component.\n     *\n     * @param {string} id - The ID of the component to store.\n     * @param {string} key - The key of the component to store.\n     * @param {any} value - The value of the component to store.\n     */\n    storeComponent(id, key, value) {\n        const prevValue = this.components[id][key];\n        this.components[id][key] = value;\n        this.updateComponentsIndex(id, key, prevValue, value);\n    }\n    /**\n     * Stores an entity ID.\n     *\n     * @param {string} id - The ID of the entity to store.\n     * @returns {boolean} True if the entity ID was stored, false otherwise.\n     */\n    storeEntity(id) {\n        const entities = this.entities;\n        return this.storeId(entities, id);\n    }\n    /**\n     * Stores an ID in a list if it doesn't exist already.\n     *\n     * @param {string[]} list - The list to store the ID in.\n     * @param {string} id - The ID to store.\n     * @returns {boolean} True if the ID was stored, false otherwise.\n     */\n    storeId(list, id) {\n        const [index, left] = binarySearch(list, id);\n        if (index === -1) {\n            list.splice(left, 0, id);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Stores an input.\n     *\n     * @param {string} id - The ID of the input to store.\n     * @param {InputPayload} input - The payload of the input to store.\n     * @returns {number} The new index of the stored input.\n     */\n    storeInput(id, input, tick = 0) {\n        const inputs = this.inputs;\n        inputs[id] = inputs[id] || [];\n        const index = inputs[id].length;\n        if (input.id === id) {\n            delete input.id;\n        }\n        inputs[id].push(tick ? [input, tick] : input);\n        return index;\n    }\n    /**\n     * Queries the store for entities by component.\n     *\n     * @param {any} query - The query to use.\n     * @returns {Set<any>} The entities.\n     */\n    queryComponents(query) {\n        return this.componentsIndex.query(query);\n    }\n    /**\n     * Removes a component from the components index.\n     *\n     * @param {string} id - The ID of the component to remove.\n     * @param {string} key - The key of the component to remove.\n     * @param {any} prevValue - The previous value of the component.\n     * @returns {void}\n     */\n    removeComponentsIndex(id, key, prevValue) {\n        this.componentsIndex.remove(id, key);\n        if (this.indexes[key]) {\n            const index = this.indexes[key];\n            if (this.isActor(id)) {\n                index.actors.remove(id, prevValue);\n            }\n            else {\n                index.entities.remove(id, prevValue);\n            }\n        }\n    }\n    /**\n     * Updates a component in the components index.\n     *\n     * @param {string} id - The ID of the component to update.\n     * @param {string} key - The key of the component to update.\n     * @param {any} prevValue - The previous value of the component.\n     * @param {any} value - The new value of the component.\n     * @returns {void}\n     */\n    updateComponentsIndex(id, key, prevValue, value) {\n        this.componentsIndex.set(id, key);\n        if (this.indexes[key]) {\n            const index = this.indexes[key];\n            if (this.isActor(id)) {\n                index.actors.store(id, prevValue, value);\n            }\n            else {\n                index.entities.store(id, prevValue, value);\n            }\n        }\n    }\n}\nexport default Storage;\n","import { Options } from './options.js';\nimport { ensureSymbolIndex, recursiveSymbolIndexesEnsured } from './symbols.js';\nimport { ArrayTypes } from './types.js';\nimport { now, concatTypedArray } from './utils.js';\n/**\n * The updater function updates the context based on the provided options.\n *\n * @param {Context} context - The current context.\n * @param {Options | any} options - The options for updating the context.\n * @param {number} tick - The current tick.\n * @returns {Promise<any[]>} A promise that resolves to an array of arrays, where each sub-array represents a batch of updates. This is only relevant if the `batched` option is enabled.\n */\nexport async function updater(context, options, tick = now()) {\n    options = options instanceof Options ? options : new Options(options);\n    const { responder, enumDefaultSymbols, compressStringsAsInts, enableRollback, isOrdered, isDiffed, isGroupedComponents, isAsyncStorage, types, setGroupedValue, updateOptions } = options;\n    const { batched, batchSize, mask, type, validKeys } = updateOptions;\n    if (!context.pending) {\n        return [];\n    }\n    /**\n     * An array of arrays, where each sub-array represents a batch of updates.\n    */\n    const batch = [];\n    /**\n     * An array representing the current batch of updates.\n    */\n    let batchBlock = [];\n    const { created = {}, removed = {}, symbols = [], updated = {} } = context.pending;\n    const store = context.store;\n    /**\n     * Merges the current batch block into the batch array.\n     *\n     * @param {string | number} action - The action associated with the current batch block.\n     */\n    const mergeBatch = (action) => {\n        if (batched && batchBlock.length) {\n            batch.push([action, ...batchBlock]);\n            batchBlock = [];\n        }\n    };\n    /**\n     * Queues a message for later processing.\n     *\n     * @param {string | number} action - The action associated with the message.\n     * @param {any} payload - The payload of the message.\n     */\n    const queueMessage = async (action, payload) => {\n        if (batched) {\n            // batchBlock.push(payload)\n            batchBlock = batchBlock.concat(payload);\n            if (batchBlock.length >= batchSize) {\n                mergeBatch(action);\n            }\n        }\n        else {\n            if (compressStringsAsInts) {\n                action = ensureSymbolIndex(action, context, options);\n            }\n            await responder([action, payload], type);\n        }\n    };\n    /**\n     * Ensures that a symbol is indexed if the `compressStringsAsInts` option is enabled.\n     *\n     * @param {string | number} symbol - The symbol to be indexed.\n     * @returns {string | number} The indexed symbol, or the original symbol if `compressStringsAsInts` is not enabled.\n     */\n    const ensureSymbol = (symbol) => {\n        if (compressStringsAsInts) {\n            symbol = ensureSymbolIndex(symbol, context, options);\n        }\n        return symbol;\n    };\n    const upsertComponents = async (pendingComponents = {}, state) => {\n        const groups = isGroupedComponents ? {} : null;\n        for (const id in (pendingComponents ?? {})) {\n            const components = isAsyncStorage ? await store.findComponents(id) : store.findComponents(id);\n            if (components === null || components === undefined) {\n                break;\n            }\n            const updatedComponents = pendingComponents ? pendingComponents[id] : {};\n            for (const key in (updatedComponents ?? {})) {\n                if (validKeys && !validKeys[key]) {\n                    break;\n                }\n                const type = types[key] ?? null;\n                const Type = type ? ArrayTypes.get(Array.isArray(type) ? type[0] : type) : null;\n                let group = null;\n                if (groups) {\n                    group = groups[key] = groups[key] ?? {\n                        key,\n                        ids: compressStringsAsInts ? new Uint32Array(0) : [],\n                        intIds: true,\n                        values: Type ? new Type(0) : [],\n                        ticks: new Uint32Array(0),\n                    };\n                }\n                let value = isAsyncStorage ? await store.findComponent(id, key) : store.findComponent(id, key);\n                // TODO: Fix !true\n                if (isDiffed && context.changes && (state === 'updated' || !true)) {\n                    value = context.changes.getValue(id, key, value);\n                }\n                if (compressStringsAsInts) {\n                    value = recursiveSymbolIndexesEnsured(key, value, context, options);\n                }\n                const nid = ensureSymbol(id);\n                const nkey = ensureSymbol(key);\n                if (groups) {\n                    group.ids = compressStringsAsInts\n                        ? concatTypedArray(group.ids, [nid])\n                        : group.ids.concat([id]);\n                    if (nid === id) {\n                        group.intIds = false;\n                    }\n                    group.values = Type\n                        ? concatTypedArray(group.values, setGroupedValue(value, types, key))\n                        : group.values.concat(setGroupedValue(value, types, key));\n                    if (isOrdered) {\n                        group.ticks = concatTypedArray(group.ticks, [isDiffed ? -tick : tick]);\n                    }\n                    continue;\n                }\n                const payload = [nid, nkey, value];\n                if (isOrdered) {\n                    payload.push(isDiffed ? -tick : tick);\n                }\n                if (isDiffed) {\n                    await queueMessage(enumDefaultSymbols.changeComponent, payload);\n                }\n                else {\n                    await queueMessage(enumDefaultSymbols.upsertComponent, payload);\n                }\n            }\n            // delete pendingComponents[id];\n        }\n        if (groups) {\n            for (const key in groups) {\n                const group = groups[key];\n                const bufferIds = compressStringsAsInts && group.intIds ? new Uint32Array(group.ids) : group.ids;\n                const type = types[key] ?? null;\n                const Type = type ? ArrayTypes.get(Array.isArray(type) ? type[0] : type) : null;\n                const bufferValues = Type ? new Type(group.values) : group.values;\n                let i = 0;\n                const size = bufferIds.length;\n                for (; i < size; i += batchSize) {\n                    const payload = [\n                        bufferIds.slice(i, i + batchSize),\n                        group.key,\n                        bufferValues.slice(i, i + batchSize)\n                    ];\n                    if (isOrdered) {\n                        const bufferTicks = new Uint32Array(group.ticks.slice(i, i + batchSize));\n                        payload.push(bufferTicks);\n                    }\n                    if (isDiffed) {\n                        await queueMessage(enumDefaultSymbols.changeComponent, payload);\n                    }\n                    else {\n                        await queueMessage(enumDefaultSymbols.upsertComponent, payload);\n                    }\n                }\n            }\n        }\n        mergeBatch(isDiffed ? enumDefaultSymbols.changeComponent : enumDefaultSymbols.upsertComponent);\n    };\n    /**\n     * If the `mask` object does not exist or does not have an `entities` property,\n     * this code block ensures that each entity in the `created.entities` array is indexed,\n     * queues a message to create each entity, merges the batch of messages, and then clears the `created.entities` array.\n     */\n    if (!mask || !mask.entities) {\n        for (const key of created.entities ?? []) {\n            const nkey = ensureSymbol(key);\n            await queueMessage(enumDefaultSymbols.createEntity, nkey);\n        }\n        mergeBatch(enumDefaultSymbols.createEntity);\n        created.entities = [];\n    }\n    /**\n     * If the `mask` object does not exist or does not have an `actors` property,\n     * this code block ensures that each actor in the `created.actors` array is indexed,\n     * queues a message to spawn each actor, merges the batch of messages, and then clears the `created.actors` array.\n     */\n    if (!mask || !mask.actors) {\n        for (const id in (created.actors ?? {})) {\n            const nid = ensureSymbol(id);\n            await queueMessage(enumDefaultSymbols.spawnActor, nid);\n        }\n        mergeBatch(enumDefaultSymbols.spawnActor);\n        created.actors = {};\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `removed.components` object is indexed,\n     * queues a message to remove each component, merges the batch of messages, and then clears the `removed.components` object.\n     */\n    if (!mask || !mask.entities) {\n        for (const key of removed.entities ?? []) {\n            const nkey = ensureSymbol(key);\n            await queueMessage(enumDefaultSymbols.removeEntity, nkey);\n        }\n        mergeBatch(enumDefaultSymbols.removeEntity);\n        removed.entities = [];\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `removed.components` object is indexed,\n     * queues a message to remove each component, merges the batch of messages, and then clears the `removed.components` object.\n     */\n    if (!mask || !mask.actors) {\n        for (const id in (removed.actors ?? {})) {\n            const nid = ensureSymbol(id);\n            await queueMessage(enumDefaultSymbols.removeActor, nid);\n        }\n        mergeBatch(enumDefaultSymbols.removeActor);\n        removed.actors = {};\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `removed.components` object is indexed,\n     * queues a message to remove each component, merges the batch of messages, and then clears the `removed.components` object.\n     */\n    if (!mask || !mask.components) {\n        for (const id in (removed.components ?? {})) {\n            const components = removed?.components ? removed.components[id] : null;\n            if (!components) {\n                break;\n            }\n            const nid = ensureSymbol(id);\n            for (const key in components) {\n                if (validKeys && !validKeys[key]) {\n                    break;\n                }\n                const nkey = ensureSymbol(key);\n                const payload = [nid, nkey];\n                await queueMessage(enumDefaultSymbols.removeComponent, payload);\n            }\n            // delete removed.components[key]\n        }\n        mergeBatch(enumDefaultSymbols.removeComponent);\n        removed.components = {};\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `created.components` object is indexed,\n     * queues a message to create each component, merges the batch of messages, and then clears the `created.components` object.\n     */\n    if (!mask || !mask.components) {\n        const promise = upsertComponents(created.components, 'created');\n        created.components = {};\n        await promise;\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `updated.components` object is indexed,\n     * queues a message to update each component, merges the batch of messages, and then clears the `updated.components` object.\n     */\n    if (!mask || !mask.components) {\n        const promise = upsertComponents(updated.components, 'updated');\n        updated.components = {};\n        await promise;\n    }\n    /**\n     * If the `mask` object does not exist or does not have an `inputs` property,\n     * this code block ensures that each input in the `created.inputs` object is indexed,\n     * queues a message to create each input, merges the batch of messages, and then clears the `created.inputs` object.\n     */\n    if (!mask || !mask.inputs) {\n        for (const id in (created.inputs ?? {})) {\n            // const nid = ensureSymbol(id)\n            const createdInputs = created?.inputs ? (created.inputs[id] ?? []) : [];\n            for (let i = 0; i < createdInputs.length; i += 1) {\n                const index = createdInputs[i];\n                const payload = isAsyncStorage ? await store.findInput(id, index) : store.findInput(id, index);\n                const isTuple = Array.isArray(payload);\n                const input = isTuple ? payload[0] : payload;\n                const tick_ = isTuple ? payload[1] : tick;\n                await queueMessage(enumDefaultSymbols.actorInput, isTuple || enableRollback ? [input, tick_] : input);\n            }\n            // delete created.inputs[id];\n        }\n        mergeBatch(enumDefaultSymbols.actorInput);\n        created.inputs = {};\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `symbols` property,\n     * this code block ensures that each symbol in the `symbols` array is indexed,\n     * queues a message to add each symbol, merges the batch of messages, and then clears the `symbols` array.\n     */\n    if (!mask || !mask.symbols) {\n        for (const symbolOp of symbols) {\n            if (batched) {\n                batchBlock.push(symbolOp);\n            }\n            else {\n                const message = [enumDefaultSymbols.mergeSymbol, symbolOp];\n                await responder(message, type);\n            }\n            if (batchBlock.length >= batchSize && batchBlock.length) {\n                batch.unshift([enumDefaultSymbols.mergeSymbol].concat(batchBlock));\n                batchBlock = [];\n            }\n        }\n        if (batched && batchBlock.length) {\n            batch.unshift([enumDefaultSymbols.mergeSymbol].concat(batchBlock));\n            batchBlock = [];\n        }\n        context.pending.symbols = [];\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `symbols` property,\n     * this code block ensures that each symbol in the `symbols` array is indexed,\n     * queues a message to add each symbol, merges the batch of messages, and then clears the `symbols` array.\n     */\n    if (batched && batch.length) {\n        for (let i = 0; i < batch.length; i += 1) {\n            const batchSlice = batch[i];\n            if (batchSlice) {\n                await responder([enumDefaultSymbols.batch, batchSlice]);\n                // if (batchSlice.length > 1) {\n                //   responder([enumDefaultSymbols.batch].concat(batchSlice))\n                // } else {\n                //   responder(batchSlice)\n                // }\n            }\n        }\n    }\n    return batch;\n}\nexport default updater;\n","import { Context } from './context.js';\nimport { Options } from './options.js';\nimport { Storage } from './storage.js';\nimport { updater } from './updater.js';\nimport { now } from './utils.js';\n/**\n * Gets the symbol action.\n *\n * @param {string | number} action - The action.\n * @param {Record<number, string> | null} defaultSymbols - The default symbols.\n * @returns {number | string} The symbol action.\n */\nexport function getSymbolAction(action, defaultSymbols) {\n    if (defaultSymbols && typeof action === 'number' && defaultSymbols[action]) {\n        action = defaultSymbols[action];\n    }\n    return action;\n}\n/**\n * Gets the action handler.\n *\n * @param {Context} context - The context.\n * @param {OptionsExtended | any} options - The options.\n */\nexport function getActionHandler(context, options) {\n    options = options instanceof Options ? options : new Options(options);\n    const { actions, defaultSymbols } = options;\n    return (action) => {\n        action = getSymbolAction(action, defaultSymbols);\n        const handler = (payload) => {\n            if (actions[action]) {\n                actions[action](payload, context, options);\n            }\n        };\n        // Assign the action to the handler function.\n        handler.action = action;\n        return handler;\n    };\n}\n/**\n * Handles a single message.\n *\n * @param {Message | any[]} message - The message to handle.\n * @param {Context} context - The context for the handler.\n * @param {OptionsExtended | any} options - The options for the handler.\n*/\nexport function oneHandler(message, context, options) {\n    options = options instanceof Options ? options : new Options(options);\n    const actionHandler = getActionHandler(context, options);\n    if (Array.isArray(message)) {\n        actionHandler(message[0])(message[1]);\n    }\n    else if (message) {\n        actionHandler(message.action)(message.payload);\n    }\n}\nexport const handler = manyHandler;\n/**\n * Handles multiple messages.\n *\n * @param {Message | any[]} message - The messages to handle.\n * @param {Context} context - The context for the handler.\n * @param {OptionsExtended | any} options - The options for the handler.\n */\nexport function manyHandler(message, context, options) {\n    options = options instanceof Options ? options : new Options(options);\n    const { batchActionPayloadSizes, isOrdered, enableRollback } = options;\n    const actionHandler = getActionHandler(context, options);\n    const iterator = (payload, handler, offset = 0) => {\n        // Use the action from the handler Function\n        const action = handler.action;\n        let payloadSize = batchActionPayloadSizes[action] || 1;\n        if (payloadSize && typeof payloadSize === 'object') {\n            if (payloadSize.ordered && isOrdered) {\n                payloadSize = payloadSize.ordered;\n            }\n            else if (payloadSize.rollback && enableRollback) {\n                payloadSize = payloadSize.rollback;\n            }\n            else {\n                payloadSize = payloadSize.default;\n            }\n        }\n        for (let i = offset; i < payload.length; i += payloadSize) {\n            // Call the handler function with the payload\n            if (payloadSize === 1) {\n                handler(payload[i], context, options);\n            }\n            else if (batchActionPayloadSizes) {\n                handler(payload.slice(i, i + payloadSize), context, options);\n            }\n            else {\n                // console.warn('BATCH MISMATCH')\n            }\n        }\n    };\n    if (Array.isArray(message)) {\n        const handler = actionHandler(message[0]);\n        iterator(message, handler, 1);\n    }\n    else if (message) {\n        const handler = actionHandler(message.action);\n        iterator(message.payload, handler);\n    }\n}\n/**\n * The Handler class. It handles messages.\n */\nexport class Handler {\n    context;\n    options;\n    /**\n     * Creates a new Handler instance.\n     *\n     * @param {Context | any} context - The context for the handler.\n     * @param {Options | any} options - The options for the handler.\n     * @param {Object} actions - The actions for the handler.\n     * @param {Storage} _Storage - The storage for the handler.\n     */\n    constructor(context, options, actions, _Storage = Storage) {\n        this.options = Options.ensure(options, actions);\n        this.context = Context.ensure(context, options, _Storage);\n    }\n    /**\n     * Handles a single message.\n     *\n     * @param {Message | any[]} message - The message to handle.\n     */\n    one(message, extendOptions) {\n        return oneHandler(message, this.context, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Handles multiple messages.\n     *\n     * @param {Message | any[]} message - The messages to handle.\n     */\n    many(message, extendOptions) {\n        return manyHandler(message, this.context, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Gets the action handler.\n     */\n    getActionHandler() {\n        return getActionHandler(this.context, this.options);\n    }\n    /**\n     * Gets the symbol action.\n     *\n     * @param {string | number} action - The action.\n     */\n    getSymbolAction(action) {\n        return getSymbolAction(action, this.options.defaultSymbols);\n    }\n    /**\n     * Updates other nodes in the network.\n     *\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     * @param {number} tick - The tick for updating.\n     * @returns {Promise<any[]>} A promise that resolves with updated batch of messages.\n     */\n    updater(extendOptions, tick = now()) {\n        return updater(this.context, extendOptions ? this.options.extend(extendOptions) : this.options, tick);\n    }\n    /**\n     * Spawns an actor.\n     *\n     * @param {string} id - The ID of the actor to spawn.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    spawnActor(id, extendOptions) {\n        return this.context.spawnActor(id, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Despawns an actor.\n     *\n     * @param {string} id - The ID of the actor to despawn.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    removeActor(id, extendOptions) {\n        return this.context.removeActor(id, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Updates an actor with an input.\n     *\n     * @param {string} id - The ID of the actor to update.\n     * @param {any} input - The input for updating.\n     * @param {number} tick - The tick for updating.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    actorInput(id, input, tick = now(), extendOptions) {\n        return this.context.actorInput(id, input, tick, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Creates an entity.\n     *\n     * @param {string} id - The ID of the entity to create.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    createEntity(id, extendOptions) {\n        return this.context.createEntity(id, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Removes an entity.\n     *\n     * @param {string} id - The ID of the entity to remove.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    removeEntity(id, extendOptions) {\n        return this.context.removeEntity(id, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Sets a component to an entity.\n     *\n     * @param {string} id - The ID of the entity to add the component to.\n     * @param {string} key - The key of the component to add.\n     * @param {any} value - The value of the component to add.\n     * @param {number} tick - The tick for updating.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    upsertComponent(id, key, value, tick = now(), extendOptions) {\n        return this.context.upsertComponent(id, key, value, tick, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Changes a component of an entity.\n     *\n     * @param {string} id - The ID of the entity to change the component of.\n     * @param {string} key - The key of the component to change.\n     * @param {any} value - The value of the component to change.\n     * @param {number} tick - The tick for updating.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    changeComponent(id, key, value, tick = now(), extendOptions) {\n        return this.context.changeComponent(id, key, value, tick, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Removes a component from an entity.\n     *\n     * @param {string} id - The ID of the entity to remove the component from.\n     * @param {string} key - The key of the component to remove.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    removeComponent(id, key, extendOptions) {\n        return this.context.removeComponent(id, key, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Queries components.\n     *\n     * @param {any} query - The query for querying components.\n     * @returns {Set<any>} The components queried.\n     */\n    queryComponents(query) {\n        return this.context.store.queryComponents(query);\n    }\n}\nexport default Handler;\n","import { manyHandler } from '../handler.js';\nimport { Options } from '../options.js';\n/**\n * Creates a new instance of the CoreActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the CoreActions class.\n * @returns {any} - A new class that extends the provided Parent class and the CoreActions class.\n */\nexport const CoreActionsFactory = (Parent = Object) => class CoreActions extends Parent {\n    /**\n     * Processes a batch of payloads in the current context.\n     *\n     * @param {any[]} payload - The array of payloads to be processed.\n     * @param {Context} context - The current context in which the payloads are to be processed.\n     * @param {Options | any} options - The options for processing the payloads. If an instance of Options is not provided, a new one will be created.\n     */\n    batch(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        manyHandler(payload, context, options);\n    }\n};\n/**\n * The CoreActions class provides the core functionality for managing actions in your application.\n */\nexport class CoreActions extends CoreActionsFactory() {\n}\nconst __CoreActions__ = new CoreActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the CoreActions class.\n */\nexport const actions = {\n    /**\n     * Processes a batch of payloads in the current context.\n     */\n    batch: __CoreActions__.batch\n};\nexport default actions;\n","import { Options } from '../options.js';\nimport { extractSymbol } from '../symbols.js';\n/**\n * Creates a new instance of the EntityActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the EntityActions class.\n * @returns {any} - A new class that extends the provided Parent class and the EntityActions class.\n */\nexport const EntityActionsFactory = (Parent = Object) => class EntityActions extends Parent {\n    /**\n     * Creates a new entity in the current context.\n     *\n     * @param {any} id - The identifier for the entity to be created.\n     * @param {Context} context - The current context in which the entity is to be created.\n     * @param {Options | any} options - The options for creating the entity. If an instance of Options is not provided, a new one will be created.\n     */\n    createEntity(id, context, options) {\n        options = options = Options.ensure(options, this);\n        const { skipPending, compressStringsAsInts } = options;\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        context.createEntity(id, skipPending);\n    }\n    /**\n     * Retrieves entities from the current context.\n     *\n     * @param {any} payload - This parameter is not used in the method.\n     * @param {Context} context - The current context from which the entities are retrieved.\n     * @param {OptionsExtended | any} options - The options for retrieving entities. If an instance of Options is not provided, a new one will be created.\n     */\n    entities(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, isAuthority, isAsyncStorage, pageSize, enableQuerying, enumDefaultSymbols } = options;\n        if (!isAuthority) {\n            return;\n        }\n        const sendEntities = (pages) => {\n            for (const page of pages) {\n                responder([enumDefaultSymbols.mergeEntities, page]);\n            }\n        };\n        const ctxEntities = context.getEntities(enableQuerying ? payload : null, pageSize);\n        if (isAsyncStorage) {\n            ctxEntities.emitTo(sendEntities, true);\n        }\n        else {\n            sendEntities(ctxEntities);\n        }\n    }\n    /**\n     * Merges entities into the current context.\n     *\n     * @param {any[]} payload - The payload containing the entities to be merged.\n     * @param {Context} context - The current context in which the entities are to be merged.\n     * @param {OptionsExtended | any} options - The options for merging. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeEntities(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        context.mergeEntities(payload, options);\n    }\n    /**\n     * Removes an entity from the current context.\n     *\n     * @param {any} id - The identifier for the entity to be removed.\n     * @param {Context} context - The current context from which the entity is to be removed.\n     * @param {OptionsExtended | any} options - The options for removing the entity. If an instance of Options is not provided, a new one will be created.\n     */\n    removeEntity(id, context, options) {\n        options = options = Options.ensure(options, this);\n        const { skipPending, compressStringsAsInts } = options;\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        context.removeEntity(id, skipPending);\n    }\n};\n/**\n * Class representing actions that can be performed on entities.\n * This class encapsulates the logic for creating, merging, and removing entities.\n */\nexport class EntityActions extends EntityActionsFactory() {\n}\nconst __EntityActions__ = new EntityActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the EntityActions class.\n */\nexport const actions = {\n    /**\n     * Creates a new entity in the current context.\n     */\n    createEntity: __EntityActions__.createEntity,\n    /**\n     * Retrieves entities from the current context.\n     */\n    entities: __EntityActions__.entities,\n    /**\n     * Merges entities into the current context.\n     */\n    mergeEntities: __EntityActions__.mergeEntities,\n    /**\n     * Removes an entity from the current context.\n     */\n    removeEntity: __EntityActions__.removeEntity\n};\nexport default actions;\n","import { Options } from '../options.js';\nimport { paginate } from '../utils.js';\n/**\n * Creates a new instance of the SymbolActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the SymbolActions class.\n * @returns {any} - A new class that extends the provided Parent class and the SymbolActions class.\n */\nexport const SymbolActionsFactory = (Parent = Object) => class SymbolActions extends Parent {\n    /**\n     * Adds a symbol to the current context.\n     *\n     * @param {any} symbol - The symbol to be added.\n     * @param {Context} context - The current context to which the symbol is to be added.\n     * @param {Options | any} options - The options for adding the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    addSymbol(symbol, context, options) {\n        options = options = Options.ensure(options, this);\n        return context.addSymbol(symbol, options);\n    }\n    /**\n     * Fetches a symbol for the current context.\n     *\n     * @param {string | number} payload - The payload containing the symbol to be fetched.\n     * @param {Context} context - The current context from which the symbol is to be fetched.\n     * @param {Options | any} options - The options for fetching the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    fetchSymbol(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, enumDefaultSymbols } = options;\n        return context.fetchSymbol(payload, options, (symbolTuple) => {\n            responder([enumDefaultSymbols.mergeSymbol, symbolTuple]);\n        });\n    }\n    /**\n     * Retrieves a symbol from the current context by its index.\n     *\n     * @param {number} index - The index of the symbol to be retrieved.\n     * @param {Context} context - The current context from which the symbol is to be retrieved.\n     * @param {Options | any} options - The options for retrieving the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    getSymbol(index, context, options) {\n        options = options = Options.ensure(options, this);\n        return context.getSymbol(index, options);\n    }\n    /**\n     * Merges a symbol into the current context.\n     *\n     * @param {[string, number]} payload - The payload containing the symbol to be merged.\n     * @param {Context} context - The current context into which the symbol is to be merged.\n     * @param {Options | any} options - The options for merging the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeSymbol(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        context.mergeSymbol(payload, options);\n    }\n    /**\n     * Merges multiple symbols into the current context.\n     *\n     * @param {any[]} payload - The payload containing the symbols to be merged.\n     * @param {Context} context - The current context into which the symbols are to be merged.\n     * @param {Options | any} options - The options for merging the symbols. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeSymbols(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const [offset, symbols] = payload;\n        if (payload && payload.length) {\n            context.resetSymbols(offset, symbols, options);\n        }\n    }\n    /**\n     * Retrieves a symbol from the current context.\n     *\n     * @param {any} symbol - The symbol to be retrieved.\n     * @param {Context} context - The current context from which the symbol is to be retrieved.\n     * @param {Options | any} options - The options for retrieving the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    symbol(symbol, context, options) {\n        options = options = Options.ensure(options, this);\n        const { actions, responder, isAuthority, enumDefaultSymbols, compressStringsAsInts } = options;\n        if (!isAuthority || !compressStringsAsInts) {\n            return;\n        }\n        const enumSymbols = context.symbolsEnum ?? {};\n        let index = Object.prototype.hasOwnProperty.call(enumSymbols, symbol) ? enumSymbols[symbol] : -1;\n        if (index === -1) {\n            index = actions.addSymbol(symbol, context, options);\n        }\n        if (index !== -1) {\n            responder([enumDefaultSymbols.mergeSymbol, [symbol, index]]);\n        }\n    }\n    /**\n     * Retrieves all symbols from the current context.\n     *\n     * @param {any} _ - This parameter is not used.\n     * @param {Context} context - The current context from which the symbols are to be retrieved.\n     * @param {Options | any} options - The options for retrieving the symbols. If an instance of Options is not provided, a new one will be created.\n     */\n    symbols(_, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, isAuthority, pageSize, enumDefaultSymbols, compressStringsAsInts } = options;\n        if (!isAuthority || !compressStringsAsInts) {\n            return;\n        }\n        const symbols = context.symbolsList;\n        if (symbols && symbols.length) {\n            // responder([enumDefaultSymbols.mergeSymbols, 0, symbols])\n            const pages = paginate(symbols, pageSize);\n            let i = 0;\n            // send pages to responder\n            for (const page of pages) {\n                responder([enumDefaultSymbols.mergeSymbols, i, page]);\n                i += pageSize;\n            }\n        }\n    }\n};\n/**\n * The SymbolActions class provides methods for managing symbols in a context.\n */\nexport class SymbolActions extends SymbolActionsFactory() {\n}\nconst __SymbolActions__ = new SymbolActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the SymbolActions class.\n */\nexport const actions = {\n    /**\n     * Adds a symbol to the current context.\n     */\n    addSymbol: __SymbolActions__.addSymbol,\n    /**\n     * Fetches a symbol from the current context.\n     */\n    fetchSymbol: __SymbolActions__.fetchSymbol,\n    /**\n     * Retrieves a symbol from the current context by its index.\n     */\n    getSymbol: __SymbolActions__.getSymbol,\n    /**\n     * Merges a symbol into the current context.\n     */\n    mergeSymbol: __SymbolActions__.mergeSymbol,\n    /**\n     * Merges multiple symbols into the current context.\n     */\n    mergeSymbols: __SymbolActions__.mergeSymbols,\n    /**\n     * Retrieves a symbol from the current context.\n     */\n    symbol: __SymbolActions__.symbol,\n    /**\n     * Retrieves all symbols from the current context.\n     */\n    symbols: __SymbolActions__.symbols\n};\nexport default actions;\n","import actorActions, { ActorActionsFactory } from './actions/actor.js';\nimport componentActions, { ComponentActionsFactory } from './actions/component.js';\nimport coreActions, { CoreActionsFactory } from './actions/core.js';\nimport entityActions, { EntityActionsFactory } from './actions/entity.js';\nimport symbolActions, { SymbolActionsFactory } from './actions/symbol.js';\n/**\n * A factory function that creates a new instance of the AllActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the AllActions class.\n * @returns {any} A new class that extends the provided Parent class and the CoreActions class.\n */\nexport function AllActionsFactory(Parent = Object) {\n    return ActorActionsFactory(ComponentActionsFactory(CoreActionsFactory(EntityActionsFactory(SymbolActionsFactory(Parent)))));\n}\n/**\n * Combines all the actions from different modules into a single object.\n */\nexport const allActions = {\n    ...actorActions,\n    ...componentActions,\n    ...coreActions,\n    ...entityActions,\n    ...symbolActions\n};\n/**\n * The NodeActions class provides methods for managing nodes in a context.\n */\nexport class NodeActions extends AllActionsFactory() {\n}\nconst __NodeActions__ = new NodeActions();\n/**\n * The actions object combines all the actions from different modules.\n */\nexport const actions = {\n    /**\n     * Handles input for a specific actor in the current context.\n     */\n    actorInput: __NodeActions__.actorInput,\n    /**\n     * Retrieves actors from the current context.\n     */\n    actors: __NodeActions__.actors,\n    /**\n     * Merges actors into the current context.\n     */\n    mergeActors: __NodeActions__.mergeActors,\n    /**\n     * Removes an actor from the current context.\n     */\n    removeActor: __NodeActions__.removeActor,\n    /**\n     * Spawns a new actor in the current context.\n     */\n    spawnActor: __NodeActions__.spawnActor,\n    /**\n     * Changes a component in the current context.\n     */\n    changeComponent: __NodeActions__.changeComponent,\n    /**\n     * Retrieves components from the current context.\n     */\n    components: __NodeActions__.components,\n    /**\n     * Merges components into the current context.\n     */\n    mergeComponents: __NodeActions__.mergeComponents,\n    /**\n     * Removes a component from the current context.\n     */\n    removeComponent: __NodeActions__.removeComponent,\n    /**\n     * Updates an existing component or inserts a new one if it doesn't exist in the current context.\n     */\n    upsertComponent: __NodeActions__.upsertComponent,\n    /**\n     * Processes a batch of payloads in the current context.\n     */\n    batch: __NodeActions__.batch,\n    /**\n     * Creates a new entity in the current context.\n     */\n    createEntity: __NodeActions__.createEntity,\n    /**\n     * Retrieves entities from the current context.\n     */\n    entities: __NodeActions__.entities,\n    /**\n     * Merges entities into the current context.\n     */\n    mergeEntities: __NodeActions__.mergeEntities,\n    /**\n     * Removes an entity from the current context.\n     */\n    removeEntity: __NodeActions__.removeEntity,\n    /**\n     * Adds a symbol to the current context.\n     */\n    addSymbol: __NodeActions__.addSymbol,\n    /**\n     * Fetches a symbol from the current context.\n     */\n    fetchSymbol: __NodeActions__.fetchSymbol,\n    /**\n     * Retrieves a symbol from the current context by its index.\n     */\n    getSymbol: __NodeActions__.getSymbol,\n    /**\n     * Merges a symbol into the current context.\n     */\n    mergeSymbol: __NodeActions__.mergeSymbol,\n    /**\n     * Merges multiple symbols into the current context.\n     */\n    mergeSymbols: __NodeActions__.mergeSymbols,\n    /**\n     * Retrieves a symbol from the current context.\n     */\n    symbol: __NodeActions__.symbol,\n    /**\n     * Retrieves all symbols from the current context.\n     */\n    symbols: __NodeActions__.symbols,\n};\nexport default actions;\n","// import { Context } from './index.js';\nimport * as Constants from './constants.js';\nimport { actions as defaultActions } from './node.js';\n/**\n * The Options class represents the options for a node.\n */\nexport class Options {\n    actions;\n    batchActionPayloadSizes;\n    compressStringsAsInts;\n    defaultSymbols;\n    enableRollback;\n    enableQuerying;\n    enumDefaultSymbols;\n    getActorId;\n    getGroupedValue;\n    indexes;\n    isAuthority;\n    isAsyncStorage;\n    isComponentRelay;\n    isDiffed;\n    isGroupedComponents;\n    isOrdered;\n    isReadOnly;\n    isSymbolLeader;\n    isSymbolRelay;\n    onUpdate;\n    pageSize;\n    responder;\n    skipPending;\n    types;\n    setGroupedValue;\n    storeOptions;\n    updateOptions;\n    worldOptions;\n    // [key: string]: any;\n    /**\n     * Ensures that the provided options are an instance of Options.\n     *\n     * @param {Options | OptionsProps} options - The options for the node.\n     * @param {any} actionsThis - The context for the actions.\n     * @returns {Options} - An instance of Options.\n     */\n    static ensure(options = {}, actionsThis) {\n        return options instanceof Options ? options : new Options(options, actionsThis);\n    }\n    /**\n     * Constructs a new Options object.\n     *\n     * @param {Options | OptionsProps} options - The options for the node.\n     * @param {any} actionsThis - The context for the actions.\n     */\n    constructor(options = {}, actionsThis = null) {\n        const { actions = actionsThis || defaultActions, batchActionPayloadSizes = Constants.batchActionPayloadSizes, compressStringsAsInts = Constants.defaultOptions.compressStringsAsInts, defaultSymbols = Constants.DefaultSymbols, enableRollback = Constants.defaultOptions.enableRollback, enableQuerying = Constants.defaultOptions.enableQuerying, enumDefaultSymbols = Constants.enumDefaultSymbols, getActorId = Constants.defaultGetActorId, getGroupedValue = Constants.defaultGetGroupedValue, indexes = Constants.defaultOptions.indexes, isAuthority = Constants.defaultOptions.isAuthority, isAsyncStorage = Constants.defaultOptions.isAsyncStorage, isComponentRelay = Constants.defaultOptions.isComponentRelay, isDiffed = Constants.defaultOptions.isDiffed, isGroupedComponents = Constants.defaultOptions.isGroupedComponents, isOrdered = Constants.defaultOptions.isOrdered, isReadOnly = Constants.defaultOptions.isReadOnly, isSymbolLeader = Constants.defaultOptions.isSymbolLeader, isSymbolRelay = Constants.defaultOptions.isSymbolRelay, onUpdate = null, pageSize = Constants.defaultOptions.pageSize, responder = Constants.voidResponder, skipPending = Constants.defaultOptions.skipPending, types = Constants.defaultOptions.types, setGroupedValue = Constants.defaultSetGroupedValue, storeOptions = {}, updateOptions: overridenUpdateOptions = {}, worldOptions = null,\n        // ...otherOptions\n         } = options;\n        const updateOptions = {\n            ...Constants.defaultUpdateOptions,\n            ...overridenUpdateOptions\n        };\n        updateOptions.validKeys = !overridenUpdateOptions?.validKeys\n            ? null\n            : {\n                ...Constants.defaultValidKeys,\n                ...(overridenUpdateOptions?.validKeys || {})\n            };\n        this.actions = actions;\n        this.batchActionPayloadSizes = batchActionPayloadSizes;\n        this.compressStringsAsInts = compressStringsAsInts;\n        this.defaultSymbols = defaultSymbols;\n        this.enableRollback = enableRollback;\n        this.enableQuerying = enableQuerying;\n        this.enumDefaultSymbols = enumDefaultSymbols;\n        this.getActorId = getActorId;\n        this.getGroupedValue = getGroupedValue;\n        this.indexes = indexes;\n        this.isAuthority = isAuthority;\n        this.isAsyncStorage = isAsyncStorage;\n        this.isComponentRelay = isComponentRelay;\n        this.isDiffed = isDiffed;\n        this.isGroupedComponents = isGroupedComponents;\n        this.isOrdered = isOrdered;\n        this.isReadOnly = isReadOnly;\n        this.isSymbolLeader = isSymbolLeader;\n        this.isSymbolRelay = isSymbolRelay;\n        this.onUpdate = onUpdate;\n        this.pageSize = pageSize;\n        this.responder = responder;\n        this.skipPending = skipPending;\n        this.types = types;\n        this.setGroupedValue = setGroupedValue;\n        this.storeOptions = storeOptions;\n        this.updateOptions = updateOptions;\n        this.worldOptions = worldOptions;\n        // Object.assign(this, otherOptions)\n    }\n    /**\n     * Creates a new Options object from the current one.\n     *\n     * @param {Options | OptionsProps} options - The options for the node.\n     * @param {any} actionThis - The context for the actions.\n     */\n    clone() {\n        return new Options({ ...this }, this.actions);\n    }\n    /**\n     * Extends the current Options object.\n     *\n     * @param {Options | OptionsProps | Object} options - The options for the node.\n     * @param {any} actionThis - The context for the actions.\n     */\n    extend(options, actionThis = this.actions) {\n        return new Options({ ...this, ...options }, actionThis);\n    }\n}\nexport default Options;\n","import { now } from './utils.js';\n/**\n * The Ordered class represents a collection of tick values.\n *\n * @property {OrderedData} order - The collection of tick values.\n */\nexport class Ordered {\n    order;\n    /**\n     * Constructs a new Ordered object.\n     *\n     * @param {OrderedData} order - The initial tick values.\n     */\n    constructor(order = {}) {\n        this.order = order;\n    }\n    /**\n     * Changes the tick value of a component.\n     *\n     * @param {string} id - The ID of the component.\n     * @param {string} key - The key of the component.\n     * @param {number} tick - The new tick value.\n     * @returns {boolean} Whether the operation was successful.\n     */\n    changeComponent(id, key, tick) {\n        return this.upsertComponent(id, key, tick);\n    }\n    /**\n     * Resets the tick values.\n     *\n     * @param {OrderedData} order - The new tick values.\n     * @returns {Ordered} The Ordered object.\n     */\n    reset(order = {}) {\n        this.order = order;\n    }\n    /**\n     * Inserts or updates the tick value of a component.\n     *\n     * @param {string} id - The ID of the component.\n     * @param {string} key - The key of the component.\n     * @param {number} tick - The new tick value.\n     * @returns {boolean} Whether the operation was successful.\n     */\n    upsertComponent(id, key, tick) {\n        if (isNaN(tick)) {\n            return false;\n        }\n        this.order = this.order || {};\n        this.order[id] = this.order[id] || {};\n        switch (typeof this.order[id][key]) {\n            case 'number':\n                if (isFinite(this.order[id][key]) && this.order[id][key] <= tick) {\n                    const threshold = 0;\n                    if (tick > (now() + threshold)) {\n                        return false;\n                    }\n                    this.order[id][key] = tick;\n                    return true;\n                }\n                return false;\n            case 'undefined':\n            default:\n                this.order[id][key] = tick;\n                return true;\n        }\n    }\n}\nexport default Ordered;\n","/**\n * The Pending class represents a pending state with removed, updated, and created states.\n *\n * @property {RemovedState} removed - The removed state.\n * @property {UpdatedState} updated - The updated state.\n * @property {CreatedState} created - The created state.\n */\nexport class Pending {\n    /**\n     * Constructs a new Pending object and resets its state.\n     */\n    constructor(isDiffed = false) {\n        this.created = {\n            actors: {},\n            components: {},\n            entities: [],\n            inputs: {}\n        };\n        this.removed = {\n            actors: {},\n            components: {},\n            entities: []\n        };\n        this.updated = {\n            components: {}\n        };\n        this.symbols = [];\n        this.isDiffed = isDiffed;\n    }\n    /**\n     * Adds an actor input to the created inputs state.\n     *\n     * @param {string} id - The ID of the actor.\n     * @param {number} index - The index of the new input.\n     */\n    actorInput(id, index) {\n        this.created.inputs[id] = this.created.inputs[id] || [];\n        this.created.inputs[id].push(index);\n    }\n    /**\n     * Changes a component in the specified pending state.\n     *\n     * @param {string} pendingType - The type of the pending state (removed, updated, or created).\n     * @param {string} id - The ID of the entity.\n     * @param {string} key - The key of the component.\n     */\n    changeComponent(pendingType, id, key) {\n        return this.upsertComponent(pendingType, id, key);\n    }\n    /**\n     * Marks an entity as created in the created state.\n     *\n     * @param {string} id - The ID of the entity to create.\n     */\n    createEntity(id) {\n        this.created.entities.push(id);\n    }\n    /**\n     * Marks an actor as removed in the removed state.\n     *\n     * @param {string} id - The ID of the actor to remove.\n     */\n    removeActor(id) {\n        this.removed.actors[id] = true;\n    }\n    /**\n     * Marks a component as removed in the removed state.\n     *\n     * @param {string} id - The ID of the entity.\n     * @param {string} key - The key of the component to remove.\n     */\n    removeComponent(id, key) {\n        this.removed.components[id] = this.removed.components[id] || {};\n        this.removed.components[id][key] = true;\n    }\n    /**\n     * Marks an entity as removed in the removed state.\n     *\n     * @param {string} id - The ID of the entity to remove.\n     */\n    removeEntity(id) {\n        this.removed.entities.push(id);\n    }\n    /**\n     * Resets the state of the Pending object.\n     */\n    reset() {\n        this.constructor();\n    }\n    /**\n     * Marks an actor as spawned in the created state.\n     *\n     * @param {string} id - The ID of the actor to spawn.\n     */\n    spawnActor(id) {\n        this.created.actors[id] = true;\n    }\n    /**\n     * Inserts or updates a component in the specified pending state.\n     *\n     * @param {string} pendingType - The type of the pending state (created or updated).\n     * @param {string} id - The ID of the entity.\n     * @param {string} key - The key of the component.\n     */\n    upsertComponent(pendingType, id, key) {\n        const pending = pendingType === 'created' ? this.created : this.updated;\n        if (pending) {\n            if (\n            // !this.isDiffed // Diffed updates need to be created.\n            // &&\n            pendingType === 'updated'\n                && this.created.components[id]\n                && this.created.components[id][key]) {\n                // Skip updating a component that was created and updated in the same tick.\n                return;\n            }\n            pending.components[id] = pending.components[id] || {};\n            pending.components[id][key] = true;\n        }\n    }\n    /**\n     * Adds a symbol tuple to the symbols array.\n     *\n     * @param {any} symbolTuple - The symbol tuple to add.\n     */\n    addSymbol(symbolTuple) {\n        this.symbols.push(symbolTuple);\n    }\n    /**\n     * Replaces the symbols array with a new array of symbol tuples.\n     *\n     * @param {any[]} symbols - The new array of symbols.\n     */\n    replaceSymbols(offset, symbols) {\n        if (offset > 0) {\n            const { length } = symbols;\n            const { symbols: _symbols } = this;\n            for (let i = 0; i < length; i++) {\n                const value = symbols[i];\n                const index = i + offset;\n                _symbols[index] = [value, index];\n            }\n        }\n        else {\n            this.symbols = symbols.map((v, i) => [v, i]);\n        }\n    }\n}\nexport default Pending;\n","import { Changes } from './changes.js';\nimport { Emitter } from './emitter.js';\nimport { Options } from './options.js';\nimport { Ordered } from './ordered.js';\nimport { Pending } from './pending.js';\nimport { Symbols } from './symbols.js';\nimport { Storage } from './storage.js';\n// import { StorageInterface } from './storage/interface'\nimport { combineValues, now } from './utils.js';\nimport { allActions } from './node.js';\n/**\n * The Context class provides methods for managing the context.\n*\n* @property {any} events - The events.\n* @property {StorageInterface} store - The store.\n* @property {Ordered | null} order - The order.\n* @property {Changes | null} changes - The changes.\n* @property {Pending | null} pending - The pending.\n*/\nexport class Context {\n    /**\n     * Ensures that the given context is an instance of the Context class.\n     *\n     * @param {Context | ContextProps} context - The context to ensure.\n     * @param {Options | any} options - The options for ensuring the context.\n     * @param {Storage} _Storage - The store.\n     * @returns {Context} The context.\n     */\n    static ensure(context, options, _Storage = Storage) {\n        if (context instanceof Context) {\n            return context;\n        }\n        return new Context(context, options, _Storage);\n    }\n    /**\n     * Creates a new instance of the Context class.\n     *\n     * @param {Context | ContextProps} context - The context properties.\n     * @param {Options | any} options - The context options.\n     * @param {Storage} _Storage - The store.\n     */\n    constructor(context = {}, options, _Storage = Storage) {\n        const { events = null, store = null, order = null, changes = null, symbols = null, pending = null,\n        // ...otherProps\n         } = context;\n        options = Options.ensure(options, options?.actions || allActions);\n        const { isOrdered, isDiffed, isReadOnly, compressStringsAsInts, enableQuerying, enumDefaultSymbols, storeOptions, indexes, types, } = options;\n        if (isOrdered) {\n            this.order = new Ordered(order);\n        }\n        else {\n            this.order = null;\n        }\n        if (isDiffed) {\n            this.changes = new Changes(this, changes);\n        }\n        else {\n            this.changes = null;\n        }\n        if (compressStringsAsInts) {\n            if (symbols) {\n                this.symbols = new Symbols(symbols);\n            }\n            else {\n                this.symbols = new Symbols();\n                this.symbols.copyEnum(enumDefaultSymbols);\n            }\n        }\n        else {\n            this.symbols = null;\n        }\n        if (isReadOnly) {\n            this.pending = null;\n        }\n        else {\n            this.pending = pending || new Pending(isDiffed);\n        }\n        this.events = events;\n        this.store = store || new _Storage(undefined, {\n            ...(storeOptions || {}),\n            types,\n            indexes: enableQuerying ? indexes : null,\n        });\n        // Object.assign(this, otherProps)\n    }\n    /**\n     * Gets the actors from the store.\n     *\n     * @returns The actors from the store.\n     */\n    get actors() {\n        const actors = this.getActors(null, Infinity);\n        if (actors instanceof Emitter) {\n            return actors;\n        }\n        return actors[0];\n    }\n    /**\n     * Gets the actors from the store with the given query.\n     *\n     * @param {any} query - The query for getting the actors.\n     * @param {number} pageSize - The page size for getting the actors.\n     * @returns {Emitter<string[][]> | string[][]} The actors from the store.\n     */\n    getActors(query, pageSize) {\n        return this.store.getActors(query, pageSize);\n    }\n    /**\n     * Spawns an actor with the given id and options.\n     *\n     * @param {string} id - The id of the actor to spawn.\n     * @param {Options} options - The options for spawning the actor.\n     */\n    spawnActor(id, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const addedOrPromise = this.store.storeActor(id);\n        const completeActorInput = (added) => {\n            if (!added) {\n                return;\n            }\n            if (!skipPending && this.pending) {\n                this.pending.spawnActor(id);\n            }\n            if (this.events) {\n                this.events.emit('spawnActor', id);\n            }\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && addedOrPromise instanceof Promise) {\n            addedOrPromise.then(completeActorInput);\n            return addedOrPromise;\n        }\n        completeActorInput(addedOrPromise);\n        return addedOrPromise;\n    }\n    /**\n     * Removes an actor with the given id and options.\n     *\n     * @param {string} id - The id of the actor to remove.\n     * @param {Options} options - The options for removing the actor.\n     */\n    removeActor(id, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const removedOrPromise = this.store.destroyActor(id);\n        const completeRemoveActor = (removed) => {\n            if (removed) {\n                if (!skipPending && this.pending) {\n                    this.pending.removeActor(id);\n                }\n                if (this.events) {\n                    this.events.emit('removeActor', id);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n        };\n        if (isAsyncStorage && removedOrPromise instanceof Promise) {\n            removedOrPromise.then(completeRemoveActor);\n            return removedOrPromise;\n        }\n        completeRemoveActor(removedOrPromise);\n        return removedOrPromise;\n    }\n    /**\n     * Merges actors with the given payload and options.\n     *\n     * @param {any[]} payload - The payload of the actors to merge.\n     * @param {Options} options - The options for merging the actors.\n     */\n    mergeActors(payload, options) {\n        const { actions, isAsyncStorage, onUpdate } = options;\n        const nextOptions = options.extend({\n            onUpdate: null\n        });\n        const promises = [];\n        for (const id of payload) {\n            const promise = actions.spawnActor(id, this, nextOptions);\n            if (isAsyncStorage && promise instanceof Promise) {\n                promises.push(promise);\n            }\n        }\n        const completeMergeActors = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && promises.length > 0) {\n            const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n            all.then(completeMergeActors);\n            return all;\n        }\n        completeMergeActors();\n    }\n    /**\n     * Gets the entities from the store.\n     *\n     * @returns The entities from the store.\n     */\n    get entities() {\n        const entities = this.getEntities(null, Infinity);\n        if (entities instanceof Emitter) {\n            return entities;\n        }\n        return entities[0];\n    }\n    /**\n     * Gets the entities from the store with the given query.\n     *\n     * @param {any} query - The query for getting the entities.\n     * @param {number} pageSize - The page size for getting the entities.\n     * @returns {Emitter<string[][]> | string[][]} The entities from the store.\n     */\n    getEntities(query, pageSize) {\n        return this.store.getEntities(query, pageSize);\n    }\n    /**\n     * Creates an entity with the given id and options.\n     *\n     * @param {string} id - The id of the entity to create.\n     * @param {Options} options - The options for creating the entity.\n     */\n    createEntity(id, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const added = this.store.storeEntity(id);\n        const completeCreateEntity = (added) => {\n            if (added) {\n                if (!skipPending && this.pending) {\n                    this.pending.createEntity(id);\n                }\n                if (this.events) {\n                    this.events.emit('createEntity', id);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n        };\n        if (isAsyncStorage && added instanceof Promise) {\n            added.then(completeCreateEntity);\n            return added;\n        }\n        completeCreateEntity(added);\n        return added;\n    }\n    /**\n     * Removes an entity with the given id and options.\n     *\n     * @param {string} id - The id of the entity to remove.\n     * @param {Options} options - The options for removing the entity.\n     */\n    removeEntity(id, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const removed = this.store.destroyEntity(id);\n        const completeRemoveEntity = (removed) => {\n            if (removed) {\n                if (!skipPending && this.pending) {\n                    this.pending.removeEntity(id);\n                }\n                if (this.events) {\n                    this.events.emit('removeEntity', id);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n        };\n        if (isAsyncStorage && removed instanceof Promise) {\n            removed.then(completeRemoveEntity);\n            return removed;\n        }\n        completeRemoveEntity(removed);\n        return removed;\n    }\n    /**\n     * Merges entities with the given payload and options.\n     *\n     * @param {string[]} payload - The payload of the entities to merge.\n     * @param {Options} options - The options for merging the entities.\n     */\n    mergeEntities(payload, options) {\n        const { actions, isAsyncStorage, onUpdate } = options;\n        const nextOptions = options.extend({\n            onUpdate: null\n        });\n        const promises = [];\n        for (const id of payload) {\n            const promise = actions.createEntity(id, this, nextOptions);\n            if (isAsyncStorage && promise instanceof Promise) {\n                promises.push(promise);\n            }\n        }\n        const completeMergeEntities = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && promises.length > 0) {\n            const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n            all.then(completeMergeEntities);\n            return all;\n        }\n        completeMergeEntities();\n    }\n    /**\n     * Gets the components from the store.\n     *\n     * @returns The components from the store.\n     */\n    get components() {\n        const components = this.getComponents(null, Infinity);\n        if (components instanceof Emitter) {\n            return components;\n        }\n        return components[0];\n    }\n    /**\n     * Gets the components from the store with the given query.\n     *\n     * @param {any} query - The query for getting the components.\n     * @param {number} pageSize - The page size for getting the components.\n     * @returns {Emitter<Components[]> | Components[]} The components from the store.\n     */\n    getComponents(query, pageSize) {\n        return this.store.getComponents(query, pageSize);\n    }\n    /**\n     * Changes a component with the given id, key, value, and options.\n     *\n     * @param {string | string[] | Uint32Array} id - The id of the component to change.\n     * @param {string} key - The key of the component to change.\n     * @param {any | any[]} value - The value to change in the component.\n     * @param {number} tick - The tick value for the component. Defaults to 0.\n     * @param {Options} options - The options for changing the component.\n     */\n    changeComponent(id, key, value, tick = 0, options) {\n        const { actions, skipPending, isAsyncStorage, isGroupedComponents, getGroupedValue, types, onUpdate } = options;\n        const completeChangeComponentUpdate = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (Array.isArray(id) || id instanceof Uint32Array) {\n            if (!isGroupedComponents) {\n                throw new Error('Cannot change grouped components without isGroupedComponents option');\n            }\n            const noUpdateOptions = options.extend({ onUpdate: null });\n            const promises = [];\n            for (let i = 0; i < id.length; i++) {\n                const val = getGroupedValue(value, i, types, key);\n                const promise = actions.changeComponent([id[i], key, val, tick], this, noUpdateOptions);\n                if (isAsyncStorage && promise instanceof Promise) {\n                    promises.push(promise);\n                }\n            }\n            if (isAsyncStorage && promises.length > 0) {\n                const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n                all.then(completeChangeComponentUpdate);\n                return all;\n            }\n            completeChangeComponentUpdate();\n            return;\n        }\n        const currentValueOrPromise = this.store.findComponent(id, key);\n        const completeChangeComponents = (currentValue) => {\n            const pendingType = typeof currentValue === 'undefined' ? 'created' : 'updated';\n            if (this.order) {\n                const isValidOrder = this.order.changeComponent(id, key, tick);\n                if (!isValidOrder && !this.changes) {\n                    return;\n                }\n            }\n            let nextValue;\n            if (pendingType === 'created') {\n                nextValue = value;\n            }\n            else {\n                // nextValue = value\n                [/* combined */ , nextValue] = combineValues(currentValue, value);\n            }\n            let promise = null;\n            if (this.changes) {\n                promise = this.changes.changeComponent(id, key, nextValue, value, isAsyncStorage);\n            }\n            else {\n                promise = this.store.storeComponent(id, key, nextValue);\n            }\n            const completeChangeComponentStorage = () => {\n                if (!skipPending && this.pending) {\n                    this.pending.changeComponent(pendingType, id, key);\n                }\n                if (this.events) {\n                    this.events.emit('changeComponent', id, key);\n                }\n                completeChangeComponentUpdate();\n            };\n            if (isAsyncStorage && promise instanceof Promise) {\n                promise.then(completeChangeComponentStorage);\n                return promise;\n            }\n            completeChangeComponentStorage();\n        };\n        if (isAsyncStorage && currentValueOrPromise instanceof Promise) {\n            currentValueOrPromise.then(completeChangeComponents);\n            return currentValueOrPromise;\n        }\n        completeChangeComponents(currentValueOrPromise);\n        return currentValueOrPromise;\n    }\n    /**\n     * Upserts a component with the given id, key, value, and options.\n     *\n     * @param {string | string[] | Uint32Array} id - The id of the component to upsert.\n     * @param {string} key - The key of the component to upsert.\n     * @param {any | any[]} value - The value to upsert in the component.\n     * @param {number} tick - The tick value for the component. Defaults to 0.\n     * @param {Options} options - The options for upserting the component.\n     */\n    upsertComponent(id, key, value, tick = 0, options) {\n        const { actions, skipPending, isAsyncStorage, isGroupedComponents, getGroupedValue, types, onUpdate } = options;\n        const completeUpsertComponentUpdate = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (Array.isArray(id) || id instanceof Uint32Array) {\n            if (!isGroupedComponents) {\n                throw new Error('Cannot upsert grouped components without isGroupedComponents option');\n            }\n            const noUpdateOptions = options.extend({ onUpdate: null });\n            const promises = [];\n            for (let i = 0; i < id.length; i++) {\n                const val = getGroupedValue(value, i, types, key);\n                const promise = actions.upsertComponent([id[i], key, val, tick], this, noUpdateOptions);\n                if (isAsyncStorage && promise instanceof Promise) {\n                    promises.push(promise);\n                }\n            }\n            if (isAsyncStorage && promises.length > 0) {\n                const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n                all.then(completeUpsertComponentUpdate);\n                return all;\n            }\n            completeUpsertComponentUpdate();\n            return;\n        }\n        const currentValueOrPromise = this.store.findComponent(id, key);\n        const completeUpsertComponent = (currentValue) => {\n            if (currentValue !== value) {\n                if (this.order) {\n                    const isValidOrder = this.order.upsertComponent(id, key, tick);\n                    if (!isValidOrder && !this.changes) {\n                        return;\n                    }\n                }\n                let promise = null;\n                if (this.changes) {\n                    promise = this.changes.upsertComponent(id, key, value, currentValue, isAsyncStorage);\n                }\n                else {\n                    promise = this.store.storeComponent(id, key, value);\n                }\n                const completeUpsertComponentStorage = () => {\n                    if (!skipPending && this.pending) {\n                        const pendingType = typeof currentValue === 'undefined' ? 'created' : 'updated';\n                        this.pending.upsertComponent(pendingType, id, key);\n                    }\n                    if (this.events) {\n                        this.events.emit('upsertComponent', id, key);\n                    }\n                    completeUpsertComponentUpdate();\n                };\n                if (isAsyncStorage && promise instanceof Promise) {\n                    promise.then(completeUpsertComponentStorage);\n                    return promise;\n                }\n                completeUpsertComponentStorage();\n            }\n        };\n        if (isAsyncStorage && currentValueOrPromise instanceof Promise) {\n            currentValueOrPromise.then(completeUpsertComponent);\n            return currentValueOrPromise;\n        }\n        completeUpsertComponent(currentValueOrPromise);\n        return currentValueOrPromise;\n    }\n    /**\n     * Removes a component with the given id, key, and options.\n     *\n     * @param {string} id - The id of the component to remove.\n     * @param {string} key - The key of the component to remove.\n     * @param {Options} options - The options for removing the component.\n     */\n    removeComponent(id, key, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const currentValueOrPromise = this.store.findComponent(id, key);\n        const completeRemoveComponent = (currentValue) => {\n            if (currentValue !== undefined || currentValue !== null) {\n                this.store.destroyComponent(id, key);\n                if (!skipPending && this.pending) {\n                    this.pending.removeComponent(id, key);\n                }\n                if (this.events) {\n                    this.events.emit('removeComponent', id, key);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n                return true;\n            }\n            return false;\n        };\n        if (isAsyncStorage && currentValueOrPromise instanceof Promise) {\n            return new Promise((resolve, reject) => {\n                currentValueOrPromise.then((currentValue) => {\n                    resolve(completeRemoveComponent(currentValue));\n                }, reject);\n            });\n        }\n        return completeRemoveComponent(currentValueOrPromise);\n    }\n    /**\n     * Merges components with the given payload and options.\n     *\n     * @param {any} payload - The payload of the components to merge.\n     * @param {Options} options - The options for merging the components.\n     */\n    mergeComponents(payload, options) {\n        const { actions, isAsyncStorage, isComponentRelay, onUpdate } = options;\n        const nextOptions = options.extend({\n            skipPending: !isComponentRelay,\n            onUpdate: null\n        });\n        const promises = [];\n        for (const id in (payload ?? {})) {\n            for (const key in payload[id]) {\n                const value = payload[id][key];\n                const nextPayload = [id, key, value];\n                const promise = actions.upsertComponent(nextPayload, this, nextOptions);\n                if ( /* isAsyncStorage && */promise instanceof Promise) {\n                    promises.push(promise);\n                }\n            }\n        }\n        const completeMergeComponents = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && promises.length > 0) {\n            const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n            all.then(completeMergeComponents);\n            return all;\n        }\n        completeMergeComponents();\n    }\n    /**\n     * Gets the inputs from the store.\n     *\n     * @returns The inputs from the store.\n     */\n    get inputs() {\n        const inputs = this.getInputs(null, Infinity);\n        if (inputs instanceof Emitter) {\n            return inputs;\n        }\n        return inputs[0];\n    }\n    /**\n     * Gets the inputs from the store with the given query.\n     *\n     * @param {any} query - The query for getting the inputs.\n     * @param {number} pageSize - The page size for getting the inputs.\n     * @returns {Emitter<Inputs[]> | Inputs[]} The inputs from the store.\n     */\n    getInputs(query, pageSize) {\n        return this.store.getInputs(query, pageSize);\n    }\n    /**\n     * Handles actor input with the given id, payload, and options.\n     *\n     * @param {string} id - The id of the actor.\n     * @param {InputPayload} input - The payload for the actor input.\n     * @param {number} tick - The tick value for the actor input. Defaults to 0.\n     * @param {Options} options - The options for handling the actor input.\n     */\n    actorInput(id, input, tick = 0, options) {\n        const { skipPending, isAsyncStorage, enableRollback, onUpdate } = options;\n        tick = enableRollback ? tick || now() : 0;\n        const indexOrPromise = this.store.storeInput(id, input, tick);\n        const completeActorInput = (index) => {\n            if (!skipPending && this.pending) {\n                this.pending.actorInput(id, index);\n            }\n            if (this.events) {\n                this.events.emit('actorInput', id, input, index, tick);\n            }\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && indexOrPromise instanceof Promise) {\n            indexOrPromise.then(completeActorInput);\n            return indexOrPromise;\n        }\n        completeActorInput(indexOrPromise);\n        return indexOrPromise;\n    }\n    /**\n     * Gets the list of symbols.\n     *\n     * @returns The list of symbols.\n     */\n    get symbolsList() {\n        return this.symbols?.getSymbols();\n    }\n    /**\n     * Gets the enum of symbols.\n     *\n     * @returns The enum of symbols.\n     */\n    get symbolsEnum() {\n        return this.symbols?.getSymbolsEnum();\n    }\n    /**\n     * Sets the symbols with the given symbols.\n     *\n     * @param {any} symbols - The symbols to set.\n     */\n    setSymbols(symbols) {\n        this.symbols?.reset(symbols);\n    }\n    /**\n     * Gets a symbol with the given index and options.\n     *\n     * @param {number} index - The index of the symbol to get.\n     * @param {Options} options - The options for getting the symbol.\n     * @returns The symbol.\n     */\n    getSymbol(index, options) {\n        const { actions } = options;\n        const symbol = this.symbols?.get(index);\n        if (!symbol) {\n            const symbolTuple = actions.fetchSymbol(symbol, this, options);\n            return symbolTuple[0];\n        }\n        return symbol;\n    }\n    /**\n     * Adds a symbol with the given symbol and options.\n     *\n     * @param {string} symbol - The symbol to add.\n     * @param {Options} options - The options for adding the symbol.\n     * @returns The index of the added symbol or null if the symbol could not be added.\n     */\n    addSymbol(symbol, options) {\n        if (this.symbols === null) {\n            return null;\n        }\n        const { actions, isSymbolLeader, skipPending, onUpdate } = options;\n        const enumSymbols = this.symbolsEnum ?? {};\n        let index = Object.prototype.hasOwnProperty.call(enumSymbols, symbol) ? enumSymbols[symbol] : -1;\n        if (index === -1) {\n            if (isSymbolLeader) {\n                index = this.symbols.add(symbol) ?? -1;\n                if (!skipPending && this.pending) {\n                    this.pending.addSymbol([symbol, index]);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n            else if (actions.fetchSymbol) {\n                const symbolTuple = actions.fetchSymbol(symbol, this, options);\n                index = symbolTuple[1];\n            }\n        }\n        if (index === -1) {\n            return null;\n        }\n        return index;\n    }\n    /**\n     * Fetches a symbol with the given payload, options, and match function.\n     *\n     * @param {string | number} payload - The payload for fetching the symbol.\n     * @param {Options} options - The options for fetching the symbol.\n     * @param {Function} onMatch - The function to call when a match is found.\n     * @returns The fetched symbol tuple.\n     */\n    fetchSymbol(payload, options, onMatch) {\n        if (this.symbols === null) {\n            return null;\n        }\n        const { isSymbolLeader, skipPending, onUpdate } = options;\n        const symbolTuple = this.symbols.fetch(payload);\n        if (symbolTuple[0] && symbolTuple[1] !== -1) {\n            if (onMatch) {\n                onMatch(symbolTuple);\n            }\n        }\n        else {\n            if (isSymbolLeader) {\n                const index = this.symbols.add(symbolTuple[0]);\n                symbolTuple[1] = index;\n                if (!skipPending && this.pending) {\n                    this.pending.addSymbol(symbolTuple);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n        }\n        return symbolTuple;\n    }\n    /**\n     * Merges a symbol with the given payload and options.\n     *\n     * @param {[string, number]} payload - The payload for merging the symbol.\n     * @param {Options} options - The options for merging the symbol.\n     */\n    mergeSymbol(payload, options) {\n        if (this.symbols === null) {\n            return null;\n        }\n        const { isSymbolLeader, isSymbolRelay, skipPending, onUpdate } = options;\n        this.symbols.merge(payload);\n        if ((isSymbolLeader || isSymbolRelay) && !skipPending && this.pending) {\n            this.pending.addSymbol(payload);\n        }\n        if (onUpdate) {\n            onUpdate();\n        }\n    }\n    /**\n     * Resets symbols with the given payload and options.\n     *\n     * @param {any[]} payload - The payload for resetting the symbols.\n     * @param {Options} options - The options for resetting the symbols.\n     */\n    resetSymbols(offset = 0, symbols, options) {\n        if (this.symbols === null) {\n            return null;\n        }\n        const { isSymbolLeader, isSymbolRelay, skipPending, onUpdate } = options;\n        this.symbols.reset(offset, symbols);\n        if ((isSymbolLeader || isSymbolRelay) && !skipPending && this.pending) {\n            this.pending.replaceSymbols(offset, symbols);\n        }\n        if (onUpdate) {\n            onUpdate();\n        }\n    }\n    /**\n     * Resets the current frame state.\n     */\n    resetFrame() {\n        if (this.pending) {\n            this.pending.reset();\n        }\n        if (this.order) {\n            this.order.reset();\n        }\n        if (this.changes) {\n            this.changes.reset();\n        }\n    }\n}\nexport default Context;\n","import nodeActions, { NodeActions } from './node.js';\nexport class ClientActions extends NodeActions {\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    actors() { }\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    components() { }\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    entities() { }\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    symbol() { }\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    symbols() { }\n}\n/**\n * An object that maps the names of actions.\n */\nexport const actions = {\n    /**\n     * The actions related to nodes, imported from the node module.\n     */\n    ...nodeActions,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    actors: null,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    components: null,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    entities: null,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    symbol: null,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    symbols: null\n};\nexport default actions;\n","/**\n * Exports all the constants.\n */\nexport * as Constants from './constants.js';\n// Index Classes\n/**\n * Exports all the indexes-related classes.\n */\nexport * from './indexes/components.js';\nexport * from './indexes/index.js';\nexport * from './indexes/sorted.js';\nexport * from './indexes/spatial.js';\n// Main Classes\n/**\n * Exports all the actions-related functions and classes.\n */\nexport * from './changes.js';\n/**\n * Exports all the context-related functions and classes.\n*/\nexport * from './context.js';\n/**\n * Exports all the actions-related functions and classes.\n */\nexport * from './emitter.js';\n/**\n * Exports all the handler-related functions and classes.\n */\nexport * from './handler.js';\n/**\n * Exports all the options-related functions and classes.\n */\nexport * from './options.js';\n/**\n * Exports all the actions-related functions and classes.\n */\nexport * from './ordered.js';\n/**\n * Exports all the pending-related functions and classes.\n */\nexport * from './pending.js';\n/**\n * Exports all the store-related functions and classes.\n */\nexport * from './storage.js';\n/**\n * Exports all the symbols-related functions and classes.\n */\nexport * from './symbols.js';\n/**\n * Exports all the types-related functions and classes.\n */\nexport * from './types.js';\n// Utils\n/**\n * Exports all the updater-related functions and classes.\n */\nexport * from './updater.js';\n/**\n * Exports all the utility functions.\n */\nexport * as utils from './utils.js';\n// Node Actions\n/**\n * Exports all the node-related functions and classes.\n */\nexport * as Node from './node.js';\n/**\n * Exports all the client-related functions and classes.\n */\nexport * as Client from './client.js';\n// Action Modules\n/**\n * Exports all the actions-related functions and classes.\n */\nexport * as Actor from './actions/actor.js';\n/**\n * Exports all the component-related functions and classes.\n */\nexport * as Component from './actions/component.js';\n/**\n * Exports all the core-related functions and classes.\n */\nexport * as Core from './actions/core.js';\n/**\n * Exports all the entity-related functions and classes.\n */\nexport * as Entity from './actions/entity.js';\n/**\n * Exports all the entity-related functions and classes.\n */\nexport * as Symbol from './actions/symbol.js';\n/**\n * Exports the Handler class.\n*/\nimport Handler from './handler.js';\n// default export is the Handler class\nexport default Handler;\n"],"names":["root","factory","exports","module","define","amd","window","global","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","now","performance","timeOrigin","concatTypedArray","a","b","Array","isArray","concat","a_","constructor","length","set","b_","c","unionSetOrArray","sets","union","v","keys","unionSets","setA","setB","Set","add","differenceSets","difference","has","intersectionSets","intersection","binaryInsert","items","getValue","low","high","mid","binarySearch","target","left","right","createEnum","offset","_enum","i","messageTuple","message","action","payload","paginate","array","pageSize","Infinity","pages","page","push","typeOf","t","combineValues","objA","objB","recursiveCombination","typeA","newArr","combined","newObj","k","Actions","CommonComponents","DefaultSymbols","padEnum","enumActions","enumCommonComponents","actorInput","default","rollback","changeComponent","ordered","mergeSymbols","removeComponent","upsertComponent","defaultOptions","compressStringsAsInts","enableRollback","enableQuerying","isAuthority","isAsyncStorage","isComponentRelay","isDiffed","isGroupedComponents","isOrdered","isReadOnly","isSymbolLeader","isSymbolRelay","skipPending","indexes","position","type","types","asset","collider","color","hidden","rotation","velocity","spin","size","defaultUpdateOptions","mask","actors","entities","components","inputs","symbols","batched","batchSize","defaultValidKeys","voidResponder","defaultGetActorId","id","_context","defaultGetGroupedValue","slice","defaultSetGroupedValue","_types","_key","Index","_options","clear","clone","_value","_id","remove","store","preValue","query","_query","ComponentsIndex","super","ids","delete","other","with","with_","without","matches","SortedIndex","item","find","undefined","indexOf","lastIndexOf","splice","binaryRemoveID","binaryInsertID","SpatialIndex","cellSize","hash","hash2d","hash3d","x","y","Math","floor","z","index","results","xx","yy","zz","Changes","context","diffs","changes","newValue","prevValue","storedValue","diffedValue","reset","_prevValue","currentScopeOrPromise","findComponents","promises","completeUpsertComponent","currentScope","promise","storeComponent","Promise","diffObject","recursiveDiff","diff","scope","currVal","nextVal","prevType","nextType","d","toString","resolve","reject","then","all","Emitter","handlers","emissions","handlersDone","emissionsDone","handler","emission","cleanup","done","emitTo","emit","removeHandler","removeEmission","Symbols","_list","object","symbol","end","copyEnum","enumObj","symbolTuple","entries","merge","fetch","getSymbols","getSymbolsEnum","symbolsArray","extractSymbol","options","actions","getSymbol","ensureSymbolIndex","addSymbol","recursiveSymbolExtraction","charAt","recursiveFix","map","recursiveSymbolIndexesEnsured","ActorActionsFactory","Parent","Options","ensure","getActorId","input","tick","responder","enumDefaultSymbols","sendActors","mergeActors","ctxActors","getActors","removeActor","spawnActor","ActorActions","__ActorActions__","ComponentActionsFactory","String","sendComponents","mergeComponents","ctxComponents","getComponents","ComponentActions","__ComponentActions__","BasicTypes","Map","Number","Boolean","ArrayTypes","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","IndexMap","sorted","spatial","createStorageProps","props","storage","typeCtors","TypeCtor","componentsIndex","IndexCtor","Storage","destroyActor","destroyId","destroyComponent","removeComponentsIndex","destroyEntity","list","findComponent","findInputs","findInput","forEach","getEntities","getInputs","isActor","isEntity","setActors","setComponents","setEntities","setInputs","storeActor","storeId","updateComponentsIndex","storeEntity","storeInput","queryComponents","async","updater","setGroupedValue","updateOptions","validKeys","pending","batch","batchBlock","created","removed","updated","mergeBatch","queueMessage","ensureSymbol","upsertComponents","pendingComponents","state","groups","updatedComponents","Type","group","intIds","values","ticks","nid","nkey","bufferIds","bufferValues","bufferTicks","createEntity","removeEntity","createdInputs","isTuple","tick_","symbolOp","mergeSymbol","unshift","batchSlice","getSymbolAction","defaultSymbols","getActionHandler","oneHandler","actionHandler","manyHandler","batchActionPayloadSizes","iterator","payloadSize","Handler","_Storage","Context","one","extendOptions","extend","many","CoreActionsFactory","CoreActions","EntityActionsFactory","sendEntities","mergeEntities","ctxEntities","EntityActions","__EntityActions__","SymbolActionsFactory","fetchSymbol","resetSymbols","enumSymbols","symbolsEnum","_","symbolsList","SymbolActions","__SymbolActions__","AllActionsFactory","allActions","actor","component","core","entity","NodeActions","__NodeActions__","getGroupedValue","onUpdate","storeOptions","worldOptions","static","actionsThis","overridenUpdateOptions","actionThis","Ordered","order","isNaN","isFinite","threshold","Pending","pendingType","replaceSymbols","_symbols","events","addedOrPromise","completeActorInput","added","removedOrPromise","completeRemoveActor","nextOptions","completeMergeActors","completeCreateEntity","completeRemoveEntity","completeMergeEntities","completeChangeComponentUpdate","Error","noUpdateOptions","val","currentValueOrPromise","completeChangeComponents","currentValue","nextValue","completeChangeComponentStorage","completeUpsertComponentUpdate","completeUpsertComponentStorage","completeRemoveComponent","nextPayload","completeMergeComponents","indexOrPromise","setSymbols","onMatch","resetFrame","ClientActions","node"],"sourceRoot":""}