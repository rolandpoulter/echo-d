{"version":3,"file":"lib.echo-d.min.js","mappings":"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","sources":["webpack://echoD/webpack/universalModuleDefinition","webpack://echoD/webpack/runtime/async module","webpack://echoD/webpack/runtime/chunk loaded","webpack://echoD/webpack/runtime/create fake namespace object","webpack://echoD/webpack/runtime/load script","webpack://echoD/./lib/actions/actor.js","webpack://echoD/./lib/actions/component.js","webpack://echoD/./lib/actions/core.js","webpack://echoD/./lib/actions/entity.js","webpack://echoD/./lib/actions/symbol.js","webpack://echoD/./lib/changes.js","webpack://echoD/./lib/constants.js","webpack://echoD/./lib/context.js","webpack://echoD/./lib/emitter.js","webpack://echoD/./lib/handler.js","webpack://echoD/./lib/indexes/index.js","webpack://echoD/./lib/indexes/sorted.js","webpack://echoD/./lib/indexes/spatial.js","webpack://echoD/./lib/node.js","webpack://echoD/./lib/options.js","webpack://echoD/./lib/ordered.js","webpack://echoD/./lib/pending.js","webpack://echoD/./lib/indexes/components.js","webpack://echoD/./lib/storage.js","webpack://echoD/./lib/symbols.js","webpack://echoD/./lib/types.js","webpack://echoD/./lib/updater.js","webpack://echoD/./lib/utils.js","webpack://echoD/webpack/bootstrap","webpack://echoD/webpack/runtime/define property getters","webpack://echoD/webpack/runtime/ensure chunk","webpack://echoD/webpack/runtime/get javascript chunk filename","webpack://echoD/webpack/runtime/global","webpack://echoD/webpack/runtime/hasOwnProperty shorthand","webpack://echoD/webpack/runtime/make namespace object","webpack://echoD/webpack/runtime/publicPath","webpack://echoD/webpack/runtime/jsonp chunk loading","webpack://echoD/./lib/client.js","webpack://echoD/./lib/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echoD\"] = factory();\n\telse\n\t\troot[\"echoD\"] = factory();\n})(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : this, () => {\nreturn ","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var inProgress = {};\nvar dataWebpackPrefix = \"echoD:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","import { Options } from '../options.js';\nimport { extractSymbol } from '../symbols.js';\n/**\n * Creates a new instance of the ActorActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the ActorActions class.\n * @returns {any} - A new class that extends the provided Parent class and the ActorActions class.\n */\nexport const ActorActionsFactory = (Parent = Object) => class ActorActions extends Parent {\n    /**\n     * Handles input for a specific actor in the current context.\n     *\n     * @param {any[] | InputPayload} payload - The payload containing the actor's id and the input to be handled.\n     * @param {Context} context - The current context in which the actor input is to be handled.\n     * @param {Options | any} options - The options for handling the actor input. If an instance of Options is not provided, a new one will be created.\n     */\n    actorInput(payload, context, options) {\n        options = Options.ensure(options, this);\n        const { getActorId, compressStringsAsInts } = options;\n        let input;\n        let tick = 0;\n        if (Array.isArray(payload)) {\n            input = payload[0];\n            tick = payload[1] || 0;\n        }\n        else {\n            input = payload;\n        }\n        let id = getActorId(input?.id, context);\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        if (!input?.id) {\n            input.id = id;\n        }\n        context.actorInput(id, input, tick, options);\n    }\n    /**\n     * Retrieves actors from the current context and sends them to the responder.\n     *\n     * @param {any} payload - This parameter is not used in the function.\n     * @param {Context} context - The current context from which the actors are retrieved.\n     * @param {Options | any} options - The options for retrieving actors. If an instance of Options is not provided, a new one will be created.\n     */\n    actors(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, isAuthority, isAsyncStorage, pageSize, enableQuerying, enumDefaultSymbols } = options;\n        if (!isAuthority) {\n            return;\n        }\n        const sendActors = (pages) => {\n            // send pages to responder\n            for (const page of pages) {\n                responder([enumDefaultSymbols.mergeActors, page]);\n            }\n        };\n        const ctxActors = context.getActors(enableQuerying ? payload : null, pageSize);\n        if (isAsyncStorage) {\n            ctxActors.emitTo(sendActors, true);\n        }\n        else {\n            sendActors(ctxActors);\n        }\n    }\n    /**\n     * Merges actors into the current context.\n     *\n     * @param {any[]} payload - The payload containing the actors to be merged.\n     * @param {Context} context - The current context in which the actors are to be merged.\n     * @param {Options | any} options - The options for merging. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeActors(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        context.mergeActors(payload, options);\n    }\n    /**\n     * Removes an actor from the current context.\n     *\n     * @param {any} id - The identifier for the actor to be removed.\n     * @param {Context} context - The current context from which the actor is to be removed.\n     * @param {Options | any} options - The options for removing the actor. If an instance of Options is not provided, a new one will be created.\n     */\n    removeActor(id, context, options) {\n        options = options = Options.ensure(options, this);\n        const { skipPending, getActorId, compressStringsAsInts } = options;\n        id = getActorId(id, context);\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        context.removeActor(id, skipPending);\n    }\n    /**\n     * Spawns a new actor in the current context.\n     *\n     * @param {any} id - The identifier for the actor to be spawned.\n     * @param {Context} context - The current context in which the actor is to be spawned.\n     * @param {OptionsExtended | any} options - The options for spawning the actor. If an instance of Options is not provided, a new one will be created.\n     */\n    spawnActor(id, context, options) {\n        options = options = Options.ensure(options, this);\n        const { skipPending, getActorId, compressStringsAsInts } = options;\n        id = getActorId(id, context);\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        context.spawnActor(id, skipPending);\n    }\n};\n/**\n * Class representing actions that can be performed on actors.\n * This class encapsulates the logic for merging, spawning, removing, and handling input for actors.\n */\nexport class ActorActions extends ActorActionsFactory() {\n}\nconst __ActorActions__ = new ActorActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the ActorActions class.\n */\nexport const actions = {\n    /**\n     * Handles input for a specific actor in the current context.\n     */\n    actorInput: __ActorActions__.actorInput,\n    /**\n     * Retrieves actors from the current context.\n     */\n    actors: __ActorActions__.actors,\n    /**\n     * Merges actors into the current context.\n     */\n    mergeActors: __ActorActions__.mergeActors,\n    /**\n     * Removes an actor from the current context.\n     */\n    removeActor: __ActorActions__.removeActor,\n    /**\n     * Spawns a new actor in the current context.\n     */\n    spawnActor: __ActorActions__.spawnActor\n};\nexport default actions;\n","import { Options } from '../options.js';\nimport { extractSymbol, recursiveSymbolExtraction } from '../symbols.js';\n/**\n * Creates a new instance of the ComponentActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the ComponentActions class.\n * @returns {any} - A new class that extends the provided Parent class and the ComponentActions class.\n */\nexport const ComponentActionsFactory = (Parent = Object) => class ComponentActions extends Parent {\n    /**\n     * Changes a component in the current context.\n     *\n     * @param {any[]} payload - The payload containing the component's id, key, and the new value.\n     * @param {Context} context - The current context in which the component is to be changed.\n     * @param {Options | any} options - The options for changing the component. If an instance of Options is not provided, a new one will be created.\n     */\n    changeComponent(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { compressStringsAsInts, types, isOrdered } = options;\n        let [id, key, value] = payload;\n        let tick = isOrdered ? payload[3] : 0;\n        if (id === undefined || id === null || id === '' ||\n            key === undefined || key === null || key === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (!id) {\n                return;\n            }\n            key = extractSymbol(key, context, options);\n            if (!key) {\n                return;\n            }\n            const type = types[key];\n            if (type && (type === String || type[0] === String)) {\n                value = recursiveSymbolExtraction(key, value, context, options);\n                if (!value) {\n                    return;\n                }\n            }\n        }\n        return context.changeComponent(id, key, value, tick, options);\n    }\n    /**\n     * Retrieves components from the current context and sends them to the responder.\n     *\n     * @param {any} payload - The payload containing the request for components.\n     * @param {Context} context - The current context from which the components are retrieved.\n     * @param {Options | any} options - The options for retrieving components. If an instance of Options is not provided, a new one will be created.\n     */\n    components(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, isAuthority, isAsyncStorage, pageSize, enableQuerying, enumDefaultSymbols } = options;\n        if (!isAuthority) {\n            return;\n        }\n        const sendComponents = (pages) => {\n            // return responder([enumDefaultSymbols.mergeComponents, components])\n            // send pages to responder\n            for (const page of pages) {\n                responder([\n                    enumDefaultSymbols.mergeComponents,\n                    page\n                ]);\n            }\n        };\n        const ctxComponents = context.getComponents(enableQuerying ? payload : null, pageSize);\n        if (isAsyncStorage) {\n            ctxComponents.emitTo(sendComponents, true);\n        }\n        else {\n            sendComponents(ctxComponents);\n        }\n    }\n    /**\n     * Merges components into the current context.\n     *\n     * @param {any[]} payload - The payload containing the components to be merged.\n     * @param {Context} context - The current context in which the components are to be merged.\n     * @param {Options | any} options - The options for merging. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeComponents(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        context.mergeComponents(payload, options);\n    }\n    /**\n     * Removes a component from the current context.\n     *\n     * @param {any[]} payload - The payload containing the component's id and key to be removed.\n     * @param {Context} context - The current context from which the component is to be removed.\n     * @param {Options | any} options - The options for removing the component. If an instance of Options is not provided, a new one will be created.\n     */\n    removeComponent(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { compressStringsAsInts } = options;\n        let [id, key] = payload;\n        if (id === undefined || id === null || id === '' ||\n            key === undefined || key === null || key === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (!id) {\n                return;\n            }\n            key = extractSymbol(key, context, options);\n            if (!key) {\n                return;\n            }\n        }\n        context.removeComponent(id, key, options);\n    }\n    /**\n     * Inserts a new component or updates an existing one in the current context.\n     *\n     * @param {any[]} payload - The payload containing the component's id, key, and the new value.\n     * @param {Context} context - The current context in which the component is to be upserted.\n     * @param {OptionsExtended | any} options - The options for upserting the component. If an instance of Options is not provided, a new one will be created.\n     */\n    upsertComponent(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { compressStringsAsInts, types, isOrdered } = options;\n        let [id, key, value] = payload;\n        let tick = isOrdered ? payload[3] : 0;\n        if (id === undefined || id === null || id === '' ||\n            key === undefined || key === null || key === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (!id) {\n                return;\n            }\n            key = extractSymbol(key, context, options);\n            if (!key) {\n                return;\n            }\n            const type = types[key];\n            if (type && (type === String || type[0] === String)) {\n                value = recursiveSymbolExtraction(key, value, context, options);\n                if (!value) {\n                    return;\n                }\n            }\n        }\n        return context.upsertComponent(id, key, value, tick, options);\n    }\n};\n/**\n * Class representing actions that can be performed on components.\n * This class encapsulates the logic for merging, retrieving, and changing components.\n */\nexport class ComponentActions extends ComponentActionsFactory() {\n}\nconst __ComponentActions__ = new ComponentActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the ComponentActions class.\n */\nexport const actions = {\n    /**\n     * Changes a component in the current context.\n     */\n    changeComponent: __ComponentActions__.changeComponent,\n    /**\n     * Retrieves components from the current context.\n     */\n    components: __ComponentActions__.components,\n    /**\n     * Merges components into the current context.\n     */\n    mergeComponents: __ComponentActions__.mergeComponents,\n    /**\n     * Removes a component from the current context.\n     */\n    removeComponent: __ComponentActions__.removeComponent,\n    /**\n     * Updates an existing component or inserts a new one if it doesn't exist in the current context.\n     */\n    upsertComponent: __ComponentActions__.upsertComponent\n};\nexport default actions;\n","import { manyHandler } from '../handler.js';\nimport { Options } from '../options.js';\n/**\n * Creates a new instance of the CoreActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the CoreActions class.\n * @returns {any} - A new class that extends the provided Parent class and the CoreActions class.\n */\nexport const CoreActionsFactory = (Parent = Object) => class CoreActions extends Parent {\n    /**\n     * Processes a batch of payloads in the current context.\n     *\n     * @param {any[]} payload - The array of payloads to be processed.\n     * @param {Context} context - The current context in which the payloads are to be processed.\n     * @param {Options | any} options - The options for processing the payloads. If an instance of Options is not provided, a new one will be created.\n     */\n    batch(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        manyHandler(payload, context, options);\n    }\n};\n/**\n * The CoreActions class provides the core functionality for managing actions in your application.\n */\nexport class CoreActions extends CoreActionsFactory() {\n}\nconst __CoreActions__ = new CoreActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the CoreActions class.\n */\nexport const actions = {\n    /**\n     * Processes a batch of payloads in the current context.\n     */\n    batch: __CoreActions__.batch\n};\nexport default actions;\n","import { Options } from '../options.js';\nimport { extractSymbol } from '../symbols.js';\n/**\n * Creates a new instance of the EntityActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the EntityActions class.\n * @returns {any} - A new class that extends the provided Parent class and the EntityActions class.\n */\nexport const EntityActionsFactory = (Parent = Object) => class EntityActions extends Parent {\n    /**\n     * Creates a new entity in the current context.\n     *\n     * @param {any} id - The identifier for the entity to be created.\n     * @param {Context} context - The current context in which the entity is to be created.\n     * @param {Options | any} options - The options for creating the entity. If an instance of Options is not provided, a new one will be created.\n     */\n    createEntity(id, context, options) {\n        options = options = Options.ensure(options, this);\n        const { skipPending, compressStringsAsInts } = options;\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        context.createEntity(id, skipPending);\n    }\n    /**\n     * Retrieves entities from the current context.\n     *\n     * @param {any} payload - This parameter is not used in the method.\n     * @param {Context} context - The current context from which the entities are retrieved.\n     * @param {OptionsExtended | any} options - The options for retrieving entities. If an instance of Options is not provided, a new one will be created.\n     */\n    entities(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, isAuthority, isAsyncStorage, pageSize, enableQuerying, enumDefaultSymbols } = options;\n        if (!isAuthority) {\n            return;\n        }\n        const sendEntities = (pages) => {\n            for (const page of pages) {\n                responder([enumDefaultSymbols.mergeEntities, page]);\n            }\n        };\n        const ctxEntities = context.getEntities(enableQuerying ? payload : null, pageSize);\n        if (isAsyncStorage) {\n            ctxEntities.emitTo(sendEntities, true);\n        }\n        else {\n            sendEntities(ctxEntities);\n        }\n    }\n    /**\n     * Merges entities into the current context.\n     *\n     * @param {any[]} payload - The payload containing the entities to be merged.\n     * @param {Context} context - The current context in which the entities are to be merged.\n     * @param {OptionsExtended | any} options - The options for merging. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeEntities(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        context.mergeEntities(payload, options);\n    }\n    /**\n     * Removes an entity from the current context.\n     *\n     * @param {any} id - The identifier for the entity to be removed.\n     * @param {Context} context - The current context from which the entity is to be removed.\n     * @param {OptionsExtended | any} options - The options for removing the entity. If an instance of Options is not provided, a new one will be created.\n     */\n    removeEntity(id, context, options) {\n        options = options = Options.ensure(options, this);\n        const { skipPending, compressStringsAsInts } = options;\n        if (id === undefined || id === null || id === '') {\n            return;\n        }\n        if (compressStringsAsInts) {\n            id = extractSymbol(id, context, options);\n            if (id === '') {\n                return;\n            }\n        }\n        context.removeEntity(id, skipPending);\n    }\n};\n/**\n * Class representing actions that can be performed on entities.\n * This class encapsulates the logic for creating, merging, and removing entities.\n */\nexport class EntityActions extends EntityActionsFactory() {\n}\nconst __EntityActions__ = new EntityActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the EntityActions class.\n */\nexport const actions = {\n    /**\n     * Creates a new entity in the current context.\n     */\n    createEntity: __EntityActions__.createEntity,\n    /**\n     * Retrieves entities from the current context.\n     */\n    entities: __EntityActions__.entities,\n    /**\n     * Merges entities into the current context.\n     */\n    mergeEntities: __EntityActions__.mergeEntities,\n    /**\n     * Removes an entity from the current context.\n     */\n    removeEntity: __EntityActions__.removeEntity\n};\nexport default actions;\n","import { Options } from '../options.js';\nimport { paginate } from '../utils.js';\n/**\n * Creates a new instance of the SymbolActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the SymbolActions class.\n * @returns {any} - A new class that extends the provided Parent class and the SymbolActions class.\n */\nexport const SymbolActionsFactory = (Parent = Object) => class SymbolActions extends Parent {\n    /**\n     * Adds a symbol to the current context.\n     *\n     * @param {any} symbol - The symbol to be added.\n     * @param {Context} context - The current context to which the symbol is to be added.\n     * @param {Options | any} options - The options for adding the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    addSymbol(symbol, context, options) {\n        options = options = Options.ensure(options, this);\n        return context.addSymbol(symbol, options);\n    }\n    /**\n     * Fetches a symbol for the current context.\n     *\n     * @param {string | number} payload - The payload containing the symbol to be fetched.\n     * @param {Context} context - The current context from which the symbol is to be fetched.\n     * @param {Options | any} options - The options for fetching the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    fetchSymbol(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, enumDefaultSymbols } = options;\n        return context.fetchSymbol(payload, options, (symbolTuple) => {\n            responder([enumDefaultSymbols.mergeSymbol, symbolTuple]);\n        });\n    }\n    /**\n     * Retrieves a symbol from the current context by its index.\n     *\n     * @param {number} index - The index of the symbol to be retrieved.\n     * @param {Context} context - The current context from which the symbol is to be retrieved.\n     * @param {Options | any} options - The options for retrieving the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    getSymbol(index, context, options) {\n        options = options = Options.ensure(options, this);\n        return context.getSymbol(index, options);\n    }\n    /**\n     * Merges a symbol into the current context.\n     *\n     * @param {[string, number]} payload - The payload containing the symbol to be merged.\n     * @param {Context} context - The current context into which the symbol is to be merged.\n     * @param {Options | any} options - The options for merging the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeSymbol(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        context.mergeSymbol(payload, options);\n    }\n    /**\n     * Merges multiple symbols into the current context.\n     *\n     * @param {any[]} payload - The payload containing the symbols to be merged.\n     * @param {Context} context - The current context into which the symbols are to be merged.\n     * @param {Options | any} options - The options for merging the symbols. If an instance of Options is not provided, a new one will be created.\n     */\n    mergeSymbols(payload, context, options) {\n        options = options = Options.ensure(options, this);\n        const [offset, symbols] = payload;\n        if (payload && payload.length) {\n            context.resetSymbols(offset, symbols, options);\n        }\n    }\n    /**\n     * Retrieves a symbol from the current context.\n     *\n     * @param {any} symbol - The symbol to be retrieved.\n     * @param {Context} context - The current context from which the symbol is to be retrieved.\n     * @param {Options | any} options - The options for retrieving the symbol. If an instance of Options is not provided, a new one will be created.\n     */\n    symbol(symbol, context, options) {\n        options = options = Options.ensure(options, this);\n        const { actions, responder, isAuthority, enumDefaultSymbols, compressStringsAsInts } = options;\n        if (!isAuthority || !compressStringsAsInts) {\n            return;\n        }\n        const enumSymbols = context.symbolsEnum ?? {};\n        let index = Object.prototype.hasOwnProperty.call(enumSymbols, symbol) ? enumSymbols[symbol] : -1;\n        if (index === -1) {\n            index = actions.addSymbol(symbol, context, options);\n        }\n        if (index !== -1) {\n            responder([enumDefaultSymbols.mergeSymbol, [symbol, index]]);\n        }\n    }\n    /**\n     * Retrieves all symbols from the current context.\n     *\n     * @param {any} _ - This parameter is not used.\n     * @param {Context} context - The current context from which the symbols are to be retrieved.\n     * @param {Options | any} options - The options for retrieving the symbols. If an instance of Options is not provided, a new one will be created.\n     */\n    symbols(_, context, options) {\n        options = options = Options.ensure(options, this);\n        const { responder, isAuthority, pageSize, enumDefaultSymbols, compressStringsAsInts } = options;\n        if (!isAuthority || !compressStringsAsInts) {\n            return;\n        }\n        const symbols = context.symbolsList;\n        if (symbols && symbols.length) {\n            // responder([enumDefaultSymbols.mergeSymbols, 0, symbols])\n            const pages = paginate(symbols, pageSize);\n            let i = 0;\n            // send pages to responder\n            for (const page of pages) {\n                responder([enumDefaultSymbols.mergeSymbols, i, page]);\n                i += pageSize;\n            }\n        }\n    }\n};\n/**\n * The SymbolActions class provides methods for managing symbols in a context.\n */\nexport class SymbolActions extends SymbolActionsFactory() {\n}\nconst __SymbolActions__ = new SymbolActions();\n/**\n * An object that maps the names of actions to their corresponding methods in the SymbolActions class.\n */\nexport const actions = {\n    /**\n     * Adds a symbol to the current context.\n     */\n    addSymbol: __SymbolActions__.addSymbol,\n    /**\n     * Fetches a symbol from the current context.\n     */\n    fetchSymbol: __SymbolActions__.fetchSymbol,\n    /**\n     * Retrieves a symbol from the current context by its index.\n     */\n    getSymbol: __SymbolActions__.getSymbol,\n    /**\n     * Merges a symbol into the current context.\n     */\n    mergeSymbol: __SymbolActions__.mergeSymbol,\n    /**\n     * Merges multiple symbols into the current context.\n     */\n    mergeSymbols: __SymbolActions__.mergeSymbols,\n    /**\n     * Retrieves a symbol from the current context.\n     */\n    symbol: __SymbolActions__.symbol,\n    /**\n     * Retrieves all symbols from the current context.\n     */\n    symbols: __SymbolActions__.symbols\n};\nexport default actions;\n","import { typeOf } from './utils.js';\n/**\n * The Changes class provides methods for managing changes in a context.\n *\n * @property {Context} context - The context in which changes are to be managed.\n * @property {Record<string, any>} diffs - The diffs of the changes.\n */\nexport class Changes {\n    context;\n    diffs;\n    /**\n     * Creates a new instance of the Changes class.\n     *\n     * @param {Context} context - The context in which changes are to be managed.\n     * @param {ChangesInput} changes - An optional initial set of changes.\n     */\n    constructor(context, changes) {\n        this.context = context;\n        this.diffs = changes?.diffs || {};\n    }\n    /**\n     * Changes a component in the current context.\n     *\n     * @param {string} id - The ID of the component to be changed.\n     * @param {string} key - The key of the property to be changed.\n     * @param {any} newValue - The new value of the property.\n     * @param {any} prevValue - The previous value of the property.\n     * @param {boolean} isAsyncStorage - Whether the storage is asynchronous.\n     * @returns {Promise<any[]>} The new value.\n     */\n    changeComponent(id, key, newValue, prevValue, isAsyncStorage = false) {\n        return this.upsertComponent(id, key, newValue, prevValue, isAsyncStorage);\n    }\n    /**\n     * Retrieves the changes of a value.\n     *\n     * @param {string} id - The ID of the component.\n     * @param {string} key - The key of the property.\n     * @param {any} storedValue - The stored value.\n     * @returns {Record<string, any>} The diffs.\n     */\n    getValue(id, key, storedValue) {\n        const diffedValue = this.diffs[id]?.[key];\n        if (diffedValue === undefined || diffedValue === null) {\n            return storedValue;\n        }\n        return diffedValue;\n    }\n    /**\n     * Resets the changes to a new set of changes or an empty object if no changes are provided.\n     *\n     * @param {ChangesInput} changes - The new set of changes.\n     * @returns {Changes} The instance of the Changes class.\n     */\n    reset(changes) {\n        this.diffs = changes?.diffs || {};\n        return this;\n    }\n    /**\n     * Updates an existing component or inserts a new one if it doesn't exist in the current context.\n     *\n     * @param {string} id - The ID of the component to be updated or inserted.\n     * @param {string} key - The key of the property to be updated or inserted.\n     * @param {any} newValue - The new value of the property.\n     * @param {any} _prevValue - The previous value of the property.\n     * @param {boolean} isAsyncStorage - Whether the storage is asynchronous.\n     * @returns {Promise<any[]>} The new value.\n     */\n    upsertComponent(id, key, newValue, _prevValue, isAsyncStorage = false) {\n        this.diffs[id] = this.diffs[id] || {};\n        const currentScopeOrPromise = this.context.store.findComponents(id);\n        const promises = [];\n        const completeUpsertComponent = (currentScope) => {\n            if (currentScope === undefined || currentScope === null) {\n                this.diffs[id][key] = newValue;\n                const promise = this.context.store.storeComponent(id, key, newValue);\n                if (isAsyncStorage && promise instanceof Promise) {\n                    promises.push(promise);\n                }\n                return newValue;\n            }\n            let diffObject = this.diffs[id];\n            const recursiveDiff = (key, diff, scope, currVal) => {\n                let nextVal = currVal;\n                if (!scope) {\n                    return [diff, nextVal];\n                }\n                const prevType = typeOf(scope[key]);\n                const nextType = typeOf(nextVal);\n                if (prevType !== nextType) {\n                    diff[key] = nextVal;\n                    diff = diff[key];\n                    return [diff, nextVal];\n                }\n                switch (nextType) {\n                    case 'bigint':\n                    case 'number': {\n                        const v1 = scope[key];\n                        const v2 = nextVal;\n                        const d = v2 - v1;\n                        // scope[key] = v2\n                        diff[key] = d;\n                        break;\n                    }\n                    case 'array':\n                        diff = diff[key];\n                        scope = scope[key];\n                        for (let i = 0; i < nextVal.length; i += 1) {\n                            // if (nextVal[i] === undefined || nextVal[i] === null) {\n                            //   nextVal[i] = []\n                            // }\n                            recursiveDiff(i.toString(), diff, scope, nextVal[i]);\n                        }\n                        break;\n                    case 'object':\n                        diff = diff[key];\n                        scope = scope[key];\n                        for (const k in nextVal) {\n                            // if (nextVal[k] === undefined || nextVal[k] === null) {\n                            //   nextVal[k] = {}\n                            // }\n                            recursiveDiff(k, diff, scope, nextVal[k]);\n                        }\n                        break;\n                    case 'string':\n                    // TODO: append with deletes?\n                    case 'boolean':\n                    default:\n                        diff[key] = nextVal;\n                }\n                diff = diff[key];\n                nextVal = nextVal[key];\n                return [diff, currVal];\n            };\n            [diffObject, newValue] = recursiveDiff(key, diffObject, currentScope, newValue);\n            const promise = this.context.store.storeComponent(id, key, newValue);\n            if (isAsyncStorage && promise instanceof Promise) {\n                promises.push(promise);\n            }\n            return newValue;\n        };\n        if (isAsyncStorage && currentScopeOrPromise instanceof Promise) {\n            return new Promise((resolve, reject) => {\n                currentScopeOrPromise.then((currentScope) => {\n                    completeUpsertComponent(currentScope);\n                    if (promises.length === 0) {\n                        return Promise.all(promises).then(() => resolve(newValue), reject);\n                    }\n                    return resolve(newValue);\n                });\n            });\n        }\n        return completeUpsertComponent(currentScopeOrPromise);\n    }\n}\nexport default Changes;\n","import { unionSetOrArray, createEnum } from './utils.js';\n/**\n * An array of action names.\n */\nexport const Actions = [\n    'actorInput',\n    'actors',\n    'addSymbol',\n    'batch',\n    'changeComponent',\n    'components',\n    'createEntity',\n    'entities',\n    'fetchSymbol',\n    'getSymbol',\n    'mergeActors',\n    'mergeComponents',\n    'mergeEntities',\n    'mergeSymbols',\n    'mergeSymbol',\n    'removeActor',\n    'removeComponent',\n    'removeEntity',\n    'spawnActor',\n    'symbol',\n    'symbols',\n    // 'tick',\n    // 'tock',\n    'upsertComponent'\n];\n/**\n * An array of common component names.\n */\nexport const CommonComponents = [\n    'asset',\n    'collider',\n    'color',\n    'hidden',\n    'position',\n    'rotation',\n    'velocity',\n    'spin'\n];\n/**\n * A set of default symbols, which is the union of Actions and CommonComponents.\n */\nexport const DefaultSymbols = unionSetOrArray(Actions, CommonComponents);\n/**\n * Padding for the enum.\n */\nexport const padEnum = 0; // 10;\n/**\n * An enum of action names.\n */\nexport const enumActions = createEnum(Actions, padEnum);\n/**\n * An enum of common component names.\n */\nexport const enumCommonComponents = createEnum(CommonComponents, Actions.length + padEnum);\n/**\n * An enum of default symbols.\n */\nexport const enumDefaultSymbols = createEnum(DefaultSymbols, padEnum);\n/**\n * An object that maps action names to their payload sizes.\n */\nexport const batchActionPayloadSizes = {\n    actorInput: { default: 1, rollback: 2 },\n    changeComponent: { default: 3, ordered: 4 },\n    mergeSymbols: 2,\n    removeComponent: 2,\n    upsertComponent: { default: 3, ordered: 4 }\n};\n/**\n * Default options for the application.\n */\nexport const defaultOptions = {\n    compressStringsAsInts: true,\n    enableRollback: !true,\n    enableQuerying: !true,\n    isAuthority: true,\n    isAsyncStorage: false,\n    isComponentRelay: true,\n    isDiffed: false,\n    isGroupedComponents: !true,\n    isOrdered: !true,\n    isReadOnly: false,\n    isSymbolLeader: false,\n    isSymbolRelay: false,\n    pageSize: 100,\n    skipPending: false,\n    indexes: {\n        // asset: { type: 'sorted' },\n        // collider: { type: 'sorted' },\n        // color: { type: 'sorted' },\n        // hidden: { type: 'sorted' },\n        position: { type: 'spatial' },\n    },\n    types: {\n        asset: 'str',\n        collider: 'str',\n        color: ['ui8', 4],\n        hidden: 'bool',\n        position: ['f32', 3],\n        rotation: ['f32', 3],\n        velocity: ['f32', 3],\n        spin: ['f32', 3],\n        size: ['f32', 3],\n    }\n};\n/**\n * Default options for updates.\n */\nexport const defaultUpdateOptions = {\n    mask: {\n        actors: true,\n        entities: true,\n        components: true,\n        inputs: true,\n        symbols: true\n    } && null,\n    type: true,\n    batched: true,\n    batchSize: 100\n};\n/**\n * An object that maps keys to their validity.\n */\nexport const defaultValidKeys = {\n    asset: true,\n    collider: true,\n    color: true,\n    hidden: true,\n    position: true,\n    rotation: true,\n    velocity: true,\n    spin: true,\n    size: true,\n};\n/**\n * A responder function that does nothing and returns nothing.\n */\nexport function voidResponder() { }\n/**\n * A function that retrieves the actor ID from a payload.\n *\n * @param {string} id - The payload from which the actor ID is to be retrieved.\n * @param {any} _context - The current context. This parameter is not used.\n * @returns {string | undefined} The actor ID, or undefined if it cannot be found.\n */\nexport function defaultGetActorId(id, _context) {\n    return id;\n}\n/**\n * A function that retrieves the grouped value from a payload.\n *\n * @param {any | any[]} value - The payload from which the grouped value is to be retrieved.\n * @param {number} i - The index of the payload.\n * @param {Object} types - An object containing the types.\n * @param {string} key - The key of the grouped value.\n * @returns {any} The value from the group.\n */\nexport function defaultGetGroupedValue(value, i, types, key) {\n    const type = types[key];\n    if (Array.isArray(type)) {\n        return value.slice(i * type[1], (i + 1) * type[1]);\n    }\n    return value[i];\n}\n/**\n * A function that sets the grouped value in a payload.\n *\n * @param {any} value - The payload in which the grouped value is to be set.\n * @param {Object} _types - An object containing the types.\n * @param {string} _key - The key of the grouped value.\n * @returns {any} The value from the group.\n */\nexport function defaultSetGroupedValue(value, _types, _key) {\n    return value;\n}\n","import { Changes } from './changes.js';\nimport { Emitter } from './emitter.js';\nimport { Options } from './options.js';\nimport { Ordered } from './ordered.js';\nimport { Pending } from './pending.js';\nimport { Symbols } from './symbols.js';\nimport { Storage } from './storage.js';\n// import { StorageInterface } from './storage/interface'\nimport { combineValues, now } from './utils.js';\nimport { allActions } from './node.js';\n/**\n * The Context class provides methods for managing the context.\n*\n* @property {any} events - The events.\n* @property {StorageInterface} store - The store.\n* @property {Ordered | null} order - The order.\n* @property {Changes | null} changes - The changes.\n* @property {Pending | null} pending - The pending.\n*/\nexport class Context {\n    /**\n     * Ensures that the given context is an instance of the Context class.\n     *\n     * @param {Context | ContextProps} context - The context to ensure.\n     * @param {Options | any} options - The options for ensuring the context.\n     * @param {Storage} _Storage - The store.\n     * @returns {Context} The context.\n     */\n    static ensure(context, options, _Storage = Storage) {\n        if (context instanceof Context) {\n            return context;\n        }\n        return new Context(context, options, _Storage);\n    }\n    /**\n     * Creates a new instance of the Context class.\n     *\n     * @param {Context | ContextProps} context - The context properties.\n     * @param {Options | any} options - The context options.\n     * @param {Storage} _Storage - The store.\n     */\n    constructor(context = {}, options, _Storage = Storage) {\n        const { events = null, store = null, order = null, changes = null, symbols = null, pending = null,\n        // ...otherProps\n         } = context;\n        options = Options.ensure(options, options?.actions || allActions);\n        const { isOrdered, isDiffed, isReadOnly, compressStringsAsInts, enableQuerying, enumDefaultSymbols, storeOptions, indexes, types, } = options;\n        if (isOrdered) {\n            this.order = new Ordered(order);\n        }\n        else {\n            this.order = null;\n        }\n        if (isDiffed) {\n            this.changes = new Changes(this, changes);\n        }\n        else {\n            this.changes = null;\n        }\n        if (compressStringsAsInts) {\n            if (symbols) {\n                this.symbols = new Symbols(symbols);\n            }\n            else {\n                this.symbols = new Symbols();\n                this.symbols.copyEnum(enumDefaultSymbols);\n            }\n        }\n        else {\n            this.symbols = null;\n        }\n        if (isReadOnly) {\n            this.pending = null;\n        }\n        else {\n            this.pending = pending || new Pending(isDiffed);\n        }\n        this.events = events;\n        this.store = store || new _Storage(undefined, {\n            ...(storeOptions || {}),\n            types,\n            indexes: enableQuerying ? indexes : null,\n        });\n        // Object.assign(this, otherProps)\n    }\n    /**\n     * Gets the actors from the store.\n     *\n     * @returns The actors from the store.\n     */\n    get actors() {\n        const actors = this.getActors(null, Infinity);\n        if (actors instanceof Emitter) {\n            return actors;\n        }\n        return actors[0];\n    }\n    /**\n     * Gets the actors from the store with the given query.\n     *\n     * @param {any} query - The query for getting the actors.\n     * @param {number} pageSize - The page size for getting the actors.\n     * @returns {Emitter<string[][]> | string[][]} The actors from the store.\n     */\n    getActors(query, pageSize) {\n        return this.store.getActors(query, pageSize);\n    }\n    /**\n     * Spawns an actor with the given id and options.\n     *\n     * @param {string} id - The id of the actor to spawn.\n     * @param {Options} options - The options for spawning the actor.\n     */\n    spawnActor(id, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const addedOrPromise = this.store.storeActor(id);\n        const completeActorInput = (added) => {\n            if (!added) {\n                return;\n            }\n            if (!skipPending && this.pending) {\n                this.pending.spawnActor(id);\n            }\n            if (this.events) {\n                this.events.emit('spawnActor', id);\n            }\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && addedOrPromise instanceof Promise) {\n            addedOrPromise.then(completeActorInput);\n            return addedOrPromise;\n        }\n        completeActorInput(addedOrPromise);\n        return addedOrPromise;\n    }\n    /**\n     * Removes an actor with the given id and options.\n     *\n     * @param {string} id - The id of the actor to remove.\n     * @param {Options} options - The options for removing the actor.\n     */\n    removeActor(id, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const removedOrPromise = this.store.destroyActor(id);\n        const completeRemoveActor = (removed) => {\n            if (removed) {\n                if (!skipPending && this.pending) {\n                    this.pending.removeActor(id);\n                }\n                if (this.events) {\n                    this.events.emit('removeActor', id);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n        };\n        if (isAsyncStorage && removedOrPromise instanceof Promise) {\n            removedOrPromise.then(completeRemoveActor);\n            return removedOrPromise;\n        }\n        completeRemoveActor(removedOrPromise);\n        return removedOrPromise;\n    }\n    /**\n     * Merges actors with the given payload and options.\n     *\n     * @param {any[]} payload - The payload of the actors to merge.\n     * @param {Options} options - The options for merging the actors.\n     */\n    mergeActors(payload, options) {\n        const { actions, isAsyncStorage, onUpdate } = options;\n        const nextOptions = options.extend({\n            onUpdate: null\n        });\n        const promises = [];\n        for (const id of payload) {\n            const promise = actions.spawnActor(id, this, nextOptions);\n            if (isAsyncStorage && promise instanceof Promise) {\n                promises.push(promise);\n            }\n        }\n        const completeMergeActors = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && promises.length > 0) {\n            const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n            all.then(completeMergeActors);\n            return all;\n        }\n        completeMergeActors();\n    }\n    /**\n     * Gets the entities from the store.\n     *\n     * @returns The entities from the store.\n     */\n    get entities() {\n        const entities = this.getEntities(null, Infinity);\n        if (entities instanceof Emitter) {\n            return entities;\n        }\n        return entities[0];\n    }\n    /**\n     * Gets the entities from the store with the given query.\n     *\n     * @param {any} query - The query for getting the entities.\n     * @param {number} pageSize - The page size for getting the entities.\n     * @returns {Emitter<string[][]> | string[][]} The entities from the store.\n     */\n    getEntities(query, pageSize) {\n        return this.store.getEntities(query, pageSize);\n    }\n    /**\n     * Creates an entity with the given id and options.\n     *\n     * @param {string} id - The id of the entity to create.\n     * @param {Options} options - The options for creating the entity.\n     */\n    createEntity(id, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const added = this.store.storeEntity(id);\n        const completeCreateEntity = (added) => {\n            if (added) {\n                if (!skipPending && this.pending) {\n                    this.pending.createEntity(id);\n                }\n                if (this.events) {\n                    this.events.emit('createEntity', id);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n        };\n        if (isAsyncStorage && added instanceof Promise) {\n            added.then(completeCreateEntity);\n            return added;\n        }\n        completeCreateEntity(added);\n        return added;\n    }\n    /**\n     * Removes an entity with the given id and options.\n     *\n     * @param {string} id - The id of the entity to remove.\n     * @param {Options} options - The options for removing the entity.\n     */\n    removeEntity(id, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const removed = this.store.destroyEntity(id);\n        const completeRemoveEntity = (removed) => {\n            if (removed) {\n                if (!skipPending && this.pending) {\n                    this.pending.removeEntity(id);\n                }\n                if (this.events) {\n                    this.events.emit('removeEntity', id);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n        };\n        if (isAsyncStorage && removed instanceof Promise) {\n            removed.then(completeRemoveEntity);\n            return removed;\n        }\n        completeRemoveEntity(removed);\n        return removed;\n    }\n    /**\n     * Merges entities with the given payload and options.\n     *\n     * @param {string[]} payload - The payload of the entities to merge.\n     * @param {Options} options - The options for merging the entities.\n     */\n    mergeEntities(payload, options) {\n        const { actions, isAsyncStorage, onUpdate } = options;\n        const nextOptions = options.extend({\n            onUpdate: null\n        });\n        const promises = [];\n        for (const id of payload) {\n            const promise = actions.createEntity(id, this, nextOptions);\n            if (isAsyncStorage && promise instanceof Promise) {\n                promises.push(promise);\n            }\n        }\n        const completeMergeEntities = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && promises.length > 0) {\n            const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n            all.then(completeMergeEntities);\n            return all;\n        }\n        completeMergeEntities();\n    }\n    /**\n     * Gets the components from the store.\n     *\n     * @returns The components from the store.\n     */\n    get components() {\n        const components = this.getComponents(null, Infinity);\n        if (components instanceof Emitter) {\n            return components;\n        }\n        return components[0];\n    }\n    /**\n     * Gets the components from the store with the given query.\n     *\n     * @param {any} query - The query for getting the components.\n     * @param {number} pageSize - The page size for getting the components.\n     * @returns {Emitter<Components[]> | Components[]} The components from the store.\n     */\n    getComponents(query, pageSize) {\n        return this.store.getComponents(query, pageSize);\n    }\n    /**\n     * Changes a component with the given id, key, value, and options.\n     *\n     * @param {string | string[] | Uint32Array} id - The id of the component to change.\n     * @param {string} key - The key of the component to change.\n     * @param {any | any[]} value - The value to change in the component.\n     * @param {number} tick - The tick value for the component. Defaults to 0.\n     * @param {Options} options - The options for changing the component.\n     */\n    changeComponent(id, key, value, tick = 0, options) {\n        const { actions, skipPending, isAsyncStorage, isGroupedComponents, getGroupedValue, types, onUpdate } = options;\n        const completeChangeComponentUpdate = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (Array.isArray(id) || id instanceof Uint32Array) {\n            if (!isGroupedComponents) {\n                throw new Error('Cannot change grouped components without isGroupedComponents option');\n            }\n            const noUpdateOptions = options.extend({ onUpdate: null });\n            const promises = [];\n            for (let i = 0; i < id.length; i++) {\n                const val = getGroupedValue(value, i, types, key);\n                const promise = actions.changeComponent([id[i], key, val, tick], this, noUpdateOptions);\n                if (isAsyncStorage && promise instanceof Promise) {\n                    promises.push(promise);\n                }\n            }\n            if (isAsyncStorage && promises.length > 0) {\n                const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n                all.then(completeChangeComponentUpdate);\n                return all;\n            }\n            completeChangeComponentUpdate();\n            return;\n        }\n        const currentValueOrPromise = this.store.findComponent(id, key);\n        const completeChangeComponents = (currentValue) => {\n            const pendingType = typeof currentValue === 'undefined' ? 'created' : 'updated';\n            if (this.order) {\n                const isValidOrder = this.order.changeComponent(id, key, tick);\n                if (!isValidOrder && !this.changes) {\n                    return;\n                }\n            }\n            let nextValue;\n            if (pendingType === 'created') {\n                nextValue = value;\n            }\n            else {\n                // nextValue = value\n                [/* combined */ , nextValue] = combineValues(currentValue, value);\n            }\n            let promise = null;\n            if (this.changes) {\n                promise = this.changes.changeComponent(id, key, nextValue, value, isAsyncStorage);\n            }\n            else {\n                promise = this.store.storeComponent(id, key, nextValue);\n            }\n            const completeChangeComponentStorage = () => {\n                if (!skipPending && this.pending) {\n                    this.pending.changeComponent(pendingType, id, key);\n                }\n                if (this.events) {\n                    this.events.emit('changeComponent', id, key);\n                }\n                completeChangeComponentUpdate();\n            };\n            if (isAsyncStorage && promise instanceof Promise) {\n                promise.then(completeChangeComponentStorage);\n                return promise;\n            }\n            completeChangeComponentStorage();\n        };\n        if (isAsyncStorage && currentValueOrPromise instanceof Promise) {\n            currentValueOrPromise.then(completeChangeComponents);\n            return currentValueOrPromise;\n        }\n        completeChangeComponents(currentValueOrPromise);\n        return currentValueOrPromise;\n    }\n    /**\n     * Upserts a component with the given id, key, value, and options.\n     *\n     * @param {string | string[] | Uint32Array} id - The id of the component to upsert.\n     * @param {string} key - The key of the component to upsert.\n     * @param {any | any[]} value - The value to upsert in the component.\n     * @param {number} tick - The tick value for the component. Defaults to 0.\n     * @param {Options} options - The options for upserting the component.\n     */\n    upsertComponent(id, key, value, tick = 0, options) {\n        const { actions, skipPending, isAsyncStorage, isGroupedComponents, getGroupedValue, types, onUpdate } = options;\n        const completeUpsertComponentUpdate = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (Array.isArray(id) || id instanceof Uint32Array) {\n            if (!isGroupedComponents) {\n                throw new Error('Cannot upsert grouped components without isGroupedComponents option');\n            }\n            const noUpdateOptions = options.extend({ onUpdate: null });\n            const promises = [];\n            for (let i = 0; i < id.length; i++) {\n                const val = getGroupedValue(value, i, types, key);\n                const promise = actions.upsertComponent([id[i], key, val, tick], this, noUpdateOptions);\n                if (isAsyncStorage && promise instanceof Promise) {\n                    promises.push(promise);\n                }\n            }\n            if (isAsyncStorage && promises.length > 0) {\n                const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n                all.then(completeUpsertComponentUpdate);\n                return all;\n            }\n            completeUpsertComponentUpdate();\n            return;\n        }\n        const currentValueOrPromise = this.store.findComponent(id, key);\n        const completeUpsertComponent = (currentValue) => {\n            if (currentValue !== value) {\n                if (this.order) {\n                    const isValidOrder = this.order.upsertComponent(id, key, tick);\n                    if (!isValidOrder && !this.changes) {\n                        return;\n                    }\n                }\n                let promise = null;\n                if (this.changes) {\n                    promise = this.changes.upsertComponent(id, key, value, currentValue, isAsyncStorage);\n                }\n                else {\n                    promise = this.store.storeComponent(id, key, value);\n                }\n                const completeUpsertComponentStorage = () => {\n                    if (!skipPending && this.pending) {\n                        const pendingType = typeof currentValue === 'undefined' ? 'created' : 'updated';\n                        this.pending.upsertComponent(pendingType, id, key);\n                    }\n                    if (this.events) {\n                        this.events.emit('upsertComponent', id, key);\n                    }\n                    completeUpsertComponentUpdate();\n                };\n                if (isAsyncStorage && promise instanceof Promise) {\n                    promise.then(completeUpsertComponentStorage);\n                    return promise;\n                }\n                completeUpsertComponentStorage();\n            }\n        };\n        if (isAsyncStorage && currentValueOrPromise instanceof Promise) {\n            currentValueOrPromise.then(completeUpsertComponent);\n            return currentValueOrPromise;\n        }\n        completeUpsertComponent(currentValueOrPromise);\n        return currentValueOrPromise;\n    }\n    /**\n     * Removes a component with the given id, key, and options.\n     *\n     * @param {string} id - The id of the component to remove.\n     * @param {string} key - The key of the component to remove.\n     * @param {Options} options - The options for removing the component.\n     */\n    removeComponent(id, key, options) {\n        const { skipPending, isAsyncStorage, onUpdate } = options;\n        const currentValueOrPromise = this.store.findComponent(id, key);\n        const completeRemoveComponent = (currentValue) => {\n            if (currentValue !== undefined || currentValue !== null) {\n                this.store.destroyComponent(id, key);\n                if (!skipPending && this.pending) {\n                    this.pending.removeComponent(id, key);\n                }\n                if (this.events) {\n                    this.events.emit('removeComponent', id, key);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n                return true;\n            }\n            return false;\n        };\n        if (isAsyncStorage && currentValueOrPromise instanceof Promise) {\n            return new Promise((resolve, reject) => {\n                currentValueOrPromise.then((currentValue) => {\n                    resolve(completeRemoveComponent(currentValue));\n                }, reject);\n            });\n        }\n        return completeRemoveComponent(currentValueOrPromise);\n    }\n    /**\n     * Merges components with the given payload and options.\n     *\n     * @param {any} payload - The payload of the components to merge.\n     * @param {Options} options - The options for merging the components.\n     */\n    mergeComponents(payload, options) {\n        const { actions, isAsyncStorage, isComponentRelay, onUpdate } = options;\n        const nextOptions = options.extend({\n            skipPending: !isComponentRelay,\n            onUpdate: null\n        });\n        const promises = [];\n        for (const id in (payload ?? {})) {\n            for (const key in payload[id]) {\n                const value = payload[id][key];\n                const nextPayload = [id, key, value];\n                const promise = actions.upsertComponent(nextPayload, this, nextOptions);\n                if ( /* isAsyncStorage && */promise instanceof Promise) {\n                    promises.push(promise);\n                }\n            }\n        }\n        const completeMergeComponents = () => {\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && promises.length > 0) {\n            const all = promises.length ? Promise.all(promises) : Promise.resolve([]);\n            all.then(completeMergeComponents);\n            return all;\n        }\n        completeMergeComponents();\n    }\n    /**\n     * Gets the inputs from the store.\n     *\n     * @returns The inputs from the store.\n     */\n    get inputs() {\n        const inputs = this.getInputs(null, Infinity);\n        if (inputs instanceof Emitter) {\n            return inputs;\n        }\n        return inputs[0];\n    }\n    /**\n     * Gets the inputs from the store with the given query.\n     *\n     * @param {any} query - The query for getting the inputs.\n     * @param {number} pageSize - The page size for getting the inputs.\n     * @returns {Emitter<Inputs[]> | Inputs[]} The inputs from the store.\n     */\n    getInputs(query, pageSize) {\n        return this.store.getInputs(query, pageSize);\n    }\n    /**\n     * Handles actor input with the given id, payload, and options.\n     *\n     * @param {string} id - The id of the actor.\n     * @param {InputPayload} input - The payload for the actor input.\n     * @param {number} tick - The tick value for the actor input. Defaults to 0.\n     * @param {Options} options - The options for handling the actor input.\n     */\n    actorInput(id, input, tick = 0, options) {\n        const { skipPending, isAsyncStorage, enableRollback, onUpdate } = options;\n        tick = enableRollback ? tick || now() : 0;\n        const indexOrPromise = this.store.storeInput(id, input, tick);\n        const completeActorInput = (index) => {\n            if (!skipPending && this.pending) {\n                this.pending.actorInput(id, index);\n            }\n            if (this.events) {\n                this.events.emit('actorInput', id, input, index, tick);\n            }\n            if (onUpdate) {\n                onUpdate();\n            }\n        };\n        if (isAsyncStorage && indexOrPromise instanceof Promise) {\n            indexOrPromise.then(completeActorInput);\n            return indexOrPromise;\n        }\n        completeActorInput(indexOrPromise);\n        return indexOrPromise;\n    }\n    /**\n     * Gets the list of symbols.\n     *\n     * @returns The list of symbols.\n     */\n    get symbolsList() {\n        return this.symbols?.getSymbols();\n    }\n    /**\n     * Gets the enum of symbols.\n     *\n     * @returns The enum of symbols.\n     */\n    get symbolsEnum() {\n        return this.symbols?.getSymbolsEnum();\n    }\n    /**\n     * Sets the symbols with the given symbols.\n     *\n     * @param {any} symbols - The symbols to set.\n     */\n    setSymbols(symbols) {\n        this.symbols?.reset(symbols);\n    }\n    /**\n     * Gets a symbol with the given index and options.\n     *\n     * @param {number} index - The index of the symbol to get.\n     * @param {Options} options - The options for getting the symbol.\n     * @returns The symbol.\n     */\n    getSymbol(index, options) {\n        const { actions } = options;\n        const symbol = this.symbols?.get(index);\n        if (!symbol) {\n            const symbolTuple = actions.fetchSymbol(symbol, this, options);\n            return symbolTuple[0];\n        }\n        return symbol;\n    }\n    /**\n     * Adds a symbol with the given symbol and options.\n     *\n     * @param {string} symbol - The symbol to add.\n     * @param {Options} options - The options for adding the symbol.\n     * @returns The index of the added symbol or null if the symbol could not be added.\n     */\n    addSymbol(symbol, options) {\n        if (this.symbols === null) {\n            return null;\n        }\n        const { actions, isSymbolLeader, skipPending, onUpdate } = options;\n        const enumSymbols = this.symbolsEnum ?? {};\n        let index = Object.prototype.hasOwnProperty.call(enumSymbols, symbol) ? enumSymbols[symbol] : -1;\n        if (index === -1) {\n            if (isSymbolLeader) {\n                index = this.symbols.add(symbol) ?? -1;\n                if (!skipPending && this.pending) {\n                    this.pending.addSymbol([symbol, index]);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n            else if (actions.fetchSymbol) {\n                const symbolTuple = actions.fetchSymbol(symbol, this, options);\n                index = symbolTuple[1];\n            }\n        }\n        if (index === -1) {\n            return null;\n        }\n        return index;\n    }\n    /**\n     * Fetches a symbol with the given payload, options, and match function.\n     *\n     * @param {string | number} payload - The payload for fetching the symbol.\n     * @param {Options} options - The options for fetching the symbol.\n     * @param {Function} onMatch - The function to call when a match is found.\n     * @returns The fetched symbol tuple.\n     */\n    fetchSymbol(payload, options, onMatch) {\n        if (this.symbols === null) {\n            return null;\n        }\n        const { isSymbolLeader, skipPending, onUpdate } = options;\n        const symbolTuple = this.symbols.fetch(payload);\n        if (symbolTuple[0] && symbolTuple[1] !== -1) {\n            if (onMatch) {\n                onMatch(symbolTuple);\n            }\n        }\n        else {\n            if (isSymbolLeader) {\n                const index = this.symbols.add(symbolTuple[0]);\n                symbolTuple[1] = index;\n                if (!skipPending && this.pending) {\n                    this.pending.addSymbol(symbolTuple);\n                }\n                if (onUpdate) {\n                    onUpdate();\n                }\n            }\n        }\n        return symbolTuple;\n    }\n    /**\n     * Merges a symbol with the given payload and options.\n     *\n     * @param {[string, number]} payload - The payload for merging the symbol.\n     * @param {Options} options - The options for merging the symbol.\n     */\n    mergeSymbol(payload, options) {\n        if (this.symbols === null) {\n            return null;\n        }\n        const { isSymbolLeader, isSymbolRelay, skipPending, onUpdate } = options;\n        this.symbols.merge(payload);\n        if ((isSymbolLeader || isSymbolRelay) && !skipPending && this.pending) {\n            this.pending.addSymbol(payload);\n        }\n        if (onUpdate) {\n            onUpdate();\n        }\n    }\n    /**\n     * Resets symbols with the given payload and options.\n     *\n     * @param {any[]} payload - The payload for resetting the symbols.\n     * @param {Options} options - The options for resetting the symbols.\n     */\n    resetSymbols(offset = 0, symbols, options) {\n        if (this.symbols === null) {\n            return null;\n        }\n        const { isSymbolLeader, isSymbolRelay, skipPending, onUpdate } = options;\n        this.symbols.reset(offset, symbols);\n        if ((isSymbolLeader || isSymbolRelay) && !skipPending && this.pending) {\n            this.pending.replaceSymbols(offset, symbols);\n        }\n        if (onUpdate) {\n            onUpdate();\n        }\n    }\n    /**\n     * Resets the current frame state.\n     */\n    resetFrame() {\n        if (this.pending) {\n            this.pending.reset();\n        }\n        if (this.order) {\n            this.order.reset();\n        }\n        if (this.changes) {\n            this.changes.reset();\n        }\n    }\n}\nexport default Context;\n","/**\n * Emitter\n *\n * @template T\n * @class Emitter\n * @description An Emitter is a class that emits values to its handlers.\n * @property {Function[]} handlers - The handlers of the Emitter.\n * @method emitTo - Adds a handler to the Emitter and returns the handler.\n * @method emit - Emits a value to the handlers of the Emitter.\n * @example\n * const emitter = new Emitter()\n * const handler = emitter.emitTo((value) => {\n *  console.log(value)\n * })\n * emitter.emit('Hello, world!')\n * emitter.done() // cleanup\n * // => 'Hello, world!'\n */\nexport class Emitter {\n    handlers;\n    emissions;\n    handlersDone;\n    emissionsDone;\n    /**\n     * Constructs a new Emitter object.\n     */\n    constructor(emissions = [], emissionsDone = false, handlers = [], handlersDone = false) {\n        this.handlers = handlers;\n        this.emissions = emissions;\n        for (const handler of this.handlers) {\n            for (const emission of this.emissions) {\n                handler(emission);\n            }\n        }\n        this.handlersDone = emissionsDone;\n        this.emissionsDone = handlersDone;\n        this.cleanup();\n    }\n    /**\n     * Cleans up the Emitter.\n     */\n    cleanup() {\n        if (this.handlersDone && this.emissionsDone) {\n            this.clear();\n        }\n    }\n    /**\n     * Clears all handlers and emissions from the Emitter.\n     */\n    clear() {\n        this.handlers = [];\n        this.emissions = [];\n        this.handlersDone = false;\n        this.emissionsDone = false;\n    }\n    /**\n     * Marks the Emitter as done.\n     *\n     * @param {boolean} handlersDone - Whether or not the Emitter is done emitting values.\n     * @param {boolean} emissionsDone - Whether or not the Emitter is done emitting values.\n     */\n    done(handlersDone = true, emissionsDone = true) {\n        this.handlersDone = handlersDone;\n        this.emissionsDone = emissionsDone;\n        this.cleanup();\n    }\n    /**\n     * Adds a handler to the Emitter and returns the handler.\n     *\n     * @param {Function} handler - The handler to add to the Emitter.\n     * @param {boolean} handlersDone - Whether or not the Emitter is done emitting values.\n     * @returns {Function} The handler.\n     */\n    emitTo(handler, handlersDone = false) {\n        this.handlers.push(handler);\n        for (const emission of this.emissions) {\n            handler(emission);\n        }\n        this.handlersDone = handlersDone;\n        this.cleanup();\n    }\n    /**\n     * Emits a value to the handlers of the Emitter.\n     *\n     * @param {T} value - The value to emit to the handlers of the Emitter.\n     * @param {boolean} emissionsDone - Whether or not the Emitter is done emitting values.\n     */\n    emit(value, emissionsDone = false) {\n        this.emissions.push(value);\n        for (const handler of this.handlers) {\n            handler(value);\n        }\n        this.emissionsDone = emissionsDone;\n        this.cleanup();\n    }\n    /**\n     * Removes a handler from the Emitter.\n     *\n     * @param {Function} handler - The handler to remove from the Emitter.\n     */\n    removeHandler(handler) {\n        const index = this.handlers.indexOf(handler);\n        if (index !== -1) {\n            this.handlers.splice(index, 1);\n        }\n    }\n    /**\n     * Removes an emission from the Emitter.\n     *\n     * @param {T} emission - The emission to remove from the Emitter.\n     */\n    removeEmission(emission) {\n        const index = this.emissions.indexOf(emission);\n        if (index !== -1) {\n            this.emissions.splice(index, 1);\n        }\n    }\n}\nexport default Emitter;\n","import { Context } from './context.js';\nimport { Options } from './options.js';\nimport { Storage } from './storage.js';\nimport { updater } from './updater.js';\nimport { now } from './utils.js';\n/**\n * Gets the symbol action.\n *\n * @param {string | number} action - The action.\n * @param {Record<number, string> | null} defaultSymbols - The default symbols.\n * @returns {number | string} The symbol action.\n */\nexport function getSymbolAction(action, defaultSymbols) {\n    if (defaultSymbols && typeof action === 'number' && defaultSymbols[action]) {\n        action = defaultSymbols[action];\n    }\n    return action;\n}\n/**\n * Gets the action handler.\n *\n * @param {Context} context - The context.\n * @param {OptionsExtended | any} options - The options.\n */\nexport function getActionHandler(context, options) {\n    options = options instanceof Options ? options : new Options(options);\n    const { actions, defaultSymbols } = options;\n    return (action) => {\n        action = getSymbolAction(action, defaultSymbols);\n        const handler = (payload) => {\n            if (actions[action]) {\n                actions[action](payload, context, options);\n            }\n        };\n        // Assign the action to the handler function.\n        handler.action = action;\n        return handler;\n    };\n}\n/**\n * Handles a single message.\n *\n * @param {Message | any[]} message - The message to handle.\n * @param {Context} context - The context for the handler.\n * @param {OptionsExtended | any} options - The options for the handler.\n*/\nexport function oneHandler(message, context, options) {\n    options = options instanceof Options ? options : new Options(options);\n    const actionHandler = getActionHandler(context, options);\n    if (Array.isArray(message)) {\n        actionHandler(message[0])(message[1]);\n    }\n    else if (message) {\n        actionHandler(message.action)(message.payload);\n    }\n}\nexport const handler = manyHandler;\n/**\n * Handles multiple messages.\n *\n * @param {Message | any[]} message - The messages to handle.\n * @param {Context} context - The context for the handler.\n * @param {OptionsExtended | any} options - The options for the handler.\n */\nexport function manyHandler(message, context, options) {\n    options = options instanceof Options ? options : new Options(options);\n    const { batchActionPayloadSizes, isOrdered, enableRollback } = options;\n    const actionHandler = getActionHandler(context, options);\n    const iterator = (payload, handler, offset = 0) => {\n        // Use the action from the handler Function\n        const action = handler.action;\n        let payloadSize = batchActionPayloadSizes[action] || 1;\n        if (payloadSize && typeof payloadSize === 'object') {\n            if (payloadSize.ordered && isOrdered) {\n                payloadSize = payloadSize.ordered;\n            }\n            else if (payloadSize.rollback && enableRollback) {\n                payloadSize = payloadSize.rollback;\n            }\n            else {\n                payloadSize = payloadSize.default;\n            }\n        }\n        for (let i = offset; i < payload.length; i += payloadSize) {\n            // Call the handler function with the payload\n            if (payloadSize === 1) {\n                handler(payload[i], context, options);\n            }\n            else if (batchActionPayloadSizes) {\n                handler(payload.slice(i, i + payloadSize), context, options);\n            }\n            else {\n                // console.warn('BATCH MISMATCH')\n            }\n        }\n    };\n    if (Array.isArray(message)) {\n        const handler = actionHandler(message[0]);\n        iterator(message, handler, 1);\n    }\n    else if (message) {\n        const handler = actionHandler(message.action);\n        iterator(message.payload, handler);\n    }\n}\n/**\n * The Handler class. It handles messages.\n */\nexport class Handler {\n    context;\n    options;\n    /**\n     * Creates a new Handler instance.\n     *\n     * @param {Context | any} context - The context for the handler.\n     * @param {Options | any} options - The options for the handler.\n     * @param {Object} actions - The actions for the handler.\n     * @param {Storage} _Storage - The storage for the handler.\n     */\n    constructor(context, options, actions, _Storage = Storage) {\n        this.options = Options.ensure(options, actions);\n        this.context = Context.ensure(context, options, _Storage);\n    }\n    /**\n     * Handles a single message.\n     *\n     * @param {Message | any[]} message - The message to handle.\n     */\n    one(message, extendOptions) {\n        return oneHandler(message, this.context, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Handles multiple messages.\n     *\n     * @param {Message | any[]} message - The messages to handle.\n     */\n    many(message, extendOptions) {\n        return manyHandler(message, this.context, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Gets the action handler.\n     */\n    getActionHandler() {\n        return getActionHandler(this.context, this.options);\n    }\n    /**\n     * Gets the symbol action.\n     *\n     * @param {string | number} action - The action.\n     */\n    getSymbolAction(action) {\n        return getSymbolAction(action, this.options.defaultSymbols);\n    }\n    /**\n     * Updates other nodes in the network.\n     *\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     * @param {number} tick - The tick for updating.\n     * @returns {Promise<any[]>} A promise that resolves with updated batch of messages.\n     */\n    updater(extendOptions, tick = now()) {\n        return updater(this.context, extendOptions ? this.options.extend(extendOptions) : this.options, tick);\n    }\n    /**\n     * Spawns an actor.\n     *\n     * @param {string} id - The ID of the actor to spawn.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    spawnActor(id, extendOptions) {\n        return this.context.spawnActor(id, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Despawns an actor.\n     *\n     * @param {string} id - The ID of the actor to despawn.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    removeActor(id, extendOptions) {\n        return this.context.removeActor(id, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Updates an actor with an input.\n     *\n     * @param {string} id - The ID of the actor to update.\n     * @param {any} input - The input for updating.\n     * @param {number} tick - The tick for updating.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    actorInput(id, input, tick = now(), extendOptions) {\n        return this.context.actorInput(id, input, tick, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Creates an entity.\n     *\n     * @param {string} id - The ID of the entity to create.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    createEntity(id, extendOptions) {\n        return this.context.createEntity(id, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Removes an entity.\n     *\n     * @param {string} id - The ID of the entity to remove.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    removeEntity(id, extendOptions) {\n        return this.context.removeEntity(id, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Sets a component to an entity.\n     *\n     * @param {string} id - The ID of the entity to add the component to.\n     * @param {string} key - The key of the component to add.\n     * @param {any} value - The value of the component to add.\n     * @param {number} tick - The tick for updating.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    upsertComponent(id, key, value, tick = now(), extendOptions) {\n        return this.context.upsertComponent(id, key, value, tick, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Changes a component of an entity.\n     *\n     * @param {string} id - The ID of the entity to change the component of.\n     * @param {string} key - The key of the component to change.\n     * @param {any} value - The value of the component to change.\n     * @param {number} tick - The tick for updating.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    changeComponent(id, key, value, tick = now(), extendOptions) {\n        return this.context.changeComponent(id, key, value, tick, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Removes a component from an entity.\n     *\n     * @param {string} id - The ID of the entity to remove the component from.\n     * @param {string} key - The key of the component to remove.\n     * @param {Options | any} extendOptions - Custom options to extend the options for the handler.\n     */\n    removeComponent(id, key, extendOptions) {\n        return this.context.removeComponent(id, key, extendOptions ? this.options.extend(extendOptions) : this.options);\n    }\n    /**\n     * Queries components.\n     *\n     * @param {any} query - The query for querying components.\n     * @returns {Set<any>} The components queried.\n     */\n    queryComponents(query) {\n        return this.context.store.queryComponents(query);\n    }\n}\nexport default Handler;\n","/**\n * The Index class represents an index.\n */\nexport class Index {\n    items;\n    constructor(items = null, _options = {}) {\n        this.items = items;\n    }\n    /**\n     * The clear method clears the index.\n     */\n    clear() {\n        this.items = null;\n    }\n    /**\n     * The clone method clones the index.\n     */\n    clone() {\n        return new Index(this.items);\n    }\n    /**\n     * The get method gets a value from the index.\n     *\n     * @param {any} _value - The value to get from the index.\n     * @returns {any} The value from the index.\n     */\n    get(_value) { }\n    /**\n     * The has method checks if a value is in the index.\n     *\n     * @param {any} _value - The value to check in the index.\n     * @param {any} _id - The ID of the value to check in the index.\n     * @returns {boolean} True if the value is in the index, false otherwise.\n     */\n    has(_value, _id) {\n        return false;\n    }\n    /**\n     * The remove method removes a value from the index.\n     *\n     * @param {any} _value - The value to remove from the index.\n     * @param {any} _id - The ID of the value to remove from the index.\n     * @returns {any} The value removed from the index.\n     */\n    remove(_value, _id) { }\n    /**\n     * The set method sets a value to the index.\n     *\n     * @param {any} _value - The value to set to the index.\n     * @param {any} _id - The ID to set to the index.\n     * @returns {any} The value being set.\n     */\n    set(_value, _id) {\n        return null;\n    }\n    /**\n   * The store method stores a value to the index.\n   *\n   * @param {ID} id - The ID of the value to store.\n   * @param {V} preValue - The previous value to store to the index.\n   * @param {V} value - The value to store to the index.\n   * @returns The value being stored.\n   */\n    store(id, preValue, value) {\n        if (preValue) {\n            this.remove(preValue, id);\n        }\n        return this.set(value, id);\n    }\n    /**\n     * The query method queries the index.\n     *\n     * @param {any} _query - The query to use.\n     * @returns {any[]} The result of the query.\n     */\n    query(_query) {\n        return [];\n    }\n}\n","import { Index } from './index.js';\nimport { binaryInsert } from '../utils.js';\n/**\n * binaryInsertID inserts an ID value into a sorted array.\n *\n * @param {any[]} items - The sorted array\n * @param {any} value - The value to insert\n * @param {any} id - The ID of the value to insert\n * @returns {number[]} The index of the inserted value\n */\nfunction binaryInsertID(items, value, id) {\n    const low = binaryInsert(items, value, (item) => item[0]);\n    const item = items[low];\n    const v = item[0];\n    if (v === value) {\n        const ids = item[1];\n        const i = ids.indexOf(id);\n        if (i === -1) {\n            ids.push(id);\n            return [low, ids.length - 1];\n        }\n        else {\n            // return [low, i]\n        }\n    }\n    else {\n        const ids = [id];\n        items.splice(low, 0, [value, ids]);\n        return [low, 0];\n    }\n    return [-1, -1];\n}\n/**\n * binaryRemove removes a value from a sorted array.\n *\n * @param {any[]} items - The sorted array\n * @param {any} value - The value to remove\n * @param {any} id - The ID of the value to remove\n * @returns {number[]} The index of the removed value\n */\nfunction binaryRemoveID(items, value, id) {\n    const low = binaryInsert(items, value, (item) => item[0]);\n    const item = items[low];\n    const v = item[0];\n    if (v === value) {\n        const ids = item[1];\n        const i = ids.lastIndexOf(id);\n        if (i !== -1) {\n            ids.splice(i, 1);\n            if (ids.length === 0) {\n                items.splice(low, 1);\n            }\n            return [low, i];\n        }\n    }\n    return [-1, -1];\n}\n/**\n * SortedIndex class represents a sorted index.\n */\nexport class SortedIndex extends Index {\n    constructor(items = [], _options = {}) {\n        super(items);\n    }\n    /**\n     * The clear method clears the index.\n     */\n    clear() {\n        this.items = [];\n    }\n    /**\n     * The clone method clones the index.\n     */\n    clone() {\n        return new SortedIndex(this.items);\n    }\n    /**\n     * The get method gets a value from the index.\n     *\n     * @param {V} value - The value to get from the index.\n     * @returns {ID[]} The value from the index.\n     */\n    get(value) {\n        const item = this.items.find((item) => item[0] === value);\n        if (item) {\n            return item[1];\n        }\n        return [];\n    }\n    /**\n     * The has method checks if a value is in the index.\n     *\n     * @param {V} value - The value to check in the index.\n     * @param {ID} id - The ID of the value to check in the index.\n     * @returns {boolean} True if the value is in the index, false otherwise.\n     */\n    has(value, id) {\n        const item = this.items.find((item) => item[0] === value);\n        if (id === undefined) {\n            return !!item;\n        }\n        if (item) {\n            const ids = item[1];\n            return ids.indexOf(id) !== -1;\n        }\n        return false;\n    }\n    /**\n     * The remove method removes a value from the index.\n     *\n     * @param {T} value - The value to remove from the index.\n     * @returns {number[]} The value removed from the index.\n     */\n    remove(value, id) {\n        const indexes = binaryRemoveID(this.items, value, id);\n        return indexes;\n        // return indexes[0] === -1 || indexes[1] === -1 ? null : value \n    }\n    /**\n     * The set method sets a value to the index.\n     *\n     * @param {T} value - The value to set to the index.\n     * @param {ID} id - The ID of the value to set to the index.\n     * @returns {number[]} The index of the value being set.\n     */\n    set(value, id) {\n        const indexes = binaryInsertID(this.items, value, id);\n        return indexes;\n    }\n    /**\n     * The query method queries the manager.\n     *\n     * @param {V} query - The query to use.\n     * @returns {ID[]} The result of the query.\n     */\n    query(query) {\n        // if (query && typeof query === 'object') {}\n        return this.get(query);\n    }\n}\n","import { Index } from './index.js';\nimport { binarySearch } from '../utils.js';\n/**\n * The SpatialIndex class represents a spatial index.\n */\nexport class SpatialIndex extends Index {\n    constructor(items = [], { cellSize = 5 } = {}) {\n        super(items);\n        this.cellSize = cellSize;\n    }\n    /**\n     * The clear method clears the index.\n     */\n    clear() {\n        this.items = [];\n    }\n    /**\n     * The clone method clones the index.\n     */\n    clone() {\n        return new SpatialIndex(this.items);\n    }\n    /**\n     * The get method gets a value from the index.\n     *\n     * @param {V} value - The value to get from the index.\n     * @returns {ID[]} The value from the index.\n     */\n    get(value) {\n        const hash = this.hash(value);\n        this.items[hash] = this.items[hash] || [];\n        const ids = this.items[hash];\n        if (ids) {\n            return ids;\n        }\n        return [];\n    }\n    /**\n     * The has method checks if a value is in the index.\n     *\n     * @param {V} value - The value to check in the index.\n     * @param {ID} id - The ID of the value to check in the index.\n     * @returns {boolean} True if the value is in the index, false otherwise.\n     */\n    has(value, id) {\n        const hash = this.hash(value);\n        this.items[hash] = this.items[hash] || [];\n        const ids = this.items[hash];\n        if (id === undefined) {\n            return !!ids;\n        }\n        if (ids) {\n            return ids.indexOf(id) !== -1;\n        }\n        return false;\n    }\n    /**\n     * The hash method hashes 2D or 3D value.\n     * @param {number[]} value - The 2D or 3D value to hash.\n     * @returns {number} The hash of the value.\n     */\n    hash(value) {\n        if (value.length === 2) {\n            return this.hash2d(value[0], value[1]);\n        }\n        return this.hash3d(value[0], value[1], value[2]);\n    }\n    /**\n     * The hash2d method hashes a 2D value.\n     * @param {number} x - The X value to hash.\n     * @param {number} y - The Y value to hash.\n     * @returns {number} The hash of the 3D value.\n     */\n    hash2d(x = 0, y = 0) {\n        const ix = Math.floor((x + 1000) / this.cellSize), iy = Math.floor((y + 1000) / this.cellSize);\n        return ((ix * 73856093) ^ (iy * 19349663)); // % 5000; // 5000 is size of hash table.\n    }\n    /**\n     * The hash3d method hashes a 3D value.\n     * @param {number} x - The X value to hash.\n     * @param {number} y - The Y value to hash.\n     * @param {number} z - The Z value to hash.\n     * @returns {number} The hash of the 3D value.\n     */\n    hash3d(x = 0, y = 0, z = 0) {\n        const ix = Math.floor((x + 1000) / this.cellSize), iy = Math.floor((y + 1000) / this.cellSize), iz = Math.floor((z + 1000) / this.cellSize);\n        return ((ix * 73856093) ^ (iy * 19349663) ^ (iz * 83492791)); // % 5000; // 5000 is size of hash table.\n    }\n    /**\n     * The remove method removes a value from the index.\n     *\n     * @param {T} value - The value to remove from the index.\n     * @returns {number[]} The value removed from the index.\n     */\n    remove(value, id) {\n        const hash = this.hash(value);\n        this.items[hash] = this.items[hash] || [];\n        const ids = this.items[hash];\n        const [index] = binarySearch(ids, id);\n        if (index === -1) {\n            ids.splice(index, 1);\n        }\n        if (ids.length === 0) {\n            delete this.items[hash];\n        }\n        return [hash, index];\n    }\n    /**\n     * The set method sets a value to the index.\n     *\n     * @param {T} value - The value to set to the index.\n     * @param {ID} id - The ID of the value to set to the index.\n     * @returns {number[]} The index of the value being set.\n     */\n    set(value, id) {\n        const hash = this.hash(value);\n        this.items[hash] = this.items[hash] || [];\n        const ids = this.items[hash];\n        const [index, left] = binarySearch(ids, id);\n        if (index === -1) {\n            ids.splice(left, 0, id);\n        }\n        return [hash, index];\n    }\n    /**\n     * The query method queries the manager.\n     *\n     * @param {V} query - The query to use.\n     * @returns {ID[]} The result of the query.\n     */\n    query(query) {\n        let results = [];\n        const o = this.cellSize;\n        const dims = query.length === 2 ? 2 : 3;\n        if (dims === 2) {\n            const [x, y] = query;\n            for (let xx = -o * 2; xx < o * 2 + o; xx += o) {\n                for (let yy = -o * 2; yy < o * 2 + o; yy += o) {\n                    const ids = this.items[this.hash2d(x + xx, y + yy)];\n                    if (ids !== undefined) {\n                        results = results.concat(ids);\n                    }\n                }\n            }\n        }\n        else {\n            const [x, y, z] = query;\n            for (let xx = -o * 2; xx < o * 2 + o; xx += o) {\n                for (let yy = -o * 2; yy < o * 2 + o; yy += o) {\n                    for (let zz = -o * 2; zz < o * 2 + o; zz += o) {\n                        const ids = this.items[this.hash3d(x + xx, y + yy, z + zz)];\n                        if (ids !== undefined) {\n                            results = results.concat(ids);\n                        }\n                    }\n                }\n            }\n        }\n        return results;\n    }\n}\n","import actorActions, { ActorActionsFactory } from './actions/actor.js';\nimport componentActions, { ComponentActionsFactory } from './actions/component.js';\nimport coreActions, { CoreActionsFactory } from './actions/core.js';\nimport entityActions, { EntityActionsFactory } from './actions/entity.js';\nimport symbolActions, { SymbolActionsFactory } from './actions/symbol.js';\n/**\n * A factory function that creates a new instance of the AllActions class that extends the provided Parent class\n *\n * @param {any} Parent - The class to be extended by the AllActions class.\n * @returns {any} A new class that extends the provided Parent class and the CoreActions class.\n */\nexport function AllActionsFactory(Parent = Object) {\n    return ActorActionsFactory(ComponentActionsFactory(CoreActionsFactory(EntityActionsFactory(SymbolActionsFactory(Parent)))));\n}\n/**\n * Combines all the actions from different modules into a single object.\n */\nexport const allActions = {\n    ...actorActions,\n    ...componentActions,\n    ...coreActions,\n    ...entityActions,\n    ...symbolActions\n};\n/**\n * The NodeActions class provides methods for managing nodes in a context.\n */\nexport class NodeActions extends AllActionsFactory() {\n}\nconst __NodeActions__ = new NodeActions();\n/**\n * The actions object combines all the actions from different modules.\n */\nexport const actions = {\n    /**\n     * Handles input for a specific actor in the current context.\n     */\n    actorInput: __NodeActions__.actorInput,\n    /**\n     * Retrieves actors from the current context.\n     */\n    actors: __NodeActions__.actors,\n    /**\n     * Merges actors into the current context.\n     */\n    mergeActors: __NodeActions__.mergeActors,\n    /**\n     * Removes an actor from the current context.\n     */\n    removeActor: __NodeActions__.removeActor,\n    /**\n     * Spawns a new actor in the current context.\n     */\n    spawnActor: __NodeActions__.spawnActor,\n    /**\n     * Changes a component in the current context.\n     */\n    changeComponent: __NodeActions__.changeComponent,\n    /**\n     * Retrieves components from the current context.\n     */\n    components: __NodeActions__.components,\n    /**\n     * Merges components into the current context.\n     */\n    mergeComponents: __NodeActions__.mergeComponents,\n    /**\n     * Removes a component from the current context.\n     */\n    removeComponent: __NodeActions__.removeComponent,\n    /**\n     * Updates an existing component or inserts a new one if it doesn't exist in the current context.\n     */\n    upsertComponent: __NodeActions__.upsertComponent,\n    /**\n     * Processes a batch of payloads in the current context.\n     */\n    batch: __NodeActions__.batch,\n    /**\n     * Creates a new entity in the current context.\n     */\n    createEntity: __NodeActions__.createEntity,\n    /**\n     * Retrieves entities from the current context.\n     */\n    entities: __NodeActions__.entities,\n    /**\n     * Merges entities into the current context.\n     */\n    mergeEntities: __NodeActions__.mergeEntities,\n    /**\n     * Removes an entity from the current context.\n     */\n    removeEntity: __NodeActions__.removeEntity,\n    /**\n     * Adds a symbol to the current context.\n     */\n    addSymbol: __NodeActions__.addSymbol,\n    /**\n     * Fetches a symbol from the current context.\n     */\n    fetchSymbol: __NodeActions__.fetchSymbol,\n    /**\n     * Retrieves a symbol from the current context by its index.\n     */\n    getSymbol: __NodeActions__.getSymbol,\n    /**\n     * Merges a symbol into the current context.\n     */\n    mergeSymbol: __NodeActions__.mergeSymbol,\n    /**\n     * Merges multiple symbols into the current context.\n     */\n    mergeSymbols: __NodeActions__.mergeSymbols,\n    /**\n     * Retrieves a symbol from the current context.\n     */\n    symbol: __NodeActions__.symbol,\n    /**\n     * Retrieves all symbols from the current context.\n     */\n    symbols: __NodeActions__.symbols,\n};\nexport default actions;\n","// import { Context } from './index.js';\nimport * as Constants from './constants.js';\nimport { actions as defaultActions } from './node.js';\n/**\n * The Options class represents the options for a node.\n */\nexport class Options {\n    actions;\n    batchActionPayloadSizes;\n    compressStringsAsInts;\n    defaultSymbols;\n    enableRollback;\n    enableQuerying;\n    enumDefaultSymbols;\n    getActorId;\n    getGroupedValue;\n    indexes;\n    isAuthority;\n    isAsyncStorage;\n    isComponentRelay;\n    isDiffed;\n    isGroupedComponents;\n    isOrdered;\n    isReadOnly;\n    isSymbolLeader;\n    isSymbolRelay;\n    onUpdate;\n    pageSize;\n    responder;\n    skipPending;\n    types;\n    setGroupedValue;\n    storeOptions;\n    updateOptions;\n    worldOptions;\n    // [key: string]: any;\n    /**\n     * Ensures that the provided options are an instance of Options.\n     *\n     * @param {Options | OptionsProps} options - The options for the node.\n     * @param {any} actionsThis - The context for the actions.\n     * @returns {Options} - An instance of Options.\n     */\n    static ensure(options = {}, actionsThis) {\n        return options instanceof Options ? options : new Options(options, actionsThis);\n    }\n    /**\n     * Constructs a new Options object.\n     *\n     * @param {Options | OptionsProps} options - The options for the node.\n     * @param {any} actionsThis - The context for the actions.\n     */\n    constructor(options = {}, actionsThis = null) {\n        const { actions = actionsThis || defaultActions, batchActionPayloadSizes = Constants.batchActionPayloadSizes, compressStringsAsInts = Constants.defaultOptions.compressStringsAsInts, defaultSymbols = Constants.DefaultSymbols, enableRollback = Constants.defaultOptions.enableRollback, enableQuerying = Constants.defaultOptions.enableQuerying, enumDefaultSymbols = Constants.enumDefaultSymbols, getActorId = Constants.defaultGetActorId, getGroupedValue = Constants.defaultGetGroupedValue, indexes = Constants.defaultOptions.indexes, isAuthority = Constants.defaultOptions.isAuthority, isAsyncStorage = Constants.defaultOptions.isAsyncStorage, isComponentRelay = Constants.defaultOptions.isComponentRelay, isDiffed = Constants.defaultOptions.isDiffed, isGroupedComponents = Constants.defaultOptions.isGroupedComponents, isOrdered = Constants.defaultOptions.isOrdered, isReadOnly = Constants.defaultOptions.isReadOnly, isSymbolLeader = Constants.defaultOptions.isSymbolLeader, isSymbolRelay = Constants.defaultOptions.isSymbolRelay, onUpdate = null, pageSize = Constants.defaultOptions.pageSize, responder = Constants.voidResponder, skipPending = Constants.defaultOptions.skipPending, types = Constants.defaultOptions.types, setGroupedValue = Constants.defaultSetGroupedValue, storeOptions = {}, updateOptions: overridenUpdateOptions = {}, worldOptions = null,\n        // ...otherOptions\n         } = options;\n        const updateOptions = {\n            ...Constants.defaultUpdateOptions,\n            ...overridenUpdateOptions\n        };\n        updateOptions.validKeys = !overridenUpdateOptions?.validKeys\n            ? null\n            : {\n                ...Constants.defaultValidKeys,\n                ...(overridenUpdateOptions?.validKeys || {})\n            };\n        this.actions = actions;\n        this.batchActionPayloadSizes = batchActionPayloadSizes;\n        this.compressStringsAsInts = compressStringsAsInts;\n        this.defaultSymbols = defaultSymbols;\n        this.enableRollback = enableRollback;\n        this.enableQuerying = enableQuerying;\n        this.enumDefaultSymbols = enumDefaultSymbols;\n        this.getActorId = getActorId;\n        this.getGroupedValue = getGroupedValue;\n        this.indexes = indexes;\n        this.isAuthority = isAuthority;\n        this.isAsyncStorage = isAsyncStorage;\n        this.isComponentRelay = isComponentRelay;\n        this.isDiffed = isDiffed;\n        this.isGroupedComponents = isGroupedComponents;\n        this.isOrdered = isOrdered;\n        this.isReadOnly = isReadOnly;\n        this.isSymbolLeader = isSymbolLeader;\n        this.isSymbolRelay = isSymbolRelay;\n        this.onUpdate = onUpdate;\n        this.pageSize = pageSize;\n        this.responder = responder;\n        this.skipPending = skipPending;\n        this.types = types;\n        this.setGroupedValue = setGroupedValue;\n        this.storeOptions = storeOptions;\n        this.updateOptions = updateOptions;\n        this.worldOptions = worldOptions;\n        // Object.assign(this, otherOptions)\n    }\n    /**\n     * Creates a new Options object from the current one.\n     *\n     * @param {Options | OptionsProps} options - The options for the node.\n     * @param {any} actionThis - The context for the actions.\n     */\n    clone() {\n        return new Options({ ...this }, this.actions);\n    }\n    /**\n     * Extends the current Options object.\n     *\n     * @param {Options | OptionsProps | Object} options - The options for the node.\n     * @param {any} actionThis - The context for the actions.\n     */\n    extend(options, actionThis = this.actions) {\n        return new Options({ ...this, ...options }, actionThis);\n    }\n}\nexport default Options;\n","import { now } from './utils.js';\n/**\n * The Ordered class represents a collection of tick values.\n *\n * @property {OrderedData} order - The collection of tick values.\n */\nexport class Ordered {\n    order;\n    /**\n     * Constructs a new Ordered object.\n     *\n     * @param {OrderedData} order - The initial tick values.\n     */\n    constructor(order = {}) {\n        this.order = order;\n    }\n    /**\n     * Changes the tick value of a component.\n     *\n     * @param {string} id - The ID of the component.\n     * @param {string} key - The key of the component.\n     * @param {number} tick - The new tick value.\n     * @returns {boolean} Whether the operation was successful.\n     */\n    changeComponent(id, key, tick) {\n        return this.upsertComponent(id, key, tick);\n    }\n    /**\n     * Resets the tick values.\n     *\n     * @param {OrderedData} order - The new tick values.\n     * @returns {Ordered} The Ordered object.\n     */\n    reset(order = {}) {\n        this.order = order;\n    }\n    /**\n     * Inserts or updates the tick value of a component.\n     *\n     * @param {string} id - The ID of the component.\n     * @param {string} key - The key of the component.\n     * @param {number} tick - The new tick value.\n     * @returns {boolean} Whether the operation was successful.\n     */\n    upsertComponent(id, key, tick) {\n        if (isNaN(tick)) {\n            return false;\n        }\n        this.order = this.order || {};\n        this.order[id] = this.order[id] || {};\n        switch (typeof this.order[id][key]) {\n            case 'number':\n                if (isFinite(this.order[id][key]) && this.order[id][key] <= tick) {\n                    const threshold = 0;\n                    if (tick > (now() + threshold)) {\n                        return false;\n                    }\n                    this.order[id][key] = tick;\n                    return true;\n                }\n                return false;\n            case 'undefined':\n            default:\n                this.order[id][key] = tick;\n                return true;\n        }\n    }\n}\nexport default Ordered;\n","/**\n * The Pending class represents a pending state with removed, updated, and created states.\n *\n * @property {RemovedState} removed - The removed state.\n * @property {UpdatedState} updated - The updated state.\n * @property {CreatedState} created - The created state.\n */\nexport class Pending {\n    /**\n     * Constructs a new Pending object and resets its state.\n     */\n    constructor(isDiffed = false) {\n        this.created = {\n            actors: {},\n            components: {},\n            entities: [],\n            inputs: {}\n        };\n        this.removed = {\n            actors: {},\n            components: {},\n            entities: []\n        };\n        this.updated = {\n            components: {}\n        };\n        this.symbols = [];\n        this.isDiffed = isDiffed;\n    }\n    /**\n     * Adds an actor input to the created inputs state.\n     *\n     * @param {string} id - The ID of the actor.\n     * @param {number} index - The index of the new input.\n     */\n    actorInput(id, index) {\n        this.created.inputs[id] = this.created.inputs[id] || [];\n        this.created.inputs[id].push(index);\n    }\n    /**\n     * Changes a component in the specified pending state.\n     *\n     * @param {string} pendingType - The type of the pending state (removed, updated, or created).\n     * @param {string} id - The ID of the entity.\n     * @param {string} key - The key of the component.\n     */\n    changeComponent(pendingType, id, key) {\n        return this.upsertComponent(pendingType, id, key);\n    }\n    /**\n     * Marks an entity as created in the created state.\n     *\n     * @param {string} id - The ID of the entity to create.\n     */\n    createEntity(id) {\n        this.created.entities.push(id);\n    }\n    /**\n     * Marks an actor as removed in the removed state.\n     *\n     * @param {string} id - The ID of the actor to remove.\n     */\n    removeActor(id) {\n        this.removed.actors[id] = true;\n    }\n    /**\n     * Marks a component as removed in the removed state.\n     *\n     * @param {string} id - The ID of the entity.\n     * @param {string} key - The key of the component to remove.\n     */\n    removeComponent(id, key) {\n        this.removed.components[id] = this.removed.components[id] || {};\n        this.removed.components[id][key] = true;\n    }\n    /**\n     * Marks an entity as removed in the removed state.\n     *\n     * @param {string} id - The ID of the entity to remove.\n     */\n    removeEntity(id) {\n        this.removed.entities.push(id);\n    }\n    /**\n     * Resets the state of the Pending object.\n     */\n    reset() {\n        this.constructor();\n    }\n    /**\n     * Marks an actor as spawned in the created state.\n     *\n     * @param {string} id - The ID of the actor to spawn.\n     */\n    spawnActor(id) {\n        this.created.actors[id] = true;\n    }\n    /**\n     * Inserts or updates a component in the specified pending state.\n     *\n     * @param {string} pendingType - The type of the pending state (created or updated).\n     * @param {string} id - The ID of the entity.\n     * @param {string} key - The key of the component.\n     */\n    upsertComponent(pendingType, id, key) {\n        const pending = pendingType === 'created' ? this.created : this.updated;\n        if (pending) {\n            if (\n            // !this.isDiffed // Diffed updates need to be created.\n            // &&\n            pendingType === 'updated'\n                && this.created.components[id]\n                && this.created.components[id][key]) {\n                // Skip updating a component that was created and updated in the same tick.\n                return;\n            }\n            pending.components[id] = pending.components[id] || {};\n            pending.components[id][key] = true;\n        }\n    }\n    /**\n     * Adds a symbol tuple to the symbols array.\n     *\n     * @param {any} symbolTuple - The symbol tuple to add.\n     */\n    addSymbol(symbolTuple) {\n        this.symbols.push(symbolTuple);\n    }\n    /**\n     * Replaces the symbols array with a new array of symbol tuples.\n     *\n     * @param {any[]} symbols - The new array of symbols.\n     */\n    replaceSymbols(offset, symbols) {\n        if (offset > 0) {\n            const { length } = symbols;\n            const { symbols: _symbols } = this;\n            for (let i = 0; i < length; i++) {\n                const value = symbols[i];\n                const index = i + offset;\n                _symbols[index] = [value, index];\n            }\n        }\n        else {\n            this.symbols = symbols.map((v, i) => [v, i]);\n        }\n    }\n}\nexport default Pending;\n","import { Index } from './index.js';\nimport { \n// SetExperimental,\ndifferenceSets, intersectionSets, unionSets, } from '../utils.js';\n/**\n * The Index class represents an index.\n */\nexport class ComponentsIndex extends Index {\n    constructor(items = {}, _options = {}) {\n        super(items);\n    }\n    /**\n     * The clear method clears the index.\n     */\n    clear() {\n        this.items = {};\n    }\n    /**\n     * The clone method clones the index.\n     */\n    clone() {\n        return new Index(this.items);\n    }\n    /**\n     * The get method gets a value from the index.\n     *\n     * @param {any} value - The value to get from the index.\n     * @returns {any} The value from the index.\n     */\n    get(value) {\n        return this.items[value];\n    }\n    /**\n     * The has method checks if a value is in the index.\n     *\n     * @param {any} value - The value to check in the index.\n     * @param {any} id - The ID of the value to check in the index.\n     * @returns {boolean} True if the value is in the index, false otherwise.\n     */\n    has(value, id) {\n        const ids = this.items[value];\n        if (ids && ids.has(id)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The remove method removes a value from the index.\n     *\n     * @param {any} value - The value to remove from the index.\n     * @param {any} id - The ID of the value to remove from the index.\n     * @returns {any} The value removed from the index.\n     */\n    remove(value, id) {\n        const ids = this.items[value];\n        if (ids && ids.has(id)) {\n            ids.delete(id);\n            return true;\n        }\n    }\n    /**\n     * The set method sets a value to the index.\n     *\n     * @param {any} value - The value to set to the index.\n     * @param {any} id - The ID to set to the index.\n     * @returns {any} The value being set.\n     */\n    set(value, id) {\n        this.items[value] = this.items[value] || new Set();\n        if (this.items[value].has(id)) {\n            return false;\n        }\n        this.items[value].add(id);\n        return true;\n    }\n    /**\n     * The union method creates an union of two indexes.\n     *\n     * @param {string} key - The key of the index.\n     * @param {Index} other - The other index.\n     * @returns {Index} The union of the indexes.\n     */\n    union(key, other) {\n        return new ComponentsIndex({\n            ...this.items,\n            [key]: unionSets(this.items[key], other.items[key])\n        });\n    }\n    /**\n     * The difference method creates a difference of two indexes.\n     *\n     * @param {string} key - The key of the index.\n     * @param {Index} other - The other index.\n     * @returns {Index} The difference of the indexes.\n     */\n    difference(key, other) {\n        return new ComponentsIndex({\n            ...this.items,\n            [key]: differenceSets(this.items[key], other.items[key])\n        });\n    }\n    /**\n     * The intersection method creates an intersection of two indexes.\n     *\n     * @param {string} key - The key of the index.\n     * @param {Index} other - The other index.\n     * @returns {Index} The intersection of the indexes.\n     */\n    intersection(key, other) {\n        return new ComponentsIndex({\n            ...this.items,\n            [key]: intersectionSets(this.items[key], other.items[key])\n        });\n    }\n    /**\n    * The query method queries the index.\n    *\n    * @param {any} query - The query to use.\n    * @returns {any[]} The result of the query.\n    */\n    query(query) {\n        const { with: with_, without,\n        // where,\n         } = query || {};\n        let matches = new Set();\n        if (with_) {\n            for (const key of with_) {\n                const ids = this.items[key];\n                if (ids) {\n                    matches = unionSets(matches, ids);\n                }\n            }\n        }\n        if (without) {\n            for (const key of without) {\n                const ids = this.items[key];\n                if (ids) {\n                    matches = differenceSets(matches, ids);\n                }\n            }\n        }\n        return matches;\n    }\n}\n","import { SortedIndex } from './indexes/sorted.js';\nimport { SpatialIndex } from './indexes/spatial.js';\nimport { ComponentsIndex } from './indexes/components.js';\nimport { BasicTypes, ArrayTypes } from './types.js';\nimport { binarySearch } from './utils.js';\nimport { paginate } from './utils.js';\n// export {\n//   StorageInterface,\n//   StorageOptions,\n//   StorageProps,\n//   Components,\n//   Types,\n//   Inputs\n// }\n/**\n * The Indexes interface represents a mapping from keys to any array.\n */\nexport const IndexMap = {\n    sorted: SortedIndex,\n    spatial: SpatialIndex,\n};\nexport function createStorageProps(props = {}, storage = {}, options = {}) {\n    const { actors = [], entities = [], components = {}, inputs = {} } = storage || {};\n    const { types = {}, indexes = {},\n    // worldOptions,\n     } = options;\n    props.actors = actors || [];\n    props.entities = entities || [];\n    props.components = components || {};\n    props.inputs = inputs || {};\n    props.types = types;\n    props.typeCtors = {};\n    for (let key in types) {\n        let TypeCtor = types[key];\n        if (Array.isArray(TypeCtor)) {\n            TypeCtor = BasicTypes.get(TypeCtor[0]) || ArrayTypes.get(TypeCtor[0]);\n        }\n        else if (typeof TypeCtor === 'string') {\n            TypeCtor = BasicTypes.get(TypeCtor) || ArrayTypes.get(TypeCtor);\n        }\n        if (typeof TypeCtor === 'function') {\n            if (TypeCtor) {\n                props.typeCtors[key] = TypeCtor;\n            }\n        }\n    }\n    props.componentsIndex = new ComponentsIndex();\n    props.indexes = {};\n    for (let key in indexes) {\n        const { type } = indexes[key];\n        const IndexCtor = IndexMap[type];\n        if (IndexCtor) {\n            props.indexes[key] = {\n                actors: new IndexCtor([], indexes[key]),\n                entities: new IndexCtor([], indexes[key]),\n            };\n        }\n    }\n    return props;\n}\n/**\n * The Storage class represents a store with actors, entities, components, and inputs.\n *\n * @property {string[]} actors - The actors in the store.\n * @property {string[]} entities - The entities in the store.\n * @property {Components} components - The components in the store.\n * @property {Inputs} inputs - The inputs in the store.\n * @property {Types} types - The types in the store.\n * @property {any} typeCtors - The type constructors in the store\n * @property {ComponentsIndex} componentsIndex - The components index in the store.\n * @property {Indexes} indexes - The indexes in the store.\n */\nexport class Storage {\n    // declare world?: any\n    /**\n     * Constructs a new Storage object.\n     *\n     * @param {StorageProps} storage - The properties of the store.\n     */\n    constructor(storage = {}, options = {}) {\n        createStorageProps(this, storage, options);\n    }\n    /**\n     * Removes an actor ID.\n     *\n     * @param {string} id - The ID of the actor to remove.\n     * @returns {boolean} True if the actor ID was removed, false otherwise.\n     */\n    destroyActor(id) {\n        const actors = this.actors;\n        return this.destroyId(actors, id);\n    }\n    /**\n     * Removes a component.\n     *\n     * @param {string} id - The ID of the component to remove.\n     * @param {string} key - The key of the component to remove.\n     */\n    destroyComponent(id, key) {\n        const prevValue = this.components[id][key];\n        delete this.components[id][key];\n        this.removeComponentsIndex(id, key, prevValue);\n    }\n    /**\n     * Removes an entity ID.\n     *\n     * @param {string} id - The ID of the entity to remove.\n     * @returns {boolean} True if the entity ID was removed, false otherwise.\n     */\n    destroyEntity(id) {\n        const entities = this.entities;\n        return this.destroyId(entities, id);\n    }\n    /**\n     * Removes an ID from a list if it exists.\n     *\n     * @param {string[]} list - The list to remove the ID from.\n     * @param {string} id - The ID to remove.\n     * @returns {boolean} True if the ID was removed, false otherwise.\n     */\n    destroyId(list, id) {\n        const [index] = binarySearch(list, id);\n        if (index !== -1) {\n            list.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Fetches a components container for an entity.\n     *\n     * @param {string} id - The ID of the entity.\n     * @returns {Components} The fetched components container.\n     */\n    findComponents(id) {\n        this.components[id] = this.components[id] || {};\n        return this.components[id];\n    }\n    /**\n     * Fetches a component.\n     *\n     * @param {string} id - The ID of the component to fetch.\n     * @param {string} key - The key of the component to fetch.\n     * @returns {any} The fetched component.\n     */\n    findComponent(id, key) {\n        this.components[id] = this.components[id] || {};\n        return this.components[id][key];\n    }\n    /**\n     * Fetches an actors inputs\n     *\n     * @param {string} id - The ID of the actor.\n     * @returns {InputPayload} The fetched inputs.\n     */\n    findInputs(id) {\n        return this.inputs[id];\n    }\n    /**\n     * Fetches an actors input\n     *\n     * @param {string} id - The ID of the actor.\n     * @param {number} index - The index of the input.\n     * @returns {InputPayload} The fetched inputs.\n     */\n    findInput(id, index) {\n        this.inputs[id] = this.inputs[id] || [];\n        const input = this.inputs[id][index];\n        if (Array.isArray(input)) {\n            return [{ ...input[0], id }, input[1]];\n        }\n        return { ...input, id };\n    }\n    /**\n     * Gets the actors.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {string[][]} The actors.\n     */\n    getActors(query = null, pageSize = Infinity) {\n        if (query !== null) {\n            let results = {};\n            for (let key in query) {\n                const index = this.indexes[key];\n                if (index) {\n                    const result = index.actors.query(query[key]);\n                    result.forEach((id) => {\n                        results[id] = true;\n                    });\n                }\n            }\n            const ids = Object.keys(results);\n            return paginate(ids, pageSize);\n        }\n        return paginate(this.actors, pageSize);\n    }\n    /**\n     * Gets the components.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {Components} The components.\n     */\n    getComponents(query = null, pageSize = Infinity) {\n        let object = this.components;\n        if (query !== null) {\n            const results = {};\n            for (let key of query) {\n                results[key] = this.components[key];\n            }\n            object = results;\n        }\n        const ids = Object.keys(object);\n        const pages = paginate(ids, pageSize);\n        return pages.map((page) => {\n            const components = {};\n            for (let id of page) {\n                components[id] = object[id];\n            }\n            return components;\n        });\n    }\n    /**\n     * Gets the entities.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {string[]} The entities.\n     */\n    getEntities(query = null, pageSize = Infinity) {\n        if (query !== null) {\n            let results = {};\n            for (let key in query) {\n                const index = this.indexes[key];\n                if (index) {\n                    const result = index.entities.query(query[key]);\n                    result.forEach((id) => {\n                        results[id] = true;\n                    });\n                }\n            }\n            const ids = Object.keys(results);\n            return paginate(ids, pageSize);\n        }\n        return paginate(this.entities, pageSize);\n    }\n    /**\n     * Gets the inputs.\n     *\n     * @returns {Inputs} The inputs.\n     */\n    getInputs(query = null, pageSize = Infinity) {\n        let object = this.inputs;\n        if (query !== null) {\n            const results = {};\n            for (let key of query) {\n                results[key] = this.inputs[key];\n            }\n            object = results;\n        }\n        const ids = Object.keys(object);\n        const pages = paginate(ids, pageSize);\n        return pages.map((page) => {\n            const inputs = {};\n            for (let id of page) {\n                inputs[id] = object[id];\n            }\n            return inputs;\n        });\n    }\n    /**\n     * Checks if an ID is an actor.\n     *\n     * @param {string} id - The ID to check.\n     * @returns {boolean} True if the ID is an actor, false otherwise.\n     */\n    isActor(id) {\n        const actors = this.actors;\n        return actors.indexOf(id) !== -1;\n    }\n    /**\n     * Checks if an ID is an entity.\n     *\n     * @param {string} id - The ID to check.\n     * @returns {boolean} True if the ID is an entity, false otherwise.\n     */\n    isEntity(id) {\n        const entities = this.entities;\n        return entities.indexOf(id) !== -1;\n    }\n    /**\n     * Sets the actors.\n     *\n     * @param {string[]} actors - The actors to set.\n     * @returns {string[]} The actors.\n     */\n    setActors(actors) {\n        this.actors = actors;\n        return actors;\n    }\n    /**\n     * Sets the components.\n     *\n     * @param {Components} components - The components to set.\n     * @returns {Components} The components.\n     */\n    setComponents(components) {\n        this.components = components;\n        return components;\n    }\n    /**\n     * Sets the entities.\n     *\n     * @param {string[]} entities - The entities to set.\n     * @returns {string[]} The entities.\n     */\n    setEntities(entities) {\n        this.entities = entities;\n        return entities;\n    }\n    /**\n     * Sets the inputs.\n     *\n     * @param {Inputs} inputs - The inputs to set.\n     * @returns {Inputs} The inputs.\n     */\n    setInputs(inputs) {\n        this.inputs = inputs;\n        return inputs;\n    }\n    /**\n     * Stores an actor ID.\n     *\n     * @param {string} id - The ID of the actor to store.\n     * @returns {boolean} True if the actor ID was stored, false otherwise.\n     */\n    storeActor(id) {\n        const actors = this.actors;\n        return this.storeId(actors, id);\n    }\n    /**\n     * Stores a component.\n     *\n     * @param {string} id - The ID of the component to store.\n     * @param {string} key - The key of the component to store.\n     * @param {any} value - The value of the component to store.\n     */\n    storeComponent(id, key, value) {\n        const prevValue = this.components[id][key];\n        this.components[id][key] = value;\n        this.updateComponentsIndex(id, key, prevValue, value);\n    }\n    /**\n     * Stores an entity ID.\n     *\n     * @param {string} id - The ID of the entity to store.\n     * @returns {boolean} True if the entity ID was stored, false otherwise.\n     */\n    storeEntity(id) {\n        const entities = this.entities;\n        return this.storeId(entities, id);\n    }\n    /**\n     * Stores an ID in a list if it doesn't exist already.\n     *\n     * @param {string[]} list - The list to store the ID in.\n     * @param {string} id - The ID to store.\n     * @returns {boolean} True if the ID was stored, false otherwise.\n     */\n    storeId(list, id) {\n        const [index, left] = binarySearch(list, id);\n        if (index === -1) {\n            list.splice(left, 0, id);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Stores an input.\n     *\n     * @param {string} id - The ID of the input to store.\n     * @param {InputPayload} input - The payload of the input to store.\n     * @returns {number} The new index of the stored input.\n     */\n    storeInput(id, input, tick = 0) {\n        const inputs = this.inputs;\n        inputs[id] = inputs[id] || [];\n        const index = inputs[id].length;\n        if (input.id === id) {\n            delete input.id;\n        }\n        inputs[id].push(tick ? [input, tick] : input);\n        return index;\n    }\n    /**\n     * Queries the store for entities by component.\n     *\n     * @param {any} query - The query to use.\n     * @returns {Set<any>} The entities.\n     */\n    queryComponents(query) {\n        return this.componentsIndex.query(query);\n    }\n    /**\n     * Removes a component from the components index.\n     *\n     * @param {string} id - The ID of the component to remove.\n     * @param {string} key - The key of the component to remove.\n     * @param {any} prevValue - The previous value of the component.\n     * @returns {void}\n     */\n    removeComponentsIndex(id, key, prevValue) {\n        this.componentsIndex.remove(id, key);\n        if (this.indexes[key]) {\n            const index = this.indexes[key];\n            if (this.isActor(id)) {\n                index.actors.remove(id, prevValue);\n            }\n            else {\n                index.entities.remove(id, prevValue);\n            }\n        }\n    }\n    /**\n     * Updates a component in the components index.\n     *\n     * @param {string} id - The ID of the component to update.\n     * @param {string} key - The key of the component to update.\n     * @param {any} prevValue - The previous value of the component.\n     * @param {any} value - The new value of the component.\n     * @returns {void}\n     */\n    updateComponentsIndex(id, key, prevValue, value) {\n        this.componentsIndex.set(id, key);\n        if (this.indexes[key]) {\n            const index = this.indexes[key];\n            if (this.isActor(id)) {\n                index.actors.store(id, prevValue, value);\n            }\n            else {\n                index.entities.store(id, prevValue, value);\n            }\n        }\n    }\n}\nexport default Storage;\n","import { createEnum } from './utils.js';\n/**\n * The Symbols class represents a collection of symbols.\n */\nexport class Symbols {\n    _list;\n    _enum;\n    /**\n     * Constructs a new Symbols object.\n     *\n     * @param {object} object - An object containing an optional list of symbols.\n     */\n    constructor(object = {}) {\n        const { _list: symbols = [] } = object;\n        this._list = symbols;\n        this._enum = createEnum(symbols);\n    }\n    /**\n     * Adds a symbol to the Symbols object.\n     *\n     * @param {string} symbol - The symbol to be added.\n     * @returns {number | null} The index of the added symbol, or null if the symbol is not valid.\n     */\n    add(symbol) {\n        if (symbol) {\n            if (Object.prototype.hasOwnProperty.call(this._enum, symbol)) {\n                return this._enum[symbol];\n            }\n            else {\n                const end = this._list.length;\n                this._list[end] = symbol;\n                this._enum[symbol] = end;\n                return end;\n            }\n        }\n        return null;\n    }\n    /**\n     * Copies an enum into the Symbols object.\n     *\n     * @param {Enum} enumObj - The enum to be copied.\n     */\n    copyEnum(enumObj = {}) {\n        for (const symbolTuple of Object.entries(enumObj)) {\n            this.merge(symbolTuple);\n        }\n    }\n    /**\n     * Fetches a symbol and its index based on a payload.\n     *\n     * @param {number | string} payload - The payload, which can be either a symbol or an index.\n     * @returns {[string, number]} A tuple containing the symbol and its index.\n     */\n    fetch(payload) {\n        let index;\n        let symbol;\n        switch (typeof payload) {\n            case 'number':\n                index = payload;\n                symbol = this._list[index] || '';\n                break;\n            case 'string':\n                symbol = payload;\n                index = Object.prototype.hasOwnProperty.call(this._enum, symbol) ? this._enum[symbol] : -1;\n                break;\n        }\n        return [symbol, index];\n    }\n    /**\n     * Finds the index of a symbol.\n     *\n     * @param {string} symbol - The symbol to be found.\n     * @returns {number | undefined} The index of the symbol, or undefined if the symbol is not found.\n     */\n    find(symbol) {\n        return this._enum[symbol];\n    }\n    /**\n     * Gets the symbol at a specific index.\n     *\n     * @param {number} index - The index of the symbol.\n     * @returns {string | undefined} The symbol at the specified index, or undefined if there is no symbol at that index.\n     */\n    get(index) {\n        return this._list[index];\n    }\n    /**\n     * Returns the list of symbols.\n     *\n     * @returns {string[]} The list of symbols.\n     */\n    getSymbols() {\n        return this._list;\n    }\n    /**\n     * Returns the enum of symbols.\n     *\n     * @returns {Enum} The enum of symbols.\n     */\n    getSymbolsEnum() {\n        return this._enum;\n    }\n    /**\n     * Merges a symbol tuple into the Symbols object.\n     *\n     * @param {[string, number]} symbolTuple - The symbol tuple to be merged.\n     */\n    merge(symbolTuple) {\n        const [symbol, index] = symbolTuple;\n        this._list[index] = symbol;\n        this._enum[symbol] = index;\n    }\n    /**\n     * Resets the Symbols object with a new array of symbols.\n     *\n     * @param {string[]} symbolsArray - The new array of symbols.\n     */\n    reset(offset, symbolsArray = []) {\n        if (offset > 0) {\n            const { length } = symbolsArray;\n            const { _list } = this;\n            const { _enum } = this;\n            for (let i = 0; i < length; i++) {\n                const symbol = symbolsArray[i];\n                const index = i + offset;\n                _list[index] = symbol;\n                _enum[symbol] = index;\n            }\n        }\n        else {\n            this._list = symbolsArray;\n            this._enum = createEnum(symbolsArray);\n        }\n    }\n}\nexport default Symbols;\n/**\n * Extracts a symbol from a given index.\n *\n * @param {number | string} index - The index or symbol to be extracted.\n * @param {any} context - The context in which the symbol is to be extracted.\n * @param {any} options - The options for extracting the symbol.\n * @returns {string | number} The extracted symbol.\n */\nexport function extractSymbol(index, context, options) {\n    if (typeof index === 'number') {\n        const { actions } = options;\n        const { getSymbol } = actions;\n        const symbol = getSymbol(index, context, options);\n        if (!symbol) {\n            return '';\n        }\n        index = symbol;\n    }\n    return index;\n}\n/**\n * Ensures that a symbol is indexed.\n *\n * @param {number | string} symbol - The symbol to be indexed.\n * @param {any} context - The context in which the symbol is to be indexed.\n * @param {any} options - The options for indexing the symbol.\n * @returns {number | string} The indexed symbol.\n */\nexport function ensureSymbolIndex(symbol, context, options) {\n    if (typeof symbol === 'string') {\n        const { actions } = options;\n        const { addSymbol } = actions;\n        const index = addSymbol(symbol, context, options);\n        if (typeof index === 'number') {\n            return index;\n        }\n    }\n    return symbol;\n}\n/**\n * Recursively extracts symbols from a given value.\n *\n * @param {string} key - The key associated with the value.\n * @param {any} value - The value from which symbols are to be extracted.\n * @param {any} context - The context in which the symbols are to be extracted.\n * @param {any} options - The options for extracting symbols.\n * @returns {any} The value with extracted symbols.\n */\nexport function recursiveSymbolExtraction(key, value, context, options) {\n    if (key.charAt(0) === '$') {\n        const { actions } = options;\n        const { getSymbol } = actions;\n        const recursiveFix = (value) => {\n            if (Array.isArray(value)) {\n                value = value.map(recursiveFix);\n            }\n            else {\n                switch (typeof value) {\n                    case 'number': {\n                        const symbol = getSymbol(value, context, options);\n                        if (symbol) {\n                            value = symbol;\n                        }\n                        break;\n                    }\n                    case 'object':\n                        for (const key in value) {\n                            value[key] = recursiveFix(value[key]);\n                        }\n                        break;\n                }\n                return value;\n            }\n        };\n        return recursiveFix(value);\n    }\n    return value;\n}\n/**\n * Recursively ensures that symbols in a given value are indexed.\n *\n * @param {string} key - The key associated with the value.\n * @param {any} value - The value in which symbols are to be indexed.\n * @param {any} context - The context in which the symbols are to be indexed.\n * @param {any} options - The options for indexing symbols.\n * @returns {any} The value with indexed symbols.\n */\nexport function recursiveSymbolIndexesEnsured(key, value, context, options) {\n    if (key.charAt(0) === '$') {\n        const { actions } = options;\n        const { addSymbol } = actions;\n        const recursiveFix = (value) => {\n            if (Array.isArray(value)) {\n                value = value.map(recursiveFix);\n            }\n            else {\n                switch (typeof value) {\n                    case 'string': {\n                        const symbol = addSymbol(value, context, options);\n                        if (typeof symbol === 'number') {\n                            value = symbol;\n                        }\n                        break;\n                    }\n                    case 'object':\n                        for (const key in value) {\n                            value[key] = recursiveFix(value[key]);\n                        }\n                        break;\n                }\n                return value;\n            }\n        };\n        return recursiveFix(value);\n    }\n    return value;\n}\n","export const BasicTypes = new Map([\n    // ['eid', Uint32Array],\n    // ['sid', Uint32Array],\n    // ['sym', String],\n    ['str', String],\n    ['num', Number],\n    ['bool', Boolean],\n    ['map', Map],\n    ['set', Set],\n    ['arr', Array],\n]);\nexport const ArrayTypes = new Map([\n    ['i8', Int8Array],\n    ['ui8', Uint8Array],\n    ['ui8c', Uint8ClampedArray],\n    ['i16', Int16Array],\n    ['ui16', Uint16Array],\n    ['i32', Int32Array],\n    ['ui32', Uint32Array],\n    ['f32', Float32Array],\n    ['f64', Float64Array],\n]);\n","import { Options } from './options.js';\nimport { ensureSymbolIndex, recursiveSymbolIndexesEnsured } from './symbols.js';\nimport { ArrayTypes } from './types.js';\nimport { now, concatTypedArray } from './utils.js';\n/**\n * The updater function updates the context based on the provided options.\n *\n * @param {Context} context - The current context.\n * @param {Options | any} options - The options for updating the context.\n * @param {number} tick - The current tick.\n * @returns {Promise<any[]>} A promise that resolves to an array of arrays, where each sub-array represents a batch of updates. This is only relevant if the `batched` option is enabled.\n */\nexport async function updater(context, options, tick = now()) {\n    options = options instanceof Options ? options : new Options(options);\n    const { responder, enumDefaultSymbols, compressStringsAsInts, enableRollback, isOrdered, isDiffed, isGroupedComponents, isAsyncStorage, types, setGroupedValue, updateOptions } = options;\n    const { batched, batchSize, mask, type, validKeys } = updateOptions;\n    if (!context.pending) {\n        return [];\n    }\n    /**\n     * An array of arrays, where each sub-array represents a batch of updates.\n    */\n    const batch = [];\n    /**\n     * An array representing the current batch of updates.\n    */\n    let batchBlock = [];\n    const { created = {}, removed = {}, symbols = [], updated = {} } = context.pending;\n    const store = context.store;\n    /**\n     * Merges the current batch block into the batch array.\n     *\n     * @param {string | number} action - The action associated with the current batch block.\n     */\n    const mergeBatch = (action) => {\n        if (batched && batchBlock.length) {\n            batch.push([action, ...batchBlock]);\n            batchBlock = [];\n        }\n    };\n    /**\n     * Queues a message for later processing.\n     *\n     * @param {string | number} action - The action associated with the message.\n     * @param {any} payload - The payload of the message.\n     */\n    const queueMessage = (action, payload) => {\n        if (batched) {\n            // batchBlock.push(payload)\n            batchBlock = batchBlock.concat(payload);\n            if (batchBlock.length >= batchSize) {\n                mergeBatch(action);\n            }\n        }\n        else {\n            if (compressStringsAsInts) {\n                action = ensureSymbolIndex(action, context, options);\n            }\n            responder([action, payload], type);\n        }\n    };\n    /**\n     * Ensures that a symbol is indexed if the `compressStringsAsInts` option is enabled.\n     *\n     * @param {string | number} symbol - The symbol to be indexed.\n     * @returns {string | number} The indexed symbol, or the original symbol if `compressStringsAsInts` is not enabled.\n     */\n    const ensureSymbol = (symbol) => {\n        if (compressStringsAsInts) {\n            symbol = ensureSymbolIndex(symbol, context, options);\n        }\n        return symbol;\n    };\n    const upsertComponents = async (pendingComponents = {}, state) => {\n        const groups = isGroupedComponents ? {} : null;\n        for (const id in (pendingComponents ?? {})) {\n            const components = isAsyncStorage ? await store.findComponents(id) : store.findComponents(id);\n            if (!components) {\n                break;\n            }\n            const updatedComponents = pendingComponents ? pendingComponents[id] : {};\n            for (const key in (updatedComponents ?? {})) {\n                if (validKeys && !validKeys[key]) {\n                    break;\n                }\n                const type = types[key] ?? null;\n                const Type = type ? ArrayTypes.get(Array.isArray(type) ? type[0] : type) : null;\n                let group = null;\n                if (groups) {\n                    group = groups[key] = groups[key] ?? {\n                        key,\n                        ids: compressStringsAsInts ? new Uint32Array(0) : [],\n                        intIds: true,\n                        values: Type ? new Type(0) : [],\n                        ticks: new Uint32Array(0),\n                    };\n                }\n                let value = isAsyncStorage ? await store.findComponent(id, key) : store.findComponent(id, key);\n                if (isDiffed && context.changes && (state === 'updated' || !true)) {\n                    value = context.changes.getValue(id, key, value);\n                }\n                if (compressStringsAsInts) {\n                    value = recursiveSymbolIndexesEnsured(key, value, context, options);\n                }\n                const nid = ensureSymbol(id);\n                const nkey = ensureSymbol(key);\n                if (groups) {\n                    group.ids = compressStringsAsInts\n                        ? concatTypedArray(group.ids, [nid])\n                        : group.ids.concat([id]);\n                    if (nid === id) {\n                        group.intIds = false;\n                    }\n                    group.values = Type\n                        ? concatTypedArray(group.values, setGroupedValue(value, types, key))\n                        : group.values.concat(setGroupedValue(value, types, key));\n                    if (isOrdered) {\n                        group.ticks = concatTypedArray(group.ticks, [isDiffed ? -tick : tick]);\n                    }\n                    continue;\n                }\n                const payload = [nid, nkey, value];\n                if (isOrdered) {\n                    payload.push(isDiffed ? -tick : tick);\n                }\n                if (isDiffed) {\n                    queueMessage(enumDefaultSymbols.changeComponent, payload);\n                }\n                else {\n                    queueMessage(enumDefaultSymbols.upsertComponent, payload);\n                }\n            }\n            // delete pendingComponents[id];\n        }\n        if (groups) {\n            for (const key in groups) {\n                const group = groups[key];\n                const bufferIds = compressStringsAsInts && group.intIds ? new Uint32Array(group.ids) : group.ids;\n                const type = types[key] ?? null;\n                const Type = type ? ArrayTypes.get(Array.isArray(type) ? type[0] : type) : null;\n                const bufferValues = Type ? new Type(group.values) : group.values;\n                let i = 0;\n                const size = bufferIds.length;\n                for (; i < size; i += batchSize) {\n                    const payload = [\n                        bufferIds.slice(i, i + batchSize),\n                        group.key,\n                        bufferValues.slice(i, i + batchSize)\n                    ];\n                    if (isOrdered) {\n                        const bufferTicks = new Uint32Array(group.ticks.slice(i, i + batchSize));\n                        payload.push(bufferTicks);\n                    }\n                    if (isDiffed) {\n                        queueMessage(enumDefaultSymbols.changeComponent, payload);\n                    }\n                    else {\n                        queueMessage(enumDefaultSymbols.upsertComponent, payload);\n                    }\n                }\n            }\n        }\n        mergeBatch(isDiffed ? enumDefaultSymbols.changeComponent : enumDefaultSymbols.upsertComponent);\n    };\n    /**\n     * If the `mask` object does not exist or does not have an `entities` property,\n     * this code block ensures that each entity in the `created.entities` array is indexed,\n     * queues a message to create each entity, merges the batch of messages, and then clears the `created.entities` array.\n     */\n    if (!mask || !mask.entities) {\n        for (const key of created.entities ?? []) {\n            const nkey = ensureSymbol(key);\n            queueMessage(enumDefaultSymbols.createEntity, nkey);\n        }\n        mergeBatch(enumDefaultSymbols.createEntity);\n        created.entities = [];\n    }\n    /**\n     * If the `mask` object does not exist or does not have an `actors` property,\n     * this code block ensures that each actor in the `created.actors` array is indexed,\n     * queues a message to spawn each actor, merges the batch of messages, and then clears the `created.actors` array.\n     */\n    if (!mask || !mask.actors) {\n        for (const id in (created.actors ?? {})) {\n            const nid = ensureSymbol(id);\n            queueMessage(enumDefaultSymbols.spawnActor, nid);\n        }\n        mergeBatch(enumDefaultSymbols.spawnActor);\n        created.actors = {};\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `removed.components` object is indexed,\n     * queues a message to remove each component, merges the batch of messages, and then clears the `removed.components` object.\n     */\n    if (!mask || !mask.entities) {\n        for (const key of removed.entities ?? []) {\n            const nkey = ensureSymbol(key);\n            queueMessage(enumDefaultSymbols.removeEntity, nkey);\n        }\n        mergeBatch(enumDefaultSymbols.removeEntity);\n        removed.entities = [];\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `removed.components` object is indexed,\n     * queues a message to remove each component, merges the batch of messages, and then clears the `removed.components` object.\n     */\n    if (!mask || !mask.actors) {\n        for (const id in (removed.actors ?? {})) {\n            const nid = ensureSymbol(id);\n            queueMessage(enumDefaultSymbols.removeActor, nid);\n        }\n        mergeBatch(enumDefaultSymbols.removeActor);\n        removed.actors = {};\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `removed.components` object is indexed,\n     * queues a message to remove each component, merges the batch of messages, and then clears the `removed.components` object.\n     */\n    if (!mask || !mask.components) {\n        for (const id in (removed.components ?? {})) {\n            const components = removed?.components ? removed.components[id] : null;\n            if (!components) {\n                break;\n            }\n            const nid = ensureSymbol(id);\n            for (const key in components) {\n                if (validKeys && !validKeys[key]) {\n                    break;\n                }\n                const nkey = ensureSymbol(key);\n                const payload = [nid, nkey];\n                queueMessage(enumDefaultSymbols.removeComponent, payload);\n            }\n            // delete removed.components[key]\n        }\n        mergeBatch(enumDefaultSymbols.removeComponent);\n        removed.components = {};\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `created.components` object is indexed,\n     * queues a message to create each component, merges the batch of messages, and then clears the `created.components` object.\n     */\n    if (!mask || !mask.components) {\n        const promise = upsertComponents(created.components, 'created');\n        created.components = {};\n        await promise;\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `components` property,\n     * this code block ensures that each component in the `updated.components` object is indexed,\n     * queues a message to update each component, merges the batch of messages, and then clears the `updated.components` object.\n     */\n    if (!mask || !mask.components) {\n        const promise = upsertComponents(updated.components, 'updated');\n        updated.components = {};\n        await promise;\n    }\n    /**\n     * If the `mask` object does not exist or does not have an `inputs` property,\n     * this code block ensures that each input in the `created.inputs` object is indexed,\n     * queues a message to create each input, merges the batch of messages, and then clears the `created.inputs` object.\n     */\n    if (!mask || !mask.inputs) {\n        for (const id in (created.inputs ?? {})) {\n            // const nid = ensureSymbol(id)\n            const createdInputs = created?.inputs ? (created.inputs[id] ?? []) : [];\n            for (let i = 0; i < createdInputs.length; i += 1) {\n                const index = createdInputs[i];\n                const payload = isAsyncStorage ? await store.findInput(id, index) : store.findInput(id, index);\n                const isTuple = Array.isArray(payload);\n                const input = isTuple ? payload[0] : payload;\n                const tick_ = isTuple ? payload[1] : tick;\n                queueMessage(enumDefaultSymbols.actorInput, isTuple || enableRollback ? [input, tick_] : input);\n            }\n            // delete created.inputs[id];\n        }\n        mergeBatch(enumDefaultSymbols.actorInput);\n        created.inputs = {};\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `symbols` property,\n     * this code block ensures that each symbol in the `symbols` array is indexed,\n     * queues a message to add each symbol, merges the batch of messages, and then clears the `symbols` array.\n     */\n    if (!mask || !mask.symbols) {\n        for (const symbolOp of symbols) {\n            if (batched) {\n                batchBlock.push(symbolOp);\n            }\n            else {\n                const message = [enumDefaultSymbols.mergeSymbol, symbolOp];\n                await responder(message, type);\n            }\n            if (batchBlock.length >= batchSize && batchBlock.length) {\n                batch.unshift([enumDefaultSymbols.mergeSymbol].concat(batchBlock));\n                batchBlock = [];\n            }\n        }\n        if (batched && batchBlock.length) {\n            batch.unshift([enumDefaultSymbols.mergeSymbol].concat(batchBlock));\n            batchBlock = [];\n        }\n        context.pending.symbols = [];\n    }\n    /**\n     * If the `mask` object does not exist or does not have a `symbols` property,\n     * this code block ensures that each symbol in the `symbols` array is indexed,\n     * queues a message to add each symbol, merges the batch of messages, and then clears the `symbols` array.\n     */\n    if (batched && batch.length) {\n        for (let i = 0; i < batch.length; i += 1) {\n            const batchSlice = batch[i];\n            if (batchSlice) {\n                await responder([enumDefaultSymbols.batch, batchSlice]);\n                // if (batchSlice.length > 1) {\n                //   responder([enumDefaultSymbols.batch].concat(batchSlice))\n                // } else {\n                //   responder(batchSlice)\n                // }\n            }\n        }\n    }\n    return batch;\n}\nexport default updater;\n","/**\n * @returns {number} The current time in milliseconds.\n */\nexport function now() {\n    return performance.timeOrigin + performance.now();\n}\n/**\n * Concatenates two typed arrays or arrays.\n *\n * @param {TypedArray | any[]} a - The first typed array or array.\n * @param {TypedArray | any[]} b - The second typed array or array.\n * @returns {TypedArray | any[]} The concatenated typed array or array.\n */\nexport function concatTypedArray(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        return a.concat(b);\n    }\n    else if (Array.isArray(a)) {\n        const a_ = new b.constructor(a.length);\n        a_.set(a);\n        a = a_;\n    }\n    else if (Array.isArray(b)) {\n        const b_ = new a.constructor(b.length);\n        b_.set(b);\n        b = b_;\n    }\n    const c = new a.constructor(a.length + b.length);\n    if (c.set) {\n        c.set(a);\n        c.set(b, a.length);\n    }\n    return c;\n}\n/**\n * Creates a union of multiple sets or arrays.\n *\n * @param {...Array<SetOrArray<any>>} sets - The sets or arrays to be united.\n * @returns {Array<string>} The union of the sets or arrays.\n */\nexport function unionSetOrArray(...sets) {\n    const union = {};\n    for (const set of sets) {\n        if (set) {\n            for (const v of set) {\n                union[v] = true;\n            }\n        }\n    }\n    return Object.keys(union);\n}\n/**\n * Creates an union of two sets.\n *\n * @param {SetExperimental} setA - The first set.\n * @param {SetExperimental} setB - The second set.\n * @returns {Set<any>} The union of the sets.\n */\nexport function unionSets(setA, setB) {\n    if (typeof setA.union === 'function') {\n        return setA.union(setA);\n    }\n    const union = new Set();\n    for (const v of setA)\n        union.add(v);\n    for (const v of setB)\n        union.add(v);\n    return union;\n}\n/**\n * Creates an difference of the two sets.\n *\n * @param {SetExperimental} setA - The first set.\n * @param {SetExperimental} setB - The second set.\n * @returns {Set<any>} The difference of the sets.\n */\nexport function differenceSets(setA, setB) {\n    if (typeof setA.difference === 'function') {\n        return setA.difference(setA);\n    }\n    const difference = new Set();\n    for (const v of setA)\n        if (!setB.has(v))\n            difference.add(v);\n    return difference;\n}\n/**\n * Creates an intersection of the two sets.\n *\n * @param {SetExperimental} setA - The first set.\n * @param {SetExperimental} setB - The second set.\n * @returns {Set<any>} The intersection of the sets.\n */\nexport function intersectionSets(setA, setB) {\n    if (typeof setA.intersection === 'function') {\n        return setA.intersection(setA);\n    }\n    const intersection = new Set();\n    for (const v of setA)\n        if (setB.has(v))\n            intersection.add(v);\n    return intersection;\n}\n/**\n * binaryInsert finds the index of where a value should be inserted into a sorted array.\n *\n * @param {any[]} items - The sorted array\n * @param {any} value - The value to insert\n * @param {Function} getValue - The function to get the value from the item\n * @returns {number} The index of where the value should be inserted\n */\nexport function binaryInsert(items, value, getValue = (v) => v) {\n    let low = 0;\n    let high = items.length;\n    while (low < high) {\n        const mid = (low + high) >>> 1;\n        const item = items[mid];\n        const v = getValue(item);\n        if (v < value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\n/**\n * binarySearch finds the index of a value in a sorted array.\n *\n * @param {any[]} items - The sorted array\n * @param {any} target - The value to find\n * @param {Function} getValue - The function to get the value from the item\n * @returns {number[]} The index of the value\n */\nexport function binarySearch(items, target, getValue = (v) => v) {\n    let left = 0;\n    let right = items.length - 1;\n    while (left <= right) {\n        const mid = (left + right) >>> 1;\n        const item = items[mid];\n        const v = getValue(item);\n        if (v === target) {\n            return [mid, left];\n        }\n        else if (v < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    return [-1, left];\n}\n/**\n * Creates an enum from a set or an array.\n *\n * @param {SetOrArray<any>} set - The set or array from which the enum is to be created.\n * @param {number} offset - The starting value of the enum.\n * @returns {Record<string, number>} The created enum.\n */\nexport function createEnum(set, offset = 0) {\n    const _enum = {};\n    let i = offset;\n    if (set) {\n        for (const v of set) {\n            _enum[v] = i++;\n        }\n    }\n    return _enum;\n}\n/**\n * Creates a tuple from a message.\n *\n * @param {{ action?: any, payload?: any }} message - The message from which the tuple is to be created.\n * @returns {Array<any>} The created tuple.\n */\nexport function messageTuple(message) {\n    return [message?.action, message?.payload];\n}\n/**\n * Split an array into pages\n *\n * @param {Iterable<any> | any[]} array - The array to be split into pages.\n * @param {number} pageSize - The size of each page.\n * @returns {any[][]} The array of pages.\n */\nexport function paginate(array, pageSize) {\n    if (pageSize === Infinity && Array.isArray(array) && array.length > 0) {\n        return [array];\n    }\n    const pages = [];\n    let page = [];\n    let i = 0;\n    // if (!Array.isArray(array)) {\n    //   throw new Error('paginate: array must be an array');\n    // }\n    for (const v of array) {\n        if (i >= pageSize) {\n            pages.push(page);\n            page = [];\n            i = 0;\n        }\n        page.push(v);\n        i++;\n    }\n    if (page.length > 0) {\n        pages.push(page);\n    }\n    return pages;\n}\n/**\n * Determines the type of a value.\n *\n * @param {any} v - The value whose type is to be determined.\n * @returns {string} The type of the value.\n */\nexport function typeOf(v) {\n    const t = typeof v;\n    if (t === 'object') {\n        if (!v) {\n            return 'null';\n        }\n        else if (Array.isArray(v)) {\n            return 'array';\n        }\n    }\n    return t;\n}\n/**\n * Combines two values.\n *\n * @param {any} objA - The first value.\n * @param {any} objB - The second value.\n * @returns {[boolean, any]} A tuple where the first element is a boolean indicating whether the values were combined, and the second element is the combined value.\n */\nexport function combineValues(objA, objB) {\n    return recursiveCombination(objA, objB);\n}\n/**\n * Recursively combines two objects or arrays and returns the result.\n * If the combination is successful, it returns a tuple with a boolean indicating success and the combined object/array.\n * If the combination fails, it returns a tuple with a boolean indicating failure and the second object/array.\n * @param objA - The first object/array to combine.\n * @param objB - The second object/array to combine.\n * @returns A tuple with a boolean indicating success/failure and the combined object/array.\n */\nexport function recursiveCombination(objA, objB) {\n    const typeA = typeOf(objA);\n    const typeB = typeOf(objB);\n    switch (typeB) {\n        case 'bigint':\n        case 'number': {\n            if (typeA !== 'number' && typeA !== 'bigint') {\n                return [false, objB];\n            }\n            return [true, objA + objB];\n        }\n        case 'array': {\n            if (typeA !== 'array') {\n                return [false, objB];\n            }\n            const newArr = [];\n            let combined = true;\n            for (let i = 0; i < objB.length; i += 1) {\n                const [c, value] = recursiveCombination(objA[i], objB[i]);\n                newArr[i] = value;\n                if (c === false) {\n                    combined = false;\n                }\n            }\n            return [combined, newArr];\n        }\n        case 'object': {\n            if (typeA !== 'object') {\n                return [false, objB];\n            }\n            const newObj = {};\n            let combined = true;\n            for (const k in objB) {\n                const [c, value] = recursiveCombination(objA[k], objB[k]);\n                if (c === false) {\n                    combined = false;\n                }\n                newObj[k] = value;\n            }\n            return [combined, newObj];\n        }\n        default:\n            return [false, objB];\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".echo-d.min.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t647: 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = Object(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : this)[\"webpackChunkechoD\"] = Object(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : this)[\"webpackChunkechoD\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","import nodeActions, { NodeActions } from './node.js';\nexport class ClientActions extends NodeActions {\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    actors() { }\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    components() { }\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    entities() { }\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    symbol() { }\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    symbols() { }\n}\n/**\n * An object that maps the names of actions.\n */\nexport const actions = {\n    /**\n     * The actions related to nodes, imported from the node module.\n     */\n    ...nodeActions,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    actors: null,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    components: null,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    entities: null,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    symbol: null,\n    /**\n     * Disable actions that should not be handled on the client.\n     */\n    symbols: null\n};\nexport default actions;\n","/**\n * Exports all the constants.\n */\nexport * from './constants.js';\n// Index Classes\n/**\n * Exports all the indexes-related functions and classes.\n */\nexport * from './indexes/index.js';\n/**\n * Exports all the indexes-related functions and classes.\n */\nexport * from './indexes/sorted.js';\n/**\n * Exports all the indexes-related functions and classes.\n */\nexport * from './indexes/spatial.js';\n// Main Classes\n/**\n * Exports all the actions-related functions and classes.\n */\nexport * from './changes.js';\n/**\n * Exports all the context-related functions and classes.\n*/\nexport * from './context.js';\n/**\n * Exports all the actions-related functions and classes.\n */\nexport * from './emitter.js';\n/**\n * Exports all the handler-related functions and classes.\n */\nexport * from './handler.js';\n/**\n * Exports all the options-related functions and classes.\n */\nexport * from './options.js';\n/**\n * Exports all the actions-related functions and classes.\n */\nexport * from './ordered.js';\n/**\n * Exports all the pending-related functions and classes.\n */\nexport * from './pending.js';\n/**\n * Exports all the store-related functions and classes.\n */\nexport * from './storage.js';\n/**\n * Exports all the symbols-related functions and classes.\n */\nexport * from './symbols.js';\n/**\n * Exports all the types-related functions and classes.\n */\nexport * from './types.js';\n// Utils\n/**\n * Exports all the updater-related functions and classes.\n */\nexport * from './updater.js';\n/**\n * Exports all the utility functions.\n */\nexport * as utils from './utils.js';\n// Node Actions\n/**\n * Exports all the node-related functions and classes.\n */\nexport * as Node from './node.js';\n/**\n * Exports all the client-related functions and classes.\n */\nexport * as Client from './client.js';\n// Action Modules\n/**\n * Exports all the actions-related functions and classes.\n */\nexport * as Actor from './actions/actor.js';\n/**\n * Exports all the component-related functions and classes.\n */\nexport * as Component from './actions/component.js';\n/**\n * Exports all the core-related functions and classes.\n */\nexport * as Core from './actions/core.js';\n/**\n * Exports all the entity-related functions and classes.\n */\nexport * as Entitity from './actions/entity.js';\n/**\n * Exports all the entity-related functions and classes.\n */\nexport * as Symbol from './actions/symbol.js';\n// default export is the Handler class\nimport Handler from './handler.js';\nexport default Handler;\n"],"names":["root","factory","exports","module","define","amd","window","global","self","this","webpackQueues","webpackExports","webpackError","resolveQueue","deferred","leafPrototypes","getProto","inProgress","dataWebpackPrefix","ActorActionsFactory","Parent","Object","actorInput","payload","context","options","getActorId","compressStringsAsInts","input","tick","Array","isArray","id","actors","responder","isAuthority","isAsyncStorage","pageSize","enableQuerying","enumDefaultSymbols","sendActors","pages","page","mergeActors","ctxActors","getActors","emitTo","removeActor","skipPending","spawnActor","ActorActions","__ActorActions__","actions","ComponentActionsFactory","changeComponent","types","isOrdered","key","value","type","String","components","sendComponents","mergeComponents","ctxComponents","getComponents","removeComponent","upsertComponent","ComponentActions","__ComponentActions__","CoreActionsFactory","batch","CoreActions","EntityActionsFactory","createEntity","entities","sendEntities","mergeEntities","ctxEntities","getEntities","removeEntity","EntityActions","__EntityActions__","SymbolActionsFactory","addSymbol","symbol","fetchSymbol","symbolTuple","mergeSymbol","getSymbol","index","mergeSymbols","offset","symbols","length","resetSymbols","enumSymbols","symbolsEnum","prototype","hasOwnProperty","call","_","symbolsList","paginate","i","SymbolActions","__SymbolActions__","Changes","diffs","constructor","changes","newValue","prevValue","getValue","storedValue","diffedValue","reset","_prevValue","currentScopeOrPromise","store","findComponents","promises","completeUpsertComponent","currentScope","promise","storeComponent","Promise","push","diffObject","recursiveDiff","diff","scope","currVal","nextVal","prevType","typeOf","nextType","d","toString","k","resolve","reject","then","all","Actions","CommonComponents","DefaultSymbols","unionSetOrArray","padEnum","enumActions","createEnum","enumCommonComponents","batchActionPayloadSizes","default","rollback","ordered","defaultOptions","enableRollback","isComponentRelay","isDiffed","isGroupedComponents","isReadOnly","isSymbolLeader","isSymbolRelay","indexes","position","asset","collider","color","hidden","rotation","velocity","spin","size","defaultUpdateOptions","mask","inputs","batched","batchSize","defaultValidKeys","voidResponder","defaultGetActorId","_context","defaultGetGroupedValue","slice","defaultSetGroupedValue","_types","_key","Context","static","_Storage","events","order","pending","allActions","storeOptions","copyEnum","undefined","Infinity","query","onUpdate","addedOrPromise","storeActor","completeActorInput","added","emit","removedOrPromise","destroyActor","completeRemoveActor","removed","nextOptions","extend","completeMergeActors","storeEntity","completeCreateEntity","destroyEntity","completeRemoveEntity","completeMergeEntities","getGroupedValue","completeChangeComponentUpdate","Uint32Array","Error","noUpdateOptions","val","currentValueOrPromise","findComponent","completeChangeComponents","currentValue","pendingType","nextValue","combineValues","completeChangeComponentStorage","completeUpsertComponentUpdate","completeUpsertComponentStorage","completeRemoveComponent","destroyComponent","nextPayload","completeMergeComponents","getInputs","now","indexOrPromise","storeInput","getSymbols","getSymbolsEnum","setSymbols","get","add","onMatch","fetch","merge","replaceSymbols","resetFrame","Emitter","handlers","emissions","handlersDone","emissionsDone","handler","emission","cleanup","clear","done","removeHandler","indexOf","splice","removeEmission","getSymbolAction","action","defaultSymbols","getActionHandler","oneHandler","message","actionHandler","manyHandler","iterator","payloadSize","Handler","one","extendOptions","many","updater","queryComponents","Index","items","_options","clone","_value","has","_id","remove","set","preValue","_query","SortedIndex","super","item","find","low","binaryInsert","ids","lastIndexOf","binaryRemoveID","binaryInsertID","SpatialIndex","cellSize","hash","hash2d","hash3d","x","y","Math","floor","z","binarySearch","left","results","o","xx","yy","concat","zz","AllActionsFactory","NodeActions","__NodeActions__","Options","setGroupedValue","updateOptions","worldOptions","actionsThis","overridenUpdateOptions","validKeys","actionThis","Ordered","isNaN","isFinite","threshold","Pending","created","updated","_symbols","map","v","ComponentsIndex","delete","Set","union","other","unionSets","difference","differenceSets","intersection","intersectionSets","with","with_","without","matches","IndexMap","sorted","spatial","createStorageProps","props","storage","typeCtors","TypeCtor","componentsIndex","IndexCtor","Storage","destroyId","removeComponentsIndex","list","findInputs","findInput","forEach","keys","object","isActor","isEntity","setActors","setComponents","setEntities","setInputs","storeId","updateComponentsIndex","Symbols","_list","_enum","end","enumObj","entries","symbolsArray","extractSymbol","ensureSymbolIndex","recursiveSymbolExtraction","charAt","recursiveFix","recursiveSymbolIndexesEnsured","BasicTypes","Map","Number","Boolean","ArrayTypes","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Float32Array","Float64Array","async","batchBlock","mergeBatch","queueMessage","ensureSymbol","upsertComponents","pendingComponents","state","groups","updatedComponents","Type","group","intIds","values","ticks","nid","nkey","concatTypedArray","bufferIds","bufferValues","bufferTicks","createdInputs","isTuple","tick_","symbolOp","unshift","batchSlice","performance","timeOrigin","a","b","a_","b_","c","sets","setA","setB","high","mid","target","right","messageTuple","array","t","objA","objB","recursiveCombination","typeA","newArr","combined","newObj","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","Symbol","queue","fn","r","body","hasAwait","currentDeps","outerResolve","depQueues","rej","deps","dep","obj","e","ret","wrapDeps","getResult","fnQueue","q","err","O","result","chunkIds","priority","notFulfilled","fulfilled","j","every","getPrototypeOf","mode","__esModule","ns","create","def","current","getOwnPropertyNames","definition","defineProperty","enumerable","f","chunkId","reduce","u","g","globalThis","Function","prop","l","url","script","needAttach","scripts","document","getElementsByTagName","s","getAttribute","createElement","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","onerror","onload","clearTimeout","doneFns","parentNode","removeChild","setTimeout","bind","head","appendChild","toStringTag","scriptUrl","importScripts","location","currentScript","replace","p","installedChunks","installedChunkData","error","errorType","realSrc","name","request","webpackJsonpCallback","parentChunkLoadingFunction","data","moreModules","runtime","some","chunkLoadingGlobal","ClientActions","node"],"sourceRoot":""}