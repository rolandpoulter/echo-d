"use strict";(Object("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).webpackChunkechoD=Object("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).webpackChunkechoD||[]).push([[192],{192:(e,t,r)=>{r.d(t,{addComponent:()=>oe,addEntity:()=>P,createWorld:()=>ce,defineComponent:()=>re,removeComponent:()=>ie,removeEntity:()=>Y});var n="ui8",o="ui16",i="ui32",s="eid",a={i8:"Int8",ui8:"Uint8",ui8c:"Uint8Clamped",i16:"Int16",ui16:"Uint16",i32:"Int32",ui32:"Uint32",eid:"Uint32",f32:"Float32",f64:"Float64"},y={i8:Int8Array,ui8:Uint8Array,ui8c:Uint8ClampedArray,i16:Int16Array,ui16:Uint16Array,i32:Int32Array,ui32:Uint32Array,f32:Float32Array,f64:Float64Array,eid:Uint32Array},l=(4,e=>4*Math.ceil(e/4)),u=Symbol("storeRef"),d=Symbol("storeSize"),f=Symbol("storeMaps"),c=Symbol("storeFlattened"),b=Symbol("storeBase"),m=Symbol("storeType"),S=Symbol("storeArrayElementCounts"),h=Symbol("storeSubarrays"),p=Symbol("subarrayCursors"),w=Symbol("subarray"),E=(Symbol("subarrayFrom"),Symbol("subarrayTo"),Symbol("parentArray")),g=Symbol("tagStore"),A=(Symbol("queryShadow"),Symbol("serializeShadow"),Symbol("indexType")),v=Symbol("indexBytes"),C=Symbol("isEidType"),M={},O=(e,t)=>{e[c]&&e[c].forEach((e=>{ArrayBuffer.isView(e)?e[t]=0:e[t].fill(0)}))},j=e=>Array.isArray(e)&&"string"==typeof e[0]&&"number"==typeof e[1],k=()=>{const e=[],t=[];e.sort=function(r){const n=Array.prototype.sort.call(this,r);for(let r=0;r<e.length;r++)t[e[r]]=r;return n};const r=r=>e[t[r]]===r;return{add:n=>{r(n)||(t[n]=e.push(n)-1)},remove:n=>{if(!r(n))return;const o=t[n],i=e.pop();i!==n&&(e[o]=i,t[i]=o)},has:r,sparse:t,dense:e,reset:()=>{e.length=0,t.length=0}}},I=e=>t=>!e(t),U=(I((e=>e[c])),e=>"function"==typeof e&&e[$]),T=(I(U),Symbol("entityMasks")),q=Symbol("entityComponents"),R=Symbol("entitySparseSet"),x=Symbol("entityArray"),B=(Symbol("entityIndices"),Symbol("removedEntities"),1e5),Q=0,F=B,N=()=>F,_=[],z=[],L=new Map,P=e=>{const t=e[de]?_.length?_.shift():Q++:_.length>Math.round(.01*F)?_.shift():Q++;if(t>e[se])throw new Error("bitECS - max entities reached");return e[R].add(t),L.set(t,e),e[J].forEach((r=>{K(e,r,t)&&X(r,t)})),e[q].set(t,new Set),t},Y=(e,t)=>{if(e[R].has(t)){e[D].forEach((r=>{Z(e,r,t)})),e[de]?z.push(t):_.push(t),e[R].remove(t),e[q].delete(t),e[le].delete(e[ue].get(t)),e[ue].delete(t);for(let r=0;r<e[T].length;r++)e[T][r][t]=0}},$=Symbol("$modifier"),D=Symbol("queries"),J=Symbol("notQueries"),V=(Symbol("queryAny"),Symbol("queryAll"),Symbol("queryNone"),Symbol("queryMap")),W=Symbol("$dirtyQueries"),G=(Symbol("queryComponents"),Symbol("enterQuery"),Symbol("exitQuery"),Object.freeze([]),(e,t)=>e.concat(t)),H=e=>t=>t.filter((t=>t.name===e().constructor.name)).reduce(G),K=(H((function(...e){return function(){return e}})),H((function(...e){return function(){return e}})),H((function(...e){return function(){return e}})),(e,t,r)=>{const{masks:n,notMasks:o,generations:i}=t;for(let t=0;t<i.length;t++){const s=i[t],a=n[s],y=o[s],l=e[T][s][r];if(y&&0!=(l&y))return!1;if(a&&(l&a)!==a)return!1}return!0}),X=(e,t)=>{e.toRemove.remove(t),e.entered.add(t),e.add(t)},Z=(e,t,r)=>{t.has(r)&&!t.toRemove.has(r)&&(t.toRemove.add(r),e[W].add(t),t.exited.add(r))},ee=Symbol("componentMap"),te=[],re=(e,t)=>{const r=((e,t)=>{const r=Symbol("store");if(!e||!Object.keys(e).length)return M[r]={[d]:t,[g]:!0,[b]:()=>M[r]},M[r];e=JSON.parse(JSON.stringify(e));const O={},k=e=>{const t=Object.keys(e);for(const r of t)j(e[r])?(O[e[r][0]]||(O[e[r][0]]=0),O[e[r][0]]+=e[r][1]):e[r]instanceof Object&&k(e[r])};k(e);const I={[d]:t,[f]:{},[h]:{},[u]:r,[p]:Object.keys(y).reduce(((e,t)=>({...e,[t]:0})),{}),[c]:[],[S]:O};if(e instanceof Object&&Object.keys(e).length){const u=(e,f)=>{if("string"==typeof e[f])e[f]=((e,t)=>{const r=t*y[e].BYTES_PER_ELEMENT,n=new ArrayBuffer(r),o=new y[e](n);return o[C]=e===s,o})(e[f],t),e[f][b]=()=>M[r],I[c].push(e[f]);else if(j(e[f])){const[t,u]=e[f];e[f]=((e,t,r)=>{const u=e[d],f=Array(u).fill(0);f[m]=t,f[C]=t===s;const c=e[p],b=r<=256?n:r<=65536?o:i;if(!r)throw new Error("bitECS - Must define component array length");if(!y[t])throw new Error(`bitECS - Invalid component array property type ${t}`);if(!e[h][t]){const r=e[S][t],n=new y[t](l(r*u));n[A]=a[b],n[v]=y[b].BYTES_PER_ELEMENT,e[h][t]=n}const g=c[t],M=g+u*r;c[t]=M,f[E]=e[h][t].subarray(g,M);for(let e=0;e<u;e++){const t=r*e,n=t+r;f[e]=f[E].subarray(t,n),f[e][A]=a[b],f[e][v]=y[b].BYTES_PER_ELEMENT,f[e][w]=!0}return f})(I,t,u),e[f][b]=()=>M[r],I[c].push(e[f])}else e[f]instanceof Object&&(e[f]=Object.keys(e[f]).reduce(u,e[f]));return e};return M[r]=Object.assign(Object.keys(e).reduce(u,e),I),M[r][b]=()=>M[r],M[r]}})(e,t||N());return e&&Object.keys(e).length&&te.push(r),r},ne=(e,t,r)=>{const n=e[ee].get(t);if(!n)return!1;const{generationId:o,bitflag:i}=n;return(e[T][o][r]&i)===i},oe=(e,t,r,n=!1)=>{if(void 0===r)throw new Error("bitECS - entity is undefined.");if(!e[R].has(r))throw new Error("bitECS - entity does not exist in the world.");if(e[ee].has(t)||((e,t)=>{if(!t)throw new Error("bitECS - Cannot register null or undefined component");const r=new Set,n=new Set,o=new Set;e[D].forEach((e=>{e.allComponents.includes(t)&&r.add(e)})),e[ee].set(t,{generationId:e[T].length-1,bitflag:e[ae],store:t,queries:r,notQueries:n,changedQueries:o}),(e=>{e[ae]*=2,e[ae]>=2**31&&(e[ae]=1,e[T].push(new Uint32Array(e[se])))})(e)})(e,t),ne(e,t,r))return;const o=e[ee].get(t),{generationId:i,bitflag:s,queries:a,notQueries:y}=o;e[T][i][r]|=s,a.forEach((t=>{t.toRemove.remove(r);const n=K(e,t,r);n&&(t.exited.remove(r),X(t,r)),n||(t.entered.remove(r),Z(e,t,r))})),e[q].get(r).add(t),n&&O(t,r)},ie=(e,t,r,n=!0)=>{if(void 0===r)throw new Error("bitECS - entity is undefined.");if(!e[R].has(r))throw new Error("bitECS - entity does not exist in the world.");if(!ne(e,t,r))return;const o=e[ee].get(t),{generationId:i,bitflag:s,queries:a}=o;e[T][i][r]&=~s,a.forEach((t=>{t.toRemove.remove(r);const n=K(e,t,r);n&&(t.exited.remove(r),X(t,r)),n||(t.entered.remove(r),Z(e,t,r))})),e[q].get(r).delete(t),n&&O(t,r)},se=Symbol("size"),ae=(Symbol("resizeThreshold"),Symbol("bitflag")),ye=Symbol("archetypes"),le=Symbol("localEntities"),ue=Symbol("localEntityLookup"),de=Symbol("manualEntityRecycling"),fe=[],ce=(...e)=>{const t="object"==typeof e[0]?e[0]:{},r="number"==typeof e[0]?e[0]:"number"==typeof e[1]?e[1]:N();return be(t,r),fe.push(t),t},be=(e,t=N())=>(e[se]=t,e[x]&&e[x].forEach((t=>Y(e,t))),e[T]=[new Uint32Array(t)],e[q]=new Map,e[ye]=[],e[R]=k(),e[x]=e[R].dense,e[ae]=1,e[ee]=new Map,e[V]=new Map,e[D]=new Set,e[J]=new Set,e[W]=new Set,e[le]=new Map,e[ue]=new Map,e[de]=!1,e)}}]);
//# sourceMappingURL=192.echo-d.min.js.map