{"version":3,"file":"bitecs.echo-d.min.js","mappings":"cAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,GACjB,CATD,CASqB,oBAAXK,OAAyBA,OAA2B,oBAAXC,OAAyBA,OAAyB,oBAATC,KAAuBA,KAAOC,MAAM,K,ubCFhI,MAAM,YAAEC,EAAW,gBAEnBC,EAAe,gBAAEC,EAAe,aAAEC,EAAY,UAE9CC,EAAS,aAAEC,SAEA,6BACJ,SAASC,EAAuBC,EAAOC,EAAGC,EAAOC,GACpD,MAAMC,EAAOF,EAAMC,GACnB,OAAIE,MAAMC,QAAQF,GACPJ,EAAMO,MAAMN,EAAIG,EAAK,IAAKH,EAAI,GAAKG,EAAK,IAE5CJ,EAAMC,EACjB,CACO,SAASO,EAAuBR,EAAOS,EAAQC,GAClD,OAAOV,CACX,CACO,MAAMW,UAAsB,KAC/BC,YAAYC,EAASC,GACjBC,MAAM,IACEF,GAAW,CAAC,EAChBG,OAAQ,IAAIC,IACZC,WAAY,IAAID,IAChBE,SAAU,IAAIF,IAEdG,OAAQ,MACTN,GACH,IAAK,IAAIX,KAAOX,KAAKU,MAAO,CACxB,MAAME,EAAOZ,KAAKU,MAAMC,GACxB,GAAuB,iBAAZC,EAAK,GACZZ,KAAK0B,WAAWG,IAAIlB,EAAKC,EAAK,IAAMV,EAAgBU,EAAK,GAAIA,EAAK,UAGlE,OAAQA,GACJ,KAAKkB,QACL,KAAKC,OACL,KAAKC,OACDhC,KAAK0B,WAAWG,IAAIlB,EAAK,IAAIc,KAG7C,CACA,IAAI,aAGJQ,GAAkBX,EAoBlBtB,KAAKiC,aAAeA,EACpBjC,KAAKkC,MAAQb,GAASa,OAASjC,IAC/BD,KAAKmC,KAAOd,GAASc,MAAQ,IAAIV,GAgBrC,CACAW,aAAaC,GACT,OAAOrC,KAAKsC,UAAUtC,KAAKwB,OAAQa,EACvC,CACAE,iBAAiBF,EAAI1B,GACjB,MAAM6B,EAAMxC,KAAKwB,OAAOiB,IAAIJ,IAAOrC,KAAK2B,SAASc,IAAIJ,GAC/CK,EAAY1C,KAAK0B,WAAWe,IAAI9B,GACtC,IAAK6B,IAAQE,EACT,OAEJ,MAAMC,EAAgB,KAClB,MAAMC,EAAY5C,KAAK6C,eAAeR,EAAI1B,GAC1C,GAAIX,KAAK8C,QAAQnC,GAAM,CACnB,MAAMoC,EAAQ/C,KAAK8C,QAAQnC,GACvBX,KAAKgD,QAAQX,GACbU,EAAMvB,OAAOyB,OAAOZ,EAAIO,GAGxBG,EAAMpB,SAASsB,OAAOZ,EAAIO,EAElC,GAEAF,aAAqBjB,KACNiB,EAAUD,IAAID,IAEzBE,EAAUQ,OAAOV,GAErBG,MAGAxC,EAAgBH,KAAKkC,MAAOQ,EAAWF,GACvCG,IAER,CACAQ,cAAcd,GACV,OAAOrC,KAAKsC,UAAUtC,KAAK2B,SAAUU,EACzC,CACAC,UAAUc,EAAMf,GACZ,MAAMG,EAAMY,EAAKX,IAAIJ,GACrB,QAAIG,IACApC,EAAaJ,KAAKkC,MAAOM,GACzBY,EAAKF,OAAOb,IACL,EAGf,CACAgB,gBAAgBhB,GACZ,MAAMG,EAAMxC,KAAKwB,OAAOiB,IAAIJ,IAAOrC,KAAK2B,SAASc,IAAIJ,GACrD,GAAKG,EAGL,OAAOA,CACX,CACAK,eAAeR,EAAI1B,GACf,MAAM6B,EAAMxC,KAAKwB,OAAOiB,IAAIJ,IAAOrC,KAAK2B,SAASc,IAAIJ,GAC/CK,EAAY1C,KAAK0B,WAAWe,IAAI9B,GACtC,GAAK6B,GAAQE,EAAb,CAGA,GAAIA,aAAqBjB,IACrB,OAAOiB,EAAUD,IAAID,GAEpB,CACD,MAAM5B,EAAOZ,KAAKU,MAAMC,GAClB2C,EAAS1C,EAAK,GAGdJ,EAAQ,IAFD,QAAeI,EAAK,IAEnB,CADDA,EAAK,IAElB,IAAIH,EAAI,EACR,IAAK,IAAI8C,KAAQD,EACb9C,EAAMC,GAAKiC,EAAUa,GAAMf,GAC3B/B,IAEJ,OAAOD,CACX,CAhBA,CAiBJ,CACAgD,UAAUC,EAAQ,KAAMC,GACpB,GAAc,OAAVD,EACA,OAAOlC,MAAMiC,UAAUC,EAAOC,GAElC,MAAMlC,EAASX,MAAM8C,KAAK3D,KAAKwB,OAAOoC,QACtC,OAAO,IAAAC,UAASrC,EAAQkC,EAC5B,CACAI,cAAcL,EAAQ,KAAMC,GAGxB,IAAIK,EACJ,GAAc,OAAVN,EACAM,EAAMN,MAEL,CACD,MAAMjC,EAASX,MAAM8C,KAAK3D,KAAKwB,OAAOoC,QAChCjC,EAAWd,MAAM8C,KAAK3D,KAAK2B,SAASiC,QAC1CG,EAAMvC,EAAOwC,OAAOrC,EACxB,CAEA,OADc,IAAAkC,UAASE,EAAKL,GACfO,KAAKC,IACd,MAAMxC,EAAa,CAAC,EACpB,IAAK,IAAIW,KAAM6B,EACXxC,EAAWW,GAAMrC,KAAKwB,OAAOiB,IAAIJ,IAAOrC,KAAK2B,SAASc,IAAIJ,GAE9D,OAAOX,CAAU,GAEzB,CACAyC,YAAYV,EAAQ,KAAMC,GACtB,GAAc,OAAVD,EACA,OAAOlC,MAAM4C,YAAYV,EAAOC,GAEpC,MAAM/B,EAAWd,MAAM8C,KAAK3D,KAAK2B,SAASiC,QAC1C,OAAO,IAAAC,UAASlC,EAAU+B,EAC9B,CACAU,UAAUX,EAAQ,KAAMC,GACpB,OAAOnC,MAAM6C,UAAUX,EAAOC,EAClC,CACAV,QAAQX,GACJ,OAAOrC,KAAKwB,OAAO6C,IAAIhC,EAC3B,CACAiC,SAASjC,GACL,OAAOrC,KAAK2B,SAAS0C,IAAIhC,EAC7B,CACAkC,UAAU/C,GACN,OAAOD,MAAMgD,UAAU/C,EAC3B,CACAgD,cAAc9C,GACV,OAAOH,MAAMiD,cAAc9C,EAC/B,CACA+C,YAAY9C,GACR,OAAOJ,MAAMkD,YAAY9C,EAC7B,CACA+C,UAAU9C,GACN,OAAOL,MAAMmD,UAAU9C,EAC3B,CACA+C,WAAWtC,GACP,OAAOrC,KAAK4E,QAAQ5E,KAAKwB,OAAQa,EACrC,CACAwC,eAAexC,EAAI1B,EAAKH,GACpB,MAAMsE,EAAS9E,KAAKwB,OAAOiB,IAAIJ,IAAOrC,KAAK2B,SAASc,IAAIJ,GACxD,GAAIyC,EAAQ,CACR,MAAMlC,EAAYkC,EAAOnE,GAInBoE,EAAY/E,KAAK0B,WAAWe,IAAI9B,GAQtC,GAFAL,EAAaN,KAAKkC,MAAO4C,EAAQC,EAAWvE,GAExCR,KAAK8C,QAAQnC,GAAM,CACnB,MAAMoC,EAAQ/C,KAAK8C,QAAQnC,GACvBX,KAAKgD,QAAQX,IACbU,EAAMvB,OAAOyB,OAAOZ,EAAIO,GACxBG,EAAMvB,OAAOK,IAAIQ,EAAI7B,KAGrBuC,EAAMpB,SAASsB,OAAOZ,EAAIO,GAC1BG,EAAMpB,SAASE,IAAIQ,EAAI7B,GAE/B,CACJ,CACJ,CACAwE,YAAY3C,GACR,OAAOrC,KAAK4E,QAAQ5E,KAAK2B,SAAUU,EACvC,CACAuC,QAAQxB,EAAMf,GACV,IAAIyC,EAAS1B,EAAKX,IAAIJ,GACtB,OAAKyC,IACDA,EAASzE,EAAUL,KAAKkC,OACxBkB,EAAKvB,IAAIQ,EAAIyC,IACN,EAGf,CACAG,WAAW5C,EAAI6C,EAAOC,GAAO,IAAAC,QACzB,OAAO7D,MAAM0D,WAAW5C,EAAI6C,EAAOC,EACvC,E","sources":["webpack://echoD/webpack/universalModuleDefinition","webpack://echoD/./lib/extra/storage/bitecs.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echoD\"] = factory();\n\telse\n\t\troot[\"echoD\"] = factory();\n})(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : this, () => {\nreturn ","import { Storage } from '../../storage.js';\nimport { ArrayTypes } from '../../types.js';\nimport { paginate, now } from '../../utils.js';\n// interface WorldOptions {\n//     defs: any[];\n//     [key: string]: any;\n// }\nconst { createWorld, \n// Types,\ndefineComponent, removeComponent, removeEntity, \n// defineQuery,\naddEntity, addComponent,\n// pipe,\n } = await import('bitecs');\nexport function defaultGetGroupedValue(value, i, types, key) {\n    const type = types[key];\n    if (Array.isArray(type)) {\n        return value.slice(i * type[1], (i + 1) * type[1]);\n    }\n    return value[i];\n}\nexport function defaultSetGroupedValue(value, _types, _key) {\n    return value;\n}\nexport class BitECSStorage extends Storage {\n    constructor(storage, options) {\n        super({\n            ...(storage || {}),\n            actors: new Map(),\n            components: new Map(),\n            entities: new Map(),\n            // inputs: new Map(),\n            inputs: null,\n        }, options);\n        for (let key in this.types) {\n            const type = this.types[key];\n            if (typeof type[0] === 'string') {\n                this.components.set(key, type[2] || defineComponent(type[3], type[4]));\n            }\n            else\n                switch (type) {\n                    case Boolean:\n                    case Number:\n                    case String:\n                        this.components.set(key, new Map());\n                        break;\n                }\n        }\n        let { \n        // types,\n        // indexes,\n        worldOptions, } = options;\n        /*\n        worldOptions = worldOptions || { defs: [] }\n\n        if (worldOptions && !(worldOptions as WorldOptions).defs) {\n            (worldOptions as WorldOptions).defs = []\n        }\n\n        if (!((worldOptions as WorldOptions).defs as any[]).length) {\n             for (let component of this.components.values()) {\n                if (!component) {\n                    continue\n                }\n                if ((component as any) instanceof Map) {\n                    continue\n                }\n                (worldOptions as WorldOptions).defs.push(component)\n            }\n        }\n        */\n        this.worldOptions = worldOptions;\n        this.world = storage?.world || createWorld(); // worldOptions);\n        this.eids = storage?.eids || new Map();\n        /*\n        for (let key in this.actors) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.entities) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.components) {\n            for (let id in this.components[key]) {\n                addComponent(this.world, this.components[key][id], this.ids[id]);\n            }\n        }\n        */\n    }\n    destroyActor(id) {\n        return this.destroyId(this.actors, id);\n    }\n    destroyComponent(id, key) {\n        const eid = this.actors.get(id) || this.entities.get(id);\n        const Component = this.components.get(key);\n        if (!eid || !Component) {\n            return;\n        }\n        const updateIndexes = () => {\n            const prevValue = this.fetchComponent(id, key);\n            if (this.indexes[key]) {\n                const index = this.indexes[key];\n                if (this.isActor(id)) {\n                    index.actors.remove(id, prevValue);\n                }\n                else {\n                    index.entities.remove(id, prevValue);\n                }\n            }\n        };\n        if (Component instanceof Map) {\n            const entity = Component.get(eid);\n            if (entity) {\n                Component.delete(eid);\n            }\n            updateIndexes();\n        }\n        else {\n            removeComponent(this.world, Component, eid);\n            updateIndexes();\n        }\n    }\n    destroyEntity(id) {\n        return this.destroyId(this.entities, id);\n    }\n    destroyId(list, id) {\n        const eid = list.get(id);\n        if (eid) {\n            removeEntity(this.world, eid);\n            list.delete(id);\n            return true;\n        }\n        return false;\n    }\n    fetchComponents(id) {\n        const eid = this.actors.get(id) || this.entities.get(id);\n        if (!eid) {\n            return;\n        }\n        return eid;\n    }\n    fetchComponent(id, key) {\n        const eid = this.actors.get(id) || this.entities.get(id);\n        const Component = this.components.get(key);\n        if (!eid || !Component) {\n            return;\n        }\n        if (Component instanceof Map) {\n            return Component.get(eid);\n        }\n        else {\n            const type = this.types[key];\n            const schema = type[3];\n            const Type = ArrayTypes.get(type[0]);\n            const size = type[1];\n            const value = new Type(size);\n            let i = 0;\n            for (let prop in schema) {\n                value[i] = Component[prop][eid];\n                i++;\n            }\n            return value;\n        }\n    }\n    getActors(query = null, pageSize) {\n        if (query !== null) {\n            return super.getActors(query, pageSize);\n        }\n        const actors = Array.from(this.actors.keys());\n        return paginate(actors, pageSize);\n    }\n    getComponents(query = null, pageSize) {\n        // const queryKeys = Object.keys(query);\n        // const entities = this.world.with(...queryKeys);\n        let ids;\n        if (query !== null) {\n            ids = query;\n        }\n        else {\n            const actors = Array.from(this.actors.keys());\n            const entities = Array.from(this.entities.keys());\n            ids = actors.concat(entities);\n        }\n        const pages = paginate(ids, pageSize);\n        return pages.map((page) => {\n            const components = {};\n            for (let id of page) {\n                components[id] = this.actors.get(id) || this.entities.get(id);\n            }\n            return components;\n        });\n    }\n    getEntities(query = null, pageSize) {\n        if (query !== null) {\n            return super.getEntities(query, pageSize);\n        }\n        const entities = Array.from(this.entities.keys());\n        return paginate(entities, pageSize);\n    }\n    getInputs(query = null, pageSize) {\n        return super.getInputs(query, pageSize);\n    }\n    isActor(id) {\n        return this.actors.has(id);\n    }\n    isEntity(id) {\n        return this.entities.has(id);\n    }\n    setActors(actors) {\n        return super.setActors(actors);\n    }\n    setComponents(components) {\n        return super.setComponents(components);\n    }\n    setEntities(entities) {\n        return super.setEntities(entities);\n    }\n    setInputs(inputs) {\n        return super.setInputs(inputs);\n    }\n    storeActor(id) {\n        return this.storeId(this.actors, id);\n    }\n    storeComponent(id, key, value) {\n        const entity = this.actors.get(id) || this.entities.get(id);\n        if (entity) {\n            const prevValue = entity[key];\n            // entity[key] = value\n            // const type = this.types[key];\n            // const schema = type[3]\n            const component = this.components.get(key);\n            // let i = 0;\n            // for (let prop in schema) {\n            //     component[prop] = value[i]\n            //     i++\n            // }\n            addComponent(this.world, entity, component, value);\n            // this.world.reindex(entity)\n            if (this.indexes[key]) {\n                const index = this.indexes[key];\n                if (this.isActor(id)) {\n                    index.actors.remove(id, prevValue);\n                    index.actors.set(id, value);\n                }\n                else {\n                    index.entities.remove(id, prevValue);\n                    index.entities.set(id, value);\n                }\n            }\n        }\n    }\n    storeEntity(id) {\n        return this.storeId(this.entities, id);\n    }\n    storeId(list, id) {\n        let entity = list.get(id);\n        if (!entity) {\n            entity = addEntity(this.world);\n            list.set(id, entity);\n            return true;\n        }\n        return false;\n    }\n    storeInput(id, input, tick = now()) {\n        return super.storeInput(id, input, tick);\n    }\n}\n"],"names":["root","factory","exports","module","define","amd","window","global","self","this","createWorld","defineComponent","removeComponent","removeEntity","addEntity","addComponent","defaultGetGroupedValue","value","i","types","key","type","Array","isArray","slice","defaultSetGroupedValue","_types","_key","BitECSStorage","constructor","storage","options","super","actors","Map","components","entities","inputs","set","Boolean","Number","String","worldOptions","world","eids","destroyActor","id","destroyId","destroyComponent","eid","get","Component","updateIndexes","prevValue","fetchComponent","indexes","index","isActor","remove","delete","destroyEntity","list","fetchComponents","schema","prop","getActors","query","pageSize","from","keys","paginate","getComponents","ids","concat","map","page","getEntities","getInputs","has","isEntity","setActors","setComponents","setEntities","setInputs","storeActor","storeId","storeComponent","entity","component","storeEntity","storeInput","input","tick","now"],"sourceRoot":""}