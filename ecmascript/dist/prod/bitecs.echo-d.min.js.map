{"version":3,"file":"bitecs.echo-d.min.js","mappings":"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","sources":["webpack://echoD/webpack/universalModuleDefinition","webpack://echoD/./lib/extra/storage/bitecs.js","webpack://echoD/./node_modules/.deno/bitecs@0.3.40/node_modules/bitecs/dist/index.mjs"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echoD\"] = factory();\n\telse\n\t\troot[\"echoD\"] = factory();\n})(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : this, () => {\nreturn ","import { hasComponent } from 'bitecs';\nimport { Storage } from '../../storage.js';\nimport { ArrayTypes } from '../../types.js';\nimport { paginate } from '../../utils.js';\n// interface WorldOptions {\n//     defs: any[];\n//     [key: string]: any;\n// }\nconst { createWorld, \n// Types,\ndefineComponent, removeComponent, removeEntity, \n// defineQuery,\nentityExists, addEntity, addComponent, getEntityComponents,\n// pipe,\n } = await import('bitecs');\nexport function defaultGetGroupedValue(value, i, types, key) {\n    const type = types[key];\n    if (Array.isArray(type)) {\n        return value.slice(i * type[1], (i + 1) * type[1]);\n    }\n    return value[i];\n}\nexport function defaultSetGroupedValue(value, _types, _key) {\n    return value;\n}\nexport class BitECSStorage extends Storage {\n    constructor(storage, options) {\n        super({\n            ...(storage || {}),\n            actors: new Map(),\n            components: new Map(),\n            entities: new Map(),\n            // inputs: new Map(),\n            inputs: null,\n        }, options);\n        for (let key in this.types) {\n            const type = this.types[key];\n            if (typeof type[0] === 'string') {\n                this.components.set(key, type[2] || defineComponent(type[3], type[4]));\n            }\n            else\n                switch (type) {\n                    case Boolean:\n                    case Number:\n                    case String:\n                        this.components.set(key, new Map());\n                        break;\n                }\n        }\n        let { \n        // types,\n        // indexes,\n        worldOptions, } = options;\n        /*\n        worldOptions = worldOptions || { defs: [] }\n\n        if (worldOptions && !(worldOptions as WorldOptions).defs) {\n            (worldOptions as WorldOptions).defs = []\n        }\n\n        if (!((worldOptions as WorldOptions).defs as any[]).length) {\n             for (let component of this.components.values()) {\n                if (!component) {\n                    continue\n                }\n                if ((component as any) instanceof Map) {\n                    continue\n                }\n                (worldOptions as WorldOptions).defs.push(component)\n            }\n        }\n        */\n        this.worldOptions = worldOptions;\n        this.world = storage?.world || createWorld(); // worldOptions);\n        this.eids = storage?.eids || new Map();\n        /*\n        for (let key in this.actors) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.entities) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.components) {\n            for (let id in this.components[key]) {\n                addComponent(this.world, this.components[key][id], this.ids[id]);\n            }\n        }\n        */\n    }\n    destroyActor(id) {\n        return this.destroyId(this.actors, id);\n    }\n    destroyComponent(id, key) {\n        const eid = this.getEID(id);\n        const Component = this.components.get(key);\n        if ((eid === undefined || eid === null) || !Component) {\n            return;\n        }\n        const updateIndexes = () => {\n            const prevValue = this.fetchComponentProcess(id, key, Component, eid);\n            if (this.indexes[key]) {\n                const index = this.indexes[key];\n                if (this.isActor(id)) {\n                    index.actors.remove(id, prevValue);\n                }\n                else {\n                    index.entities.remove(id, prevValue);\n                }\n            }\n        };\n        if (Component instanceof Map) {\n            if (Component.has(eid)) {\n                Component.delete(eid);\n            }\n            updateIndexes();\n        }\n        else {\n            if (entityExists(this.world, eid)) {\n                if (hasComponent(this.world, Component, eid)) {\n                    removeComponent(this.world, Component, eid);\n                }\n            }\n            updateIndexes();\n        }\n    }\n    destroyEntity(id) {\n        return this.destroyId(this.entities, id);\n    }\n    destroyId(list, id) {\n        const eid = list.get(id);\n        if (eid !== null && eid !== undefined) {\n            if (entityExists(this.world, eid)) {\n                removeEntity(this.world, eid);\n            }\n            if (list.has(id)) {\n                list.delete(id);\n            }\n            return true;\n        }\n        return false;\n    }\n    fetchComponents(id) {\n        const eid = this.getEID(id);\n        if (eid !== null && eid !== undefined) {\n            return;\n        }\n        return eid;\n    }\n    fetchComponent(id, key) {\n        return this.fetchComponentProcess(id, key, undefined, undefined);\n    }\n    fetchComponentProcess(id, key, Component, eid) {\n        eid = (eid === undefined || eid === null) ? this.getEID(id) : eid;\n        Component = Component || this.components.get(key);\n        if ((eid !== null && eid !== undefined) || !Component) {\n            return;\n        }\n        if (Component instanceof Map) {\n            return Component.get(eid);\n        }\n        else {\n            const type = this.types[key];\n            const schema = type[3];\n            const Type = ArrayTypes.get(type[0]);\n            const size = type[1];\n            const value = new Type(size);\n            let i = 0;\n            for (let prop in schema) {\n                value[i] = Component[prop][eid];\n                i++;\n            }\n            return value;\n        }\n    }\n    getActors(query = null, pageSize) {\n        if (query !== null) {\n            return super.getActors(query, pageSize);\n        }\n        const actors = this.actors.keys();\n        return paginate(actors, pageSize);\n    }\n    getComponents(query = null, pageSize) {\n        // const queryKeys = Object.keys(query);\n        // const entities = this.world.with(...queryKeys);\n        let ids;\n        if (query !== null) {\n            ids = query;\n        }\n        else {\n            const actors = this.actors.keys();\n            const entities = this.entities.keys();\n            ids = [\n                ...actors,\n                ...entities\n            ];\n        }\n        const pages = paginate(ids, pageSize);\n        const compEntries = this.components.entries();\n        const compLookup = new Map();\n        for (let [key, value] of compEntries) {\n            compLookup.set(value, key);\n        }\n        return pages.map((page) => {\n            const components = {};\n            for (let id of page) {\n                const eid = this.getEID(id);\n                if (eid === undefined || eid === null) {\n                    continue;\n                }\n                const entity = {};\n                const compList = getEntityComponents(this.world, eid);\n                compList.forEach((Component) => {\n                    const key = compLookup.get(Component);\n                    if (!key) {\n                        return;\n                    }\n                    // TODO: fix this\n                    // const val = this.fetchComponentProcess(id, key, Component, eid)\n                    let val;\n                    if (Component instanceof Map) {\n                        val = Component.get(eid);\n                    }\n                    else {\n                        const type = this.types[key];\n                        const schema = type[3];\n                        const Type = ArrayTypes.get(type[0]);\n                        const size = type[1];\n                        const value = new Type(size);\n                        let i = 0;\n                        for (let prop in schema) {\n                            value[i] = Component[prop][eid];\n                            i++;\n                        }\n                        val = value;\n                    }\n                    entity[key] = val;\n                });\n                components[id] = entity;\n            }\n            return components;\n        });\n    }\n    getEntities(query = null, pageSize) {\n        if (query !== null) {\n            return super.getEntities(query, pageSize);\n        }\n        const entities = this.entities.keys();\n        return paginate(entities, pageSize);\n    }\n    getInputs(query = null, pageSize) {\n        return super.getInputs(query, pageSize);\n    }\n    getEID(id) {\n        if (this.actors.has(id)) {\n            return this.actors.get(id);\n        }\n        if (this.entities.has(id)) {\n            return this.entities.get(id);\n        }\n        return;\n    }\n    isActor(id) {\n        return this.actors.has(id);\n    }\n    isEntity(id) {\n        return this.entities.has(id);\n    }\n    setActors(actors) {\n        return super.setActors(actors);\n    }\n    setComponents(components) {\n        return super.setComponents(components);\n    }\n    setEntities(entities) {\n        return super.setEntities(entities);\n    }\n    setInputs(inputs) {\n        return super.setInputs(inputs);\n    }\n    storeActor(id) {\n        return this.storeId(this.actors, id);\n    }\n    storeComponent(id, key, value) {\n        let entity = this.getEID(id);\n        if (entity !== null && entity !== undefined) {\n            if (!entityExists(this.world, entity)) {\n                entity = addEntity(this.world);\n                if (this.isActor(id)) {\n                    // this.actors.delete(id);\n                    this.actors.set(id, entity);\n                }\n                else {\n                    // this.entities.delete(id);\n                    this.entities.set(id, entity);\n                }\n            }\n            const Component = this.components.get(key);\n            if (!Component) {\n                return;\n            }\n            if (!hasComponent(this.world, Component, entity)) {\n                addComponent(this.world, Component, entity);\n            }\n            let prevValue = []; // TODO: fix this\n            if (Component instanceof Map) {\n                prevValue = Component.get(entity);\n                Component.set(entity, value);\n            }\n            else {\n                const type = this.types[key];\n                const schema = type[3];\n                let i = 0;\n                for (let prop in schema) {\n                    prevValue[i] = Component[prop][entity];\n                    Component[prop][entity] = value[i];\n                    i++;\n                }\n            }\n            // this.world.reindex(entity)\n            if (this.indexes[key]) {\n                const index = this.indexes[key];\n                if (this.isActor(id)) {\n                    index.actors.remove(id, prevValue);\n                    index.actors.set(id, value);\n                }\n                else {\n                    index.entities.remove(id, prevValue);\n                    index.entities.set(id, value);\n                }\n            }\n        }\n    }\n    storeEntity(id) {\n        return this.storeId(this.entities, id);\n    }\n    storeId(list, id) {\n        let entity = list.get(id);\n        if (entity == null && entity == undefined) {\n            entity = addEntity(this.world);\n            list.set(id, entity);\n            return true;\n        }\n        else if (!entityExists(this.world, entity)) {\n            // list.delete(id);\n            entity = addEntity(this.world);\n            list.set(id, entity);\n            return true;\n        }\n        return false;\n    }\n    storeInput(id, input, tick = 0) {\n        return super.storeInput(id, input, tick);\n    }\n}\n","// src/Constants.js\nvar TYPES_ENUM = {\n  i8: \"i8\",\n  ui8: \"ui8\",\n  ui8c: \"ui8c\",\n  i16: \"i16\",\n  ui16: \"ui16\",\n  i32: \"i32\",\n  ui32: \"ui32\",\n  f32: \"f32\",\n  f64: \"f64\",\n  eid: \"eid\"\n};\nvar TYPES_NAMES = {\n  i8: \"Int8\",\n  ui8: \"Uint8\",\n  ui8c: \"Uint8Clamped\",\n  i16: \"Int16\",\n  ui16: \"Uint16\",\n  i32: \"Int32\",\n  ui32: \"Uint32\",\n  eid: \"Uint32\",\n  f32: \"Float32\",\n  f64: \"Float64\"\n};\nvar TYPES = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  f32: Float32Array,\n  f64: Float64Array,\n  eid: Uint32Array\n};\nvar UNSIGNED_MAX = {\n  uint8: 2 ** 8,\n  uint16: 2 ** 16,\n  uint32: 2 ** 32\n};\n\n// src/Storage.js\nvar roundToMultiple = (mul) => (x) => Math.ceil(x / mul) * mul;\nvar roundToMultiple4 = roundToMultiple(4);\nvar $storeRef = Symbol(\"storeRef\");\nvar $storeSize = Symbol(\"storeSize\");\nvar $storeMaps = Symbol(\"storeMaps\");\nvar $storeFlattened = Symbol(\"storeFlattened\");\nvar $storeBase = Symbol(\"storeBase\");\nvar $storeType = Symbol(\"storeType\");\nvar $storeArrayElementCounts = Symbol(\"storeArrayElementCounts\");\nvar $storeSubarrays = Symbol(\"storeSubarrays\");\nvar $subarrayCursors = Symbol(\"subarrayCursors\");\nvar $subarray = Symbol(\"subarray\");\nvar $subarrayFrom = Symbol(\"subarrayFrom\");\nvar $subarrayTo = Symbol(\"subarrayTo\");\nvar $parentArray = Symbol(\"parentArray\");\nvar $tagStore = Symbol(\"tagStore\");\nvar $queryShadow = Symbol(\"queryShadow\");\nvar $serializeShadow = Symbol(\"serializeShadow\");\nvar $indexType = Symbol(\"indexType\");\nvar $indexBytes = Symbol(\"indexBytes\");\nvar $isEidType = Symbol(\"isEidType\");\nvar stores = {};\nvar resize = (ta, size) => {\n  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT);\n  const newTa = new ta.constructor(newBuffer);\n  newTa.set(ta, 0);\n  return newTa;\n};\nvar createShadow = (store, key) => {\n  if (!ArrayBuffer.isView(store)) {\n    const shadowStore = store[$parentArray].slice(0);\n    store[key] = store.map((_, eid) => {\n      const { length } = store[eid];\n      const start = length * eid;\n      const end = start + length;\n      return shadowStore.subarray(start, end);\n    });\n  } else {\n    store[key] = store.slice(0);\n  }\n};\nvar resetStoreFor = (store, eid) => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach((ta) => {\n      if (ArrayBuffer.isView(ta))\n        ta[eid] = 0;\n      else\n        ta[eid].fill(0);\n    });\n  }\n};\nvar createTypeStore = (type, length) => {\n  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT;\n  const buffer = new ArrayBuffer(totalBytes);\n  const store = new TYPES[type](buffer);\n  store[$isEidType] = type === TYPES_ENUM.eid;\n  return store;\n};\nvar parentArray = (store) => store[$parentArray];\nvar createArrayStore = (metadata, type, length) => {\n  const storeSize = metadata[$storeSize];\n  const store = Array(storeSize).fill(0);\n  store[$storeType] = type;\n  store[$isEidType] = type === TYPES_ENUM.eid;\n  const cursors = metadata[$subarrayCursors];\n  const indexType = length <= UNSIGNED_MAX.uint8 ? TYPES_ENUM.ui8 : length <= UNSIGNED_MAX.uint16 ? TYPES_ENUM.ui16 : TYPES_ENUM.ui32;\n  if (!length)\n    throw new Error(\"bitECS - Must define component array length\");\n  if (!TYPES[type])\n    throw new Error(`bitECS - Invalid component array property type ${type}`);\n  if (!metadata[$storeSubarrays][type]) {\n    const arrayElementCount = metadata[$storeArrayElementCounts][type];\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize));\n    array[$indexType] = TYPES_NAMES[indexType];\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;\n    metadata[$storeSubarrays][type] = array;\n  }\n  const start = cursors[type];\n  const end = start + storeSize * length;\n  cursors[type] = end;\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end);\n  for (let eid = 0; eid < storeSize; eid++) {\n    const start2 = length * eid;\n    const end2 = start2 + length;\n    store[eid] = store[$parentArray].subarray(start2, end2);\n    store[eid][$indexType] = TYPES_NAMES[indexType];\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT;\n    store[eid][$subarray] = true;\n  }\n  return store;\n};\nvar isArrayType = (x) => Array.isArray(x) && typeof x[0] === \"string\" && typeof x[1] === \"number\";\nvar createStore = (schema, size) => {\n  const $store = Symbol(\"store\");\n  if (!schema || !Object.keys(schema).length) {\n    stores[$store] = {\n      [$storeSize]: size,\n      [$tagStore]: true,\n      [$storeBase]: () => stores[$store]\n    };\n    return stores[$store];\n  }\n  schema = JSON.parse(JSON.stringify(schema));\n  const arrayElementCounts = {};\n  const collectArrayElementCounts = (s) => {\n    const keys = Object.keys(s);\n    for (const k of keys) {\n      if (isArrayType(s[k])) {\n        if (!arrayElementCounts[s[k][0]])\n          arrayElementCounts[s[k][0]] = 0;\n        arrayElementCounts[s[k][0]] += s[k][1];\n      } else if (s[k] instanceof Object) {\n        collectArrayElementCounts(s[k]);\n      }\n    }\n  };\n  collectArrayElementCounts(schema);\n  const metadata = {\n    [$storeSize]: size,\n    [$storeMaps]: {},\n    [$storeSubarrays]: {},\n    [$storeRef]: $store,\n    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {}),\n    [$storeFlattened]: [],\n    [$storeArrayElementCounts]: arrayElementCounts\n  };\n  if (schema instanceof Object && Object.keys(schema).length) {\n    const recursiveTransform = (a, k) => {\n      if (typeof a[k] === \"string\") {\n        a[k] = createTypeStore(a[k], size);\n        a[k][$storeBase] = () => stores[$store];\n        metadata[$storeFlattened].push(a[k]);\n      } else if (isArrayType(a[k])) {\n        const [type, length] = a[k];\n        a[k] = createArrayStore(metadata, type, length);\n        a[k][$storeBase] = () => stores[$store];\n        metadata[$storeFlattened].push(a[k]);\n      } else if (a[k] instanceof Object) {\n        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k]);\n      }\n      return a;\n    };\n    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata);\n    stores[$store][$storeBase] = () => stores[$store];\n    return stores[$store];\n  }\n};\n\n// src/Util.js\nvar SparseSet = () => {\n  const dense = [];\n  const sparse = [];\n  dense.sort = function(comparator) {\n    const result = Array.prototype.sort.call(this, comparator);\n    for (let i = 0; i < dense.length; i++) {\n      sparse[dense[i]] = i;\n    }\n    return result;\n  };\n  const has = (val) => dense[sparse[val]] === val;\n  const add = (val) => {\n    if (has(val))\n      return;\n    sparse[val] = dense.push(val) - 1;\n  };\n  const remove = (val) => {\n    if (!has(val))\n      return;\n    const index = sparse[val];\n    const swapped = dense.pop();\n    if (swapped !== val) {\n      dense[index] = swapped;\n      sparse[swapped] = index;\n    }\n  };\n  const reset = () => {\n    dense.length = 0;\n    sparse.length = 0;\n  };\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n    reset\n  };\n};\n\n// src/Serialize.js\nvar DESERIALIZE_MODE = {\n  REPLACE: 0,\n  APPEND: 1,\n  MAP: 2\n};\nvar resized = false;\nvar setSerializationResized = (v) => {\n  resized = v;\n};\nvar concat = (a, v) => a.concat(v);\nvar not = (fn) => (v) => !fn(v);\nvar storeFlattened = (c) => c[$storeFlattened];\nvar isFullComponent = storeFlattened;\nvar isProperty = not(isFullComponent);\nvar isModifier = (c) => typeof c === \"function\" && c[$modifier];\nvar isNotModifier = not(isModifier);\nvar isChangedModifier = (c) => isModifier(c) && c()[1] === \"changed\";\nvar isWorld = (w) => Object.getOwnPropertySymbols(w).includes($componentMap);\nvar fromModifierToComponent = (c) => c()[0];\nvar canonicalize = (target) => {\n  if (isWorld(target))\n    return [[], /* @__PURE__ */ new Map()];\n  const fullComponentProps = target.filter(isNotModifier).filter(isFullComponent).map(storeFlattened).reduce(concat, []);\n  const changedComponentProps = target.filter(isChangedModifier).map(fromModifierToComponent).filter(isFullComponent).map(storeFlattened).reduce(concat, []);\n  const props = target.filter(isNotModifier).filter(isProperty);\n  const changedProps = target.filter(isChangedModifier).map(fromModifierToComponent).filter(isProperty);\n  const componentProps = [...fullComponentProps, ...props, ...changedComponentProps, ...changedProps];\n  const allChangedProps = [...changedComponentProps, ...changedProps].reduce((map, prop) => {\n    const $ = Symbol();\n    createShadow(prop, $);\n    map.set(prop, $);\n    return map;\n  }, /* @__PURE__ */ new Map());\n  return [componentProps, allChangedProps];\n};\nvar defineSerializer = (target, maxBytes = 2e7) => {\n  const worldSerializer = isWorld(target);\n  let [componentProps, changedProps] = canonicalize(target);\n  const buffer = new ArrayBuffer(maxBytes);\n  const view = new DataView(buffer);\n  const entityComponentCache = /* @__PURE__ */ new Map();\n  return (ents) => {\n    if (resized) {\n      [componentProps, changedProps] = canonicalize(target);\n      resized = false;\n    }\n    if (worldSerializer) {\n      componentProps = [];\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened]);\n        else\n          componentProps.push(component);\n      });\n    }\n    let world;\n    if (Object.getOwnPropertySymbols(ents).includes($componentMap)) {\n      world = ents;\n      ents = ents[$entityArray];\n    } else {\n      world = eidToWorld.get(ents[0]);\n    }\n    let where = 0;\n    if (!ents.length)\n      return buffer.slice(0, where);\n    const cache = /* @__PURE__ */ new Map();\n    for (let pid = 0; pid < componentProps.length; pid++) {\n      const prop = componentProps[pid];\n      const component = prop[$storeBase]();\n      const $diff = changedProps.get(prop);\n      const shadow = $diff ? prop[$diff] : null;\n      if (!cache.has(component))\n        cache.set(component, /* @__PURE__ */ new Map());\n      view.setUint8(where, pid);\n      where += 1;\n      const countWhere = where;\n      where += 4;\n      let writeCount = 0;\n      for (let i = 0; i < ents.length; i++) {\n        const eid = ents[i];\n        let componentCache = entityComponentCache.get(eid);\n        if (!componentCache)\n          componentCache = entityComponentCache.set(eid, /* @__PURE__ */ new Set()).get(eid);\n        componentCache.add(eid);\n        const newlyAddedComponent = shadow && cache.get(component).get(eid) || !componentCache.has(component) && hasComponent(world, component, eid);\n        cache.get(component).set(eid, newlyAddedComponent);\n        if (newlyAddedComponent) {\n          componentCache.add(component);\n        } else if (!hasComponent(world, component, eid)) {\n          componentCache.delete(component);\n          continue;\n        }\n        const rewindWhere = where;\n        view.setUint32(where, eid);\n        where += 4;\n        if (prop[$tagStore]) {\n          writeCount++;\n          continue;\n        }\n        if (ArrayBuffer.isView(prop[eid])) {\n          const type = prop[eid].constructor.name.replace(\"Array\", \"\");\n          const indexType = prop[eid][$indexType];\n          const indexBytes = prop[eid][$indexBytes];\n          const countWhere2 = where;\n          where += indexBytes;\n          let arrayWriteCount = 0;\n          for (let i2 = 0; i2 < prop[eid].length; i2++) {\n            if (shadow) {\n              const changed = shadow[eid][i2] !== prop[eid][i2];\n              shadow[eid][i2] = prop[eid][i2];\n              if (!changed && !newlyAddedComponent) {\n                continue;\n              }\n            }\n            view[`set${indexType}`](where, i2);\n            where += indexBytes;\n            const value = prop[eid][i2];\n            view[`set${type}`](where, value);\n            where += prop[eid].BYTES_PER_ELEMENT;\n            arrayWriteCount++;\n          }\n          if (arrayWriteCount > 0) {\n            view[`set${indexType}`](countWhere2, arrayWriteCount);\n            writeCount++;\n          } else {\n            where = rewindWhere;\n            continue;\n          }\n        } else {\n          if (shadow) {\n            const changed = shadow[eid] !== prop[eid];\n            shadow[eid] = prop[eid];\n            if (!changed && !newlyAddedComponent) {\n              where = rewindWhere;\n              continue;\n            }\n          }\n          const type = prop.constructor.name.replace(\"Array\", \"\");\n          view[`set${type}`](where, prop[eid]);\n          where += prop.BYTES_PER_ELEMENT;\n          writeCount++;\n        }\n      }\n      if (writeCount > 0) {\n        view.setUint32(countWhere, writeCount);\n      } else {\n        where -= 5;\n      }\n    }\n    return buffer.slice(0, where);\n  };\n};\nvar newEntities = /* @__PURE__ */ new Map();\nvar defineDeserializer = (target) => {\n  const isWorld2 = Object.getOwnPropertySymbols(target).includes($componentMap);\n  let [componentProps] = canonicalize(target);\n  const deserializedEntities = /* @__PURE__ */ new Set();\n  return (world, packet, mode = 0) => {\n    newEntities.clear();\n    if (resized) {\n      [componentProps] = canonicalize(target);\n      resized = false;\n    }\n    if (isWorld2) {\n      componentProps = [];\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened]);\n        else\n          componentProps.push(component);\n      });\n    }\n    const localEntities = world[$localEntities];\n    const localEntityLookup = world[$localEntityLookup];\n    const view = new DataView(packet);\n    let where = 0;\n    while (where < packet.byteLength) {\n      const pid = view.getUint8(where);\n      where += 1;\n      const entityCount = view.getUint32(where);\n      where += 4;\n      const prop = componentProps[pid];\n      for (let i = 0; i < entityCount; i++) {\n        let eid = view.getUint32(where);\n        where += 4;\n        if (mode === DESERIALIZE_MODE.MAP) {\n          if (localEntities.has(eid)) {\n            eid = localEntities.get(eid);\n          } else if (newEntities.has(eid)) {\n            eid = newEntities.get(eid);\n          } else {\n            const newEid = addEntity(world);\n            localEntities.set(eid, newEid);\n            localEntityLookup.set(newEid, eid);\n            newEntities.set(eid, newEid);\n            eid = newEid;\n          }\n        }\n        if (mode === DESERIALIZE_MODE.APPEND || mode === DESERIALIZE_MODE.REPLACE && !world[$entitySparseSet].has(eid)) {\n          const newEid = newEntities.get(eid) || addEntity(world);\n          newEntities.set(eid, newEid);\n          eid = newEid;\n        }\n        const component = prop[$storeBase]();\n        if (!hasComponent(world, component, eid)) {\n          addComponent(world, component, eid);\n        }\n        deserializedEntities.add(eid);\n        if (component[$tagStore]) {\n          continue;\n        }\n        if (ArrayBuffer.isView(prop[eid])) {\n          const array = prop[eid];\n          const count = view[`get${array[$indexType]}`](where);\n          where += array[$indexBytes];\n          for (let i2 = 0; i2 < count; i2++) {\n            const index = view[`get${array[$indexType]}`](where);\n            where += array[$indexBytes];\n            const value = view[`get${array.constructor.name.replace(\"Array\", \"\")}`](where);\n            where += array.BYTES_PER_ELEMENT;\n            if (prop[$isEidType]) {\n              let localEid;\n              if (localEntities.has(value)) {\n                localEid = localEntities.get(value);\n              } else if (newEntities.has(value)) {\n                localEid = newEntities.get(value);\n              } else {\n                const newEid = addEntity(world);\n                localEntities.set(value, newEid);\n                localEntityLookup.set(newEid, value);\n                newEntities.set(value, newEid);\n                localEid = newEid;\n              }\n              prop[eid][index] = localEid;\n            } else\n              prop[eid][index] = value;\n          }\n        } else {\n          const value = view[`get${prop.constructor.name.replace(\"Array\", \"\")}`](where);\n          where += prop.BYTES_PER_ELEMENT;\n          if (prop[$isEidType]) {\n            let localEid;\n            if (localEntities.has(value)) {\n              localEid = localEntities.get(value);\n            } else if (newEntities.has(value)) {\n              localEid = newEntities.get(value);\n            } else {\n              const newEid = addEntity(world);\n              localEntities.set(value, newEid);\n              localEntityLookup.set(newEid, value);\n              newEntities.set(value, newEid);\n              localEid = newEid;\n            }\n            prop[eid] = localEid;\n          } else\n            prop[eid] = value;\n        }\n      }\n    }\n    const ents = Array.from(deserializedEntities);\n    deserializedEntities.clear();\n    return ents;\n  };\n};\n\n// src/Entity.js\nvar $entityMasks = Symbol(\"entityMasks\");\nvar $entityComponents = Symbol(\"entityComponents\");\nvar $entitySparseSet = Symbol(\"entitySparseSet\");\nvar $entityArray = Symbol(\"entityArray\");\nvar $entityIndices = Symbol(\"entityIndices\");\nvar $removedEntities = Symbol(\"removedEntities\");\nvar defaultSize = 1e5;\nvar globalEntityCursor = 0;\nvar globalSize = defaultSize;\nvar getGlobalSize = () => globalSize;\nvar removed = [];\nvar recycled = [];\nvar defaultRemovedReuseThreshold = 0.01;\nvar removedReuseThreshold = defaultRemovedReuseThreshold;\nvar resetGlobals = () => {\n  globalSize = defaultSize;\n  globalEntityCursor = 0;\n  removedReuseThreshold = defaultRemovedReuseThreshold;\n  removed.length = 0;\n  recycled.length = 0;\n};\nvar setDefaultSize = (newSize) => {\n  const oldSize = globalSize;\n  defaultSize = newSize;\n  resetGlobals();\n  globalSize = newSize;\n  resizeWorlds(newSize);\n  setSerializationResized(true);\n};\nvar setRemovedRecycleThreshold = (newThreshold) => {\n  removedReuseThreshold = newThreshold;\n};\nvar getEntityCursor = () => globalEntityCursor;\nvar eidToWorld = /* @__PURE__ */ new Map();\nvar flushRemovedEntities = (world) => {\n  if (!world[$manualEntityRecycling]) {\n    throw new Error(\"bitECS - cannot flush removed entities, enable feature with the enableManualEntityRecycling function\");\n  }\n  removed.push(...recycled);\n  recycled.length = 0;\n};\nvar addEntity = (world) => {\n  const eid = world[$manualEntityRecycling] ? removed.length ? removed.shift() : globalEntityCursor++ : removed.length > Math.round(globalSize * removedReuseThreshold) ? removed.shift() : globalEntityCursor++;\n  if (eid > world[$size])\n    throw new Error(\"bitECS - max entities reached\");\n  world[$entitySparseSet].add(eid);\n  eidToWorld.set(eid, world);\n  world[$notQueries].forEach((q) => {\n    const match = queryCheckEntity(world, q, eid);\n    if (match)\n      queryAddEntity(q, eid);\n  });\n  world[$entityComponents].set(eid, /* @__PURE__ */ new Set());\n  return eid;\n};\nvar removeEntity = (world, eid) => {\n  if (!world[$entitySparseSet].has(eid))\n    return;\n  world[$queries].forEach((q) => {\n    queryRemoveEntity(world, q, eid);\n  });\n  if (world[$manualEntityRecycling])\n    recycled.push(eid);\n  else\n    removed.push(eid);\n  world[$entitySparseSet].remove(eid);\n  world[$entityComponents].delete(eid);\n  world[$localEntities].delete(world[$localEntityLookup].get(eid));\n  world[$localEntityLookup].delete(eid);\n  for (let i = 0; i < world[$entityMasks].length; i++)\n    world[$entityMasks][i][eid] = 0;\n};\nvar getEntityComponents = (world, eid) => {\n  if (eid === void 0)\n    throw new Error(\"bitECS - entity is undefined.\");\n  if (!world[$entitySparseSet].has(eid))\n    throw new Error(\"bitECS - entity does not exist in the world.\");\n  return Array.from(world[$entityComponents].get(eid));\n};\nvar entityExists = (world, eid) => world[$entitySparseSet].has(eid);\n\n// src/Query.js\nvar $modifier = Symbol(\"$modifier\");\nfunction modifier(c, mod) {\n  const inner = () => [c, mod];\n  inner[$modifier] = true;\n  return inner;\n}\nvar Not = (c) => modifier(c, \"not\");\nvar Changed = (c) => modifier(c, \"changed\");\nfunction Any(...comps) {\n  return function QueryAny() {\n    return comps;\n  };\n}\nfunction All(...comps) {\n  return function QueryAll() {\n    return comps;\n  };\n}\nfunction None(...comps) {\n  return function QueryNone() {\n    return comps;\n  };\n}\nvar $queries = Symbol(\"queries\");\nvar $notQueries = Symbol(\"notQueries\");\nvar $queryAny = Symbol(\"queryAny\");\nvar $queryAll = Symbol(\"queryAll\");\nvar $queryNone = Symbol(\"queryNone\");\nvar $queryMap = Symbol(\"queryMap\");\nvar $dirtyQueries = Symbol(\"$dirtyQueries\");\nvar $queryComponents = Symbol(\"queryComponents\");\nvar $enterQuery = Symbol(\"enterQuery\");\nvar $exitQuery = Symbol(\"exitQuery\");\nvar empty = Object.freeze([]);\nvar enterQuery = (query) => (world) => {\n  if (!world[$queryMap].has(query))\n    registerQuery(world, query);\n  const q = world[$queryMap].get(query);\n  if (q.entered.dense.length === 0) {\n    return empty;\n  } else {\n    const results = q.entered.dense.slice();\n    q.entered.reset();\n    return results;\n  }\n};\nvar exitQuery = (query) => (world) => {\n  if (!world[$queryMap].has(query))\n    registerQuery(world, query);\n  const q = world[$queryMap].get(query);\n  if (q.exited.dense.length === 0) {\n    return empty;\n  } else {\n    const results = q.exited.dense.slice();\n    q.exited.reset();\n    return results;\n  }\n};\nvar registerQuery = (world, query) => {\n  const components2 = [];\n  const notComponents = [];\n  const changedComponents = [];\n  query[$queryComponents].forEach((c) => {\n    if (typeof c === \"function\" && c[$modifier]) {\n      const [comp, mod] = c();\n      if (!world[$componentMap].has(comp))\n        registerComponent(world, comp);\n      if (mod === \"not\") {\n        notComponents.push(comp);\n      }\n      if (mod === \"changed\") {\n        changedComponents.push(comp);\n        components2.push(comp);\n      }\n    } else {\n      if (!world[$componentMap].has(c))\n        registerComponent(world, c);\n      components2.push(c);\n    }\n  });\n  const mapComponents = (c) => world[$componentMap].get(c);\n  const allComponents = components2.concat(notComponents).map(mapComponents);\n  const sparseSet = SparseSet();\n  const archetypes = [];\n  const changed = [];\n  const toRemove = SparseSet();\n  const entered = SparseSet();\n  const exited = SparseSet();\n  const generations = allComponents.map((c) => c.generationId).reduce((a, v) => {\n    if (a.includes(v))\n      return a;\n    a.push(v);\n    return a;\n  }, []);\n  const reduceBitflags = (a, c) => {\n    if (!a[c.generationId])\n      a[c.generationId] = 0;\n    a[c.generationId] |= c.bitflag;\n    return a;\n  };\n  const masks = components2.map(mapComponents).reduce(reduceBitflags, {});\n  const notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {});\n  const hasMasks = allComponents.reduce(reduceBitflags, {});\n  const flatProps = components2.filter((c) => !c[$tagStore]).map((c) => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c]).reduce((a, v) => a.concat(v), []);\n  const shadows = [];\n  const q = Object.assign(sparseSet, {\n    archetypes,\n    changed,\n    components: components2,\n    notComponents,\n    changedComponents,\n    allComponents,\n    masks,\n    notMasks,\n    hasMasks,\n    generations,\n    flatProps,\n    toRemove,\n    entered,\n    exited,\n    shadows\n  });\n  world[$queryMap].set(query, q);\n  world[$queries].add(q);\n  allComponents.forEach((c) => {\n    c.queries.add(q);\n  });\n  if (notComponents.length)\n    world[$notQueries].add(q);\n  for (let eid = 0; eid < getEntityCursor(); eid++) {\n    if (!world[$entitySparseSet].has(eid))\n      continue;\n    const match = queryCheckEntity(world, q, eid);\n    if (match)\n      queryAddEntity(q, eid);\n  }\n};\nvar generateShadow = (q, pid) => {\n  const $ = Symbol();\n  const prop = q.flatProps[pid];\n  createShadow(prop, $);\n  q.shadows[pid] = prop[$];\n  return prop[$];\n};\nvar diff = (q, clearDiff) => {\n  if (clearDiff)\n    q.changed = [];\n  const { flatProps, shadows } = q;\n  for (let i = 0; i < q.dense.length; i++) {\n    const eid = q.dense[i];\n    let dirty = false;\n    for (let pid = 0; pid < flatProps.length; pid++) {\n      const prop = flatProps[pid];\n      const shadow = shadows[pid] || generateShadow(q, pid);\n      if (ArrayBuffer.isView(prop[eid])) {\n        for (let i2 = 0; i2 < prop[eid].length; i2++) {\n          if (prop[eid][i2] !== shadow[eid][i2]) {\n            dirty = true;\n            break;\n          }\n        }\n        shadow[eid].set(prop[eid]);\n      } else {\n        if (prop[eid] !== shadow[eid]) {\n          dirty = true;\n          shadow[eid] = prop[eid];\n        }\n      }\n    }\n    if (dirty)\n      q.changed.push(eid);\n  }\n  return q.changed;\n};\nvar flatten = (a, v) => a.concat(v);\nvar aggregateComponentsFor = (mod) => (x) => x.filter((f) => f.name === mod().constructor.name).reduce(flatten);\nvar getAnyComponents = aggregateComponentsFor(Any);\nvar getAllComponents = aggregateComponentsFor(All);\nvar getNoneComponents = aggregateComponentsFor(None);\nvar defineQuery = (...args) => {\n  let components2;\n  let any, all, none;\n  if (Array.isArray(args[0])) {\n    components2 = args[0];\n  } else {\n  }\n  if (components2 === void 0 || components2[$componentMap] !== void 0) {\n    return (world) => world ? world[$entityArray] : components2[$entityArray];\n  }\n  const query = function(world, clearDiff = true) {\n    if (!world[$queryMap].has(query))\n      registerQuery(world, query);\n    const q = world[$queryMap].get(query);\n    commitRemovals(world);\n    if (q.changedComponents.length)\n      return diff(q, clearDiff);\n    return q.dense;\n  };\n  query[$queryComponents] = components2;\n  query[$queryAny] = any;\n  query[$queryAll] = all;\n  query[$queryNone] = none;\n  return query;\n};\nvar queryCheckEntity = (world, q, eid) => {\n  const { masks, notMasks, generations } = q;\n  let or = 0;\n  for (let i = 0; i < generations.length; i++) {\n    const generationId = generations[i];\n    const qMask = masks[generationId];\n    const qNotMask = notMasks[generationId];\n    const eMask = world[$entityMasks][generationId][eid];\n    if (qNotMask && (eMask & qNotMask) !== 0) {\n      return false;\n    }\n    if (qMask && (eMask & qMask) !== qMask) {\n      return false;\n    }\n  }\n  return true;\n};\nvar queryAddEntity = (q, eid) => {\n  q.toRemove.remove(eid);\n  q.entered.add(eid);\n  q.add(eid);\n};\nvar queryCommitRemovals = (q) => {\n  for (let i = q.toRemove.dense.length - 1; i >= 0; i--) {\n    const eid = q.toRemove.dense[i];\n    q.toRemove.remove(eid);\n    q.remove(eid);\n  }\n};\nvar commitRemovals = (world) => {\n  if (!world[$dirtyQueries].size)\n    return;\n  world[$dirtyQueries].forEach(queryCommitRemovals);\n  world[$dirtyQueries].clear();\n};\nvar queryRemoveEntity = (world, q, eid) => {\n  if (!q.has(eid) || q.toRemove.has(eid))\n    return;\n  q.toRemove.add(eid);\n  world[$dirtyQueries].add(q);\n  q.exited.add(eid);\n};\nvar resetChangedQuery = (world, query) => {\n  const q = world[$queryMap].get(query);\n  q.changed = [];\n};\nvar removeQuery = (world, query) => {\n  const q = world[$queryMap].get(query);\n  world[$queries].delete(q);\n  world[$queryMap].delete(query);\n};\n\n// src/Component.js\nvar $componentMap = Symbol(\"componentMap\");\nvar components = [];\nvar defineComponent = (schema, size) => {\n  const component = createStore(schema, size || getGlobalSize());\n  if (schema && Object.keys(schema).length)\n    components.push(component);\n  return component;\n};\nvar incrementBitflag = (world) => {\n  world[$bitflag] *= 2;\n  if (world[$bitflag] >= 2 ** 31) {\n    world[$bitflag] = 1;\n    world[$entityMasks].push(new Uint32Array(world[$size]));\n  }\n};\nvar registerComponent = (world, component) => {\n  if (!component)\n    throw new Error(`bitECS - Cannot register null or undefined component`);\n  const queries = /* @__PURE__ */ new Set();\n  const notQueries = /* @__PURE__ */ new Set();\n  const changedQueries = /* @__PURE__ */ new Set();\n  world[$queries].forEach((q) => {\n    if (q.allComponents.includes(component)) {\n      queries.add(q);\n    }\n  });\n  world[$componentMap].set(component, {\n    generationId: world[$entityMasks].length - 1,\n    bitflag: world[$bitflag],\n    store: component,\n    queries,\n    notQueries,\n    changedQueries\n  });\n  incrementBitflag(world);\n};\nvar registerComponents = (world, components2) => {\n  components2.forEach((c) => registerComponent(world, c));\n};\nvar hasComponent = (world, component, eid) => {\n  const registeredComponent = world[$componentMap].get(component);\n  if (!registeredComponent)\n    return false;\n  const { generationId, bitflag } = registeredComponent;\n  const mask = world[$entityMasks][generationId][eid];\n  return (mask & bitflag) === bitflag;\n};\nvar addComponent = (world, component, eid, reset = false) => {\n  if (eid === void 0)\n    throw new Error(\"bitECS - entity is undefined.\");\n  if (!world[$entitySparseSet].has(eid))\n    throw new Error(\"bitECS - entity does not exist in the world.\");\n  if (!world[$componentMap].has(component))\n    registerComponent(world, component);\n  if (hasComponent(world, component, eid))\n    return;\n  const c = world[$componentMap].get(component);\n  const { generationId, bitflag, queries, notQueries } = c;\n  world[$entityMasks][generationId][eid] |= bitflag;\n  queries.forEach((q) => {\n    q.toRemove.remove(eid);\n    const match = queryCheckEntity(world, q, eid);\n    if (match) {\n      q.exited.remove(eid);\n      queryAddEntity(q, eid);\n    }\n    if (!match) {\n      q.entered.remove(eid);\n      queryRemoveEntity(world, q, eid);\n    }\n  });\n  world[$entityComponents].get(eid).add(component);\n  if (reset)\n    resetStoreFor(component, eid);\n};\nvar removeComponent = (world, component, eid, reset = true) => {\n  if (eid === void 0)\n    throw new Error(\"bitECS - entity is undefined.\");\n  if (!world[$entitySparseSet].has(eid))\n    throw new Error(\"bitECS - entity does not exist in the world.\");\n  if (!hasComponent(world, component, eid))\n    return;\n  const c = world[$componentMap].get(component);\n  const { generationId, bitflag, queries } = c;\n  world[$entityMasks][generationId][eid] &= ~bitflag;\n  queries.forEach((q) => {\n    q.toRemove.remove(eid);\n    const match = queryCheckEntity(world, q, eid);\n    if (match) {\n      q.exited.remove(eid);\n      queryAddEntity(q, eid);\n    }\n    if (!match) {\n      q.entered.remove(eid);\n      queryRemoveEntity(world, q, eid);\n    }\n  });\n  world[$entityComponents].get(eid).delete(component);\n  if (reset)\n    resetStoreFor(component, eid);\n};\n\n// src/World.js\nvar $size = Symbol(\"size\");\nvar $resizeThreshold = Symbol(\"resizeThreshold\");\nvar $bitflag = Symbol(\"bitflag\");\nvar $archetypes = Symbol(\"archetypes\");\nvar $localEntities = Symbol(\"localEntities\");\nvar $localEntityLookup = Symbol(\"localEntityLookup\");\nvar $manualEntityRecycling = Symbol(\"manualEntityRecycling\");\nvar worlds = [];\nvar resizeWorlds = (size) => {\n  worlds.forEach((world) => {\n    world[$size] = size;\n    for (let i = 0; i < world[$entityMasks].length; i++) {\n      const masks = world[$entityMasks][i];\n      world[$entityMasks][i] = resize(masks, size);\n    }\n    world[$resizeThreshold] = world[$size] - world[$size] / 5;\n  });\n};\nvar createWorld = (...args) => {\n  const world = typeof args[0] === \"object\" ? args[0] : {};\n  const size = typeof args[0] === \"number\" ? args[0] : typeof args[1] === \"number\" ? args[1] : getGlobalSize();\n  resetWorld(world, size);\n  worlds.push(world);\n  return world;\n};\nvar enableManualEntityRecycling = (world) => {\n  world[$manualEntityRecycling] = true;\n};\nvar resetWorld = (world, size = getGlobalSize()) => {\n  world[$size] = size;\n  if (world[$entityArray])\n    world[$entityArray].forEach((eid) => removeEntity(world, eid));\n  world[$entityMasks] = [new Uint32Array(size)];\n  world[$entityComponents] = /* @__PURE__ */ new Map();\n  world[$archetypes] = [];\n  world[$entitySparseSet] = SparseSet();\n  world[$entityArray] = world[$entitySparseSet].dense;\n  world[$bitflag] = 1;\n  world[$componentMap] = /* @__PURE__ */ new Map();\n  world[$queryMap] = /* @__PURE__ */ new Map();\n  world[$queries] = /* @__PURE__ */ new Set();\n  world[$notQueries] = /* @__PURE__ */ new Set();\n  world[$dirtyQueries] = /* @__PURE__ */ new Set();\n  world[$localEntities] = /* @__PURE__ */ new Map();\n  world[$localEntityLookup] = /* @__PURE__ */ new Map();\n  world[$manualEntityRecycling] = false;\n  return world;\n};\nvar deleteWorld = (world) => {\n  Object.getOwnPropertySymbols(world).forEach(($) => {\n    delete world[$];\n  });\n  Object.keys(world).forEach((key) => {\n    delete world[key];\n  });\n  worlds.splice(worlds.indexOf(world), 1);\n};\nvar getWorldComponents = (world) => Array.from(world[$componentMap].keys());\nvar getAllEntities = (world) => world[$entitySparseSet].dense.slice(0);\n\n// src/System.js\nvar defineSystem = (update) => (world, ...args) => {\n  update(world, ...args);\n  return world;\n};\n\n// src/index.js\nvar pipe = (...fns) => (input) => {\n  let tmp = input;\n  for (let i = 0; i < fns.length; i++) {\n    const fn = fns[i];\n    tmp = fn(tmp);\n  }\n  return tmp;\n};\nvar Types = TYPES_ENUM;\nexport {\n  Changed,\n  DESERIALIZE_MODE,\n  Not,\n  Types,\n  addComponent,\n  addEntity,\n  commitRemovals,\n  createWorld,\n  defineComponent,\n  defineDeserializer,\n  defineQuery,\n  defineSerializer,\n  defineSystem,\n  deleteWorld,\n  enableManualEntityRecycling,\n  enterQuery,\n  entityExists,\n  exitQuery,\n  flushRemovedEntities,\n  getAllEntities,\n  getEntityComponents,\n  getWorldComponents,\n  hasComponent,\n  parentArray,\n  pipe,\n  registerComponent,\n  registerComponents,\n  removeComponent,\n  removeEntity,\n  removeQuery,\n  resetChangedQuery,\n  resetGlobals,\n  resetWorld,\n  setDefaultSize,\n  setRemovedRecycleThreshold\n};\n//# sourceMappingURL=index.mjs.map\n"],"names":["root","factory","exports","module","define","amd","window","global","self","this","createWorld","defineComponent","removeComponent","removeEntity","entityExists","addEntity","addComponent","getEntityComponents","defaultGetGroupedValue","value","i","types","key","type","Array","isArray","slice","defaultSetGroupedValue","_types","_key","BitECSStorage","constructor","storage","options","super","actors","Map","components","entities","inputs","set","Boolean","Number","String","worldOptions","world","eids","destroyActor","id","destroyId","destroyComponent","eid","getEID","Component","get","updateIndexes","prevValue","fetchComponentProcess","indexes","index","isActor","remove","has","delete","destroyEntity","list","fetchComponents","fetchComponent","undefined","schema","prop","getActors","query","pageSize","keys","paginate","getComponents","ids","pages","compEntries","entries","compLookup","map","page","entity","forEach","val","getEntities","getInputs","isEntity","setActors","setComponents","setEntities","setInputs","storeActor","storeId","storeComponent","storeEntity","storeInput","input","tick","TYPES_ENUM","TYPES_NAMES","i8","ui8","ui8c","i16","ui16","i32","ui32","f32","f64","TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","roundToMultiple4","x","Math","ceil","$storeRef","Symbol","$storeSize","$storeMaps","$storeFlattened","$storeBase","$storeType","$storeArrayElementCounts","$storeSubarrays","$subarrayCursors","$subarray","$parentArray","$tagStore","$indexType","$indexBytes","$isEidType","stores","resetStoreFor","store","ta","ArrayBuffer","isView","fill","isArrayType","SparseSet","dense","sparse","sort","comparator","result","prototype","call","length","add","push","swapped","pop","reset","not","fn","v","isModifier","c","$modifier","$entityMasks","$entityComponents","$entitySparseSet","$entityArray","defaultSize","globalEntityCursor","globalSize","getGlobalSize","removed","recycled","eidToWorld","$manualEntityRecycling","shift","round","$size","Error","$notQueries","q","queryCheckEntity","queryAddEntity","Set","$queries","queryRemoveEntity","$localEntities","$localEntityLookup","from","$queryMap","$dirtyQueries","flatten","Object","freeze","a","concat","aggregateComponentsFor","mod","filter","f","name","reduce","comps","masks","notMasks","generations","generationId","qMask","qNotMask","eMask","toRemove","entered","exited","$componentMap","size","component","$store","JSON","parse","stringify","arrayElementCounts","collectArrayElementCounts","s","k","metadata","recursiveTransform","totalBytes","BYTES_PER_ELEMENT","buffer","createTypeStore","storeSize","cursors","indexType","arrayElementCount","array","start","end","subarray","start2","end2","createArrayStore","assign","createStore","hasComponent","registeredComponent","bitflag","queries","notQueries","changedQueries","allComponents","includes","$bitflag","incrementBitflag","registerComponent","match","$archetypes","worlds","args","resetWorld"],"sourceRoot":""}