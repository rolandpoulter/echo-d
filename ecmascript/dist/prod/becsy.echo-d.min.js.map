{"version":3,"file":"becsy.echo-d.min.js","mappings":"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","sources":["webpack://echoD/webpack/universalModuleDefinition","webpack://echoD/./lib/extra/storage/becsy.js","webpack://echoD/./lib/storage/async.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echoD\"] = factory();\n\telse\n\t\troot[\"echoD\"] = factory();\n})(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : this, () => {\nreturn ","import { AsyncStorage, } from '../../storage/async.js';\nimport { ArrayTypes } from '../../types.js';\nimport { paginate, now } from '../../utils.js';\nconst { \n// System,\n// Type,\nWorld } = await import('@lastolivegames/becsy/index.js');\n/*\nexport function defaultGetGroupedValue (value: any | any[], i: number, types: Types, key: string): any {\n    const type = types[key]\n    if (Array.isArray(type)) {\n        return value.slice(i * type[1], (i + 1) * type[1])\n    }\n    return value[i]\n}\n\nexport function defaultSetGroupedValue (value: any, _types: Types, _key: string): any {\n    return value;\n}\n*/\nexport class BecsyStorage extends AsyncStorage {\n    // declare eids: Map<string, any>;\n    constructor(storage, options) {\n        super({\n            ...(storage || {}),\n            actors: new Map(),\n            components: new Map(),\n            entities: new Map(),\n            // inputs: new Map(),\n            inputs: null,\n        }, options);\n        const { \n        // types,\n        // indexes,\n        worldOptions = { defs: [] }, world = null, } = options;\n        for (let key in this.types) {\n            const type = this.types[key];\n            if (typeof type[0] === 'string') {\n                this.components.set(key, type[2]);\n            }\n            else\n                switch (type) {\n                    case Boolean:\n                    case Number:\n                    case String:\n                        this.components.set(key, new Map());\n                        break;\n                }\n        }\n        if (worldOptions && !worldOptions.defs) {\n            worldOptions.defs = [];\n        }\n        // if (!((worldOptions as WorldOptions).defs as any[]).length) {\n        for (let component of this.components.values()) {\n            if (!component) {\n                continue;\n            }\n            if (component instanceof Map) {\n                continue;\n            }\n            if (worldOptions.defs.indexOf(component) === -1) {\n                worldOptions.defs.push(component);\n            }\n        }\n        // }\n        this.worldOptions = worldOptions;\n        this.world = world || World.create(this.worldOptions);\n        /*\n        this.eids = storage?.eids || new Map();\n        \n        for (let key in this.actors) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.entities) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.components) {\n            for (let id in this.components[key]) {\n                addComponent(this.world, this.components[key][id], this.ids[id]);\n            }\n        }\n        */\n    }\n    async cleanup() {\n        const world = await this.world;\n        try {\n            world.__dispatcher.registry.releaseComponentTypes();\n            await world.terminate();\n        }\n        catch (err) {\n            // console.warn(err)\n        }\n    }\n    derefEntity(id) {\n        if (this.actors.has(id)) {\n            return this.actors.get(id);\n        }\n        if (this.entities.has(id)) {\n            return this.entities.get(id);\n        }\n        return;\n    }\n    async destroyActor(id) {\n        return this.destroyId(this.actors, id);\n    }\n    async destroyComponent(id, key) {\n        const entity = this.derefEntity(id);\n        const Component = this.components.get(key);\n        if (entity === null || entity === undefined || !Component) {\n            return;\n        }\n        const updateIndexes = () => {\n            const prevValue = this.findComponent(id, key);\n            this.removeComponentsIndex(id, key, prevValue);\n        };\n        if (Component instanceof Map) {\n            const entity = Component.get(id);\n            if (entity) {\n                Component.delete(id);\n            }\n            updateIndexes();\n        }\n        else {\n            // removeComponent(this.world, Component, eid);\n            updateIndexes();\n        }\n    }\n    async destroyEntity(id) {\n        return this.destroyId(this.entities, id);\n    }\n    async destroyId(list, id) {\n        const entity = list.get(id);\n        if (entity) {\n            entity.delete();\n            list.delete(id);\n            return true;\n        }\n        return false;\n    }\n    async findComponents(id) {\n        const entity = this.derefEntity(id);\n        if (entity === null || entity === undefined) {\n            return;\n        }\n        return entity;\n    }\n    findComponent(id, key) {\n        const _ = undefined;\n        return this.findComponentProcess(id, key, _, _);\n    }\n    findComponentProcess(id, key, entity, Component) {\n        entity = (entity === null || entity === undefined) ? this.derefEntity(id) : entity;\n        Component = Component || this.components.get(key);\n        if (entity === null || entity === undefined || !Component) {\n            return;\n        }\n        if (Component instanceof Map) {\n            return Component.get(id);\n        }\n        else {\n            const type = this.types[key];\n            const schema = type[3];\n            const Type = ArrayTypes.get(type[0]);\n            const size = type[1];\n            const value = new Type(size);\n            const view = entity.has(Component) ? entity.read(Component) : undefined;\n            let i = 0;\n            if (view === null || view === undefined) {\n                return value;\n            }\n            for (let prop in schema) {\n                if (prop === '$val') {\n                    value.set(view);\n                    break;\n                }\n                value[i] = view[prop];\n                i++;\n            }\n            return value;\n        }\n    }\n    getActors(query = null, pageSize) {\n        if (query !== null) {\n            return super.getActors(query, pageSize);\n        }\n        const actors = Array.from(this.actors.keys());\n        const pages = paginate(actors, pageSize);\n        return pages;\n        // return new Emitter<string[][]>(pages, true)\n    }\n    getComponents(query = null, pageSize) {\n        // const queryKeys = Object.keys(query);\n        // const entities = this.world.with(...queryKeys);\n        let ids;\n        if (query !== null) {\n            ids = query;\n        }\n        else {\n            const actors = this.actors.keys();\n            const entities = this.entities.keys();\n            ids = [\n                ...actors,\n                ...entities\n            ];\n        }\n        const pages = paginate(ids, pageSize);\n        const _ = undefined;\n        return pages.map((page) => {\n            const components = {};\n            for (let id of page) {\n                const entity = this.derefEntity(id);\n                if (entity === null || entity === undefined) {\n                    continue;\n                }\n                const compList = this.componentsIndex.get(id);\n                const component = {};\n                for (let key of compList) {\n                    component[key] = this.findComponentProcess(id, key, entity, _);\n                }\n                components[id] = component;\n            }\n            return components;\n        });\n        // return pages;\n        // return new Emitter<Components[]>(pages, true)\n    }\n    getEntities(query = null, pageSize) {\n        if (query !== null) {\n            return super.getEntities(query, pageSize);\n        }\n        const entities = this.entities.keys();\n        const pages = paginate(entities, pageSize);\n        return pages;\n        // return new Emitter<string[][]>(pages, true)\n    }\n    getInputs(query = null, pageSize) {\n        return super.getInputs(query, pageSize);\n    }\n    isActor(id) {\n        return this.actors.has(id);\n    }\n    isEntity(id) {\n        return this.entities.has(id);\n    }\n    async setActors(actors) {\n        return super.setActors(actors);\n    }\n    async setComponents(components) {\n        return super.setComponents(components);\n    }\n    async setEntities(entities) {\n        return super.setEntities(entities);\n    }\n    async setInputs(inputs) {\n        return super.setInputs(inputs);\n    }\n    async storeActor(id) {\n        return await this.storeId(this.actors, id);\n    }\n    async storeComponent(id, key, value) {\n        const entity = this.derefEntity(id);\n        if (entity !== null && entity !== undefined) {\n            const Component = this.components.get(key);\n            if (!Component) {\n                return;\n            }\n            if (!entity.has(Component)) {\n                entity.add(Component, {});\n            }\n            let prevValue = [];\n            if (Component instanceof Map) {\n                prevValue = Component.get(id);\n                Component.set(id, value);\n            }\n            else {\n                // entity[key] = value\n                const type = this.types[key];\n                const schema = type[3];\n                const component = entity.write(Component);\n                let i = 0;\n                for (let prop in schema) {\n                    if (prop === '$val') {\n                        component.set(value);\n                        break;\n                    }\n                    component[prop] = value[i];\n                    i++;\n                }\n                // const world = await this.world;\n                // world.addComponent(entity, key, component);\n            }\n            await this.updateComponentsIndex(id, key, prevValue, value);\n        }\n    }\n    async storeEntity(id) {\n        return await this.storeId(this.entities, id);\n    }\n    async storeId(list, id) {\n        let entity = list.get(id);\n        if (entity === null || entity === undefined) {\n            const world = await this.world;\n            const entity = world.__dispatcher.createEntity([] // (this.worldOptions.defaultComponents || this.worldOptions.defs)\n            );\n            const reference = entity.__registry.holdEntity(entity.__id);\n            // const reference = entity.hold();\n            list.set(id, reference);\n            return true;\n        }\n        return false;\n    }\n    async storeInput(id, input, tick = now()) {\n        return super.storeInput(id, input, tick);\n    }\n}\n","import { createStorageProps, Storage, } from '../storage.js';\nconst StoragePrototype = Storage.prototype;\n/**\n * The AsyncStorage class represents an asynchronous store with actors, entities, components, and inputs.\n *\n * @property {string[]} actors - The actors in the store.\n * @property {string[]} entities - The entities in the store.\n * @property {Components} components - The components in the store.\n * @property {Inputs} inputs - The inputs in the store.\n * @property {Inputs} inputs - The inputs in the store.\n */\nexport class AsyncStorage {\n    /**\n     * Constructs a new AsyncStorage object.\n     *\n     * @param {StorageProps} storage - The properties of the store.\n     */\n    constructor(storage = {}, options = {}) {\n        createStorageProps(this, storage, options);\n    }\n    /**\n     * Removes an actor ID asynchronously.\n     *\n     * @param {string} id - The ID of the actor to remove.\n     * @returns {Promise<boolean>} A Promise that resolves with true if the actor ID was removed, false otherwise.\n     */\n    async destroyActor(id) {\n        return StoragePrototype.destroyActor.call(this, id);\n    }\n    /**\n     * Removes a component asynchronously.\n     *\n     * @param {string} id - The ID of the component to remove.\n     * @param {string} key - The key of the component to remove.\n     */\n    async destroyComponent(id, key) {\n        return StoragePrototype.destroyComponent.call(this, id, key);\n    }\n    /**\n     * Removes an entity ID asynchronously.\n     *\n     * @param {string} id - The ID of the entity to remove.\n     * @returns {Promise<boolean>} A Promise that resolves with true if the entity ID was removed, false otherwise.\n     */\n    async destroyEntity(id) {\n        return StoragePrototype.destroyEntity.call(this, id);\n    }\n    /**\n     * Removes an ID from a list if it exists asynchronously.\n     *\n     * @param {string[]} list - The list to remove the ID from.\n     * @param {string} id - The ID to remove.\n     * @returns {Promise<boolean>} A Promise that resolves with true if the ID was removed, false otherwise.\n     */\n    async destroyId(list, id) {\n        return StoragePrototype.destroyId.call(this, list, id);\n    }\n    /**\n     * Fetches a components container for an entity.\n     *\n     * @param {string} id - The ID of the entity.\n     * @returns {Components} The fetched components container.\n     */\n    async findComponents(id) {\n        return StoragePrototype.findComponents.call(this, id);\n    }\n    /**\n     * Fetches a component.\n     *\n     * @param {string} id - The ID of the component to fetch.\n     * @param {string} key - The key of the component to fetch.\n     * @returns {any} The fetched component.\n     */\n    async findComponent(id, key) {\n        return StoragePrototype.findComponent.call(this, id, key);\n    }\n    /**\n     * Fetches an actors inputs\n     *\n     * @param {string} id - The ID of the actor.\n     * @returns {InputPayload} The fetched inputs.\n     */\n    async findInputs(id) {\n        return StoragePrototype.findInputs.call(this, id);\n    }\n    /**\n     * Fetches an actors input\n     *\n     * @param {string} id - The ID of the actor.\n     * @param {number} index - The index of the input.\n     * @returns {InputPayload} The fetched inputs.\n     */\n    async findInput(id, index) {\n        return StoragePrototype.findInput.call(this, id, index);\n    }\n    /**\n     * Gets the actors.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {string[][]} The actors.\n     */\n    getActors(query = null, pageSize = Infinity) {\n        const pages = StoragePrototype.getActors.call(this, query, pageSize);\n        return pages;\n        // const emitter = new Emitter<string[][]>(pages as string[][], true); \n        // return emitter;\n    }\n    /**\n     * Gets the components.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {Components} The components.\n     */\n    getComponents(query = null, pageSize = Infinity) {\n        const pages = StoragePrototype.getComponents.call(this, query, pageSize);\n        return pages;\n        // const emitter = new Emitter<Components[]>(pages as Components[], true); \n        // return emitter;\n    }\n    /**\n     * Gets the entities.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {string[]} The entities.\n     */\n    getEntities(query = null, pageSize = Infinity) {\n        const pages = StoragePrototype.getEntities.call(this, query, pageSize);\n        return pages;\n        // const emitter = new Emitter<string[][]>(pages as string[][], true); \n        // return emitter;\n    }\n    /**\n     * Gets the inputs.\n     *\n     * @returns {Inputs} The inputs.\n     */\n    getInputs(query = null, pageSize = Infinity) {\n        const pages = StoragePrototype.getInputs.call(this, query, pageSize);\n        return pages;\n        // const emitter = new Emitter<Inputs[]>(pages as Inputs[], true); \n        // return emitter;\n    }\n    /**\n     * Checks if an ID is an actor.\n     *\n     * @param {string} id - The ID to check.\n     * @returns {boolean} True if the ID is an actor, false otherwise.\n     */\n    isActor(id) {\n        return StoragePrototype.isActor.call(this, id);\n    }\n    /**\n     * Checks if an ID is an entity.\n     *\n     * @param {string} id - The ID to check.\n     * @returns {boolean} True if the ID is an entity, false otherwise.\n     */\n    isEntity(id) {\n        return StoragePrototype.isEntity.call(this, id);\n    }\n    /**\n     * Sets the actors.\n     *\n     * @param {string[]} actors - The actors to set.\n     * @returns {string[]} The actors.\n     */\n    async setActors(actors) {\n        return StoragePrototype.setActors.call(this, actors);\n    }\n    /**\n     * Sets the components.\n     *\n     * @param {Components} components - The components to set.\n     * @returns {Components} The components.\n     */\n    async setComponents(components) {\n        return StoragePrototype.setComponents.call(this, components);\n    }\n    /**\n     * Sets the entities.\n     *\n     * @param {string[]} entities - The entities to set.\n     * @returns {string[]} The entities.\n     */\n    async setEntities(entities) {\n        return StoragePrototype.setEntities.call(this, entities);\n    }\n    /**\n     * Sets the inputs.\n     *\n     * @param {Inputs} inputs - The inputs to set.\n     * @returns {Inputs} The inputs.\n     */\n    async setInputs(inputs) {\n        return StoragePrototype.setInputs.call(this, inputs);\n    }\n    /**\n     * Stores an actor ID.\n     *\n     * @param {string} id - The ID of the actor to store.\n     * @returns {boolean} True if the actor ID was stored, false otherwise.\n     */\n    async storeActor(id) {\n        return StoragePrototype.storeActor.call(this, id);\n    }\n    /**\n     * Stores a component.\n     *\n     * @param {string} id - The ID of the component to store.\n     * @param {string} key - The key of the component to store.\n     * @param {any} value - The value of the component to store.\n     */\n    async storeComponent(id, key, value) {\n        return StoragePrototype.storeComponent.call(this, id, key, value);\n    }\n    /**\n     * Stores an entity ID.\n     *\n     * @param {string} id - The ID of the entity to store.\n     * @returns {boolean} True if the entity ID was stored, false otherwise.\n     */\n    async storeEntity(id) {\n        return StoragePrototype.storeEntity.call(this, id);\n    }\n    /**\n     * Stores an ID in a list if it doesn't exist already.\n     *\n     * @param {string[]} list - The list to store the ID in.\n     * @param {string} id - The ID to store.\n     * @returns {boolean} True if the ID was stored, false otherwise.\n     */\n    async storeId(list, id) {\n        return StoragePrototype.storeId.call(this, list, id);\n    }\n    /**\n     * Stores an input.\n     *\n     * @param {string} id - The ID of the input to store.\n     * @param {InputPayload} input - The payload of the input to store.\n     * @returns {number} The new index of the stored input.\n     */\n    async storeInput(id, input, tick = 0) {\n        return StoragePrototype.storeInput.call(this, id, input, tick);\n    }\n    /**\n     * Queries the store for entities by component.\n     *\n     * @param {any} query - The query to use.\n     * @returns {Set<any>} The entities.\n     */\n    queryComponents(query) {\n        return StoragePrototype.queryComponents.call(this, query);\n    }\n    /**\n   * Removes a component from the components index.\n   *\n   * @param {string} id - The ID of the component to remove.\n   * @param {string} key - The key of the component to remove.\n   * @param {any} prevValue - The previous value of the component.\n   * @returns {void}\n   */\n    removeComponentsIndex(id, key, prevValue) {\n        StoragePrototype.removeComponentsIndex.call(this, id, key, prevValue);\n    }\n    /**\n     * Updates a component in the components index.\n     *\n     * @param {string} id - The ID of the component to update.\n     * @param {string} key - The key of the component to update.\n     * @param {any} prevValue - The previous value of the component.\n     * @param {any} value - The new value of the component.\n     * @returns {void}\n     */\n    updateComponentsIndex(id, key, prevValue, value) {\n        StoragePrototype.updateComponentsIndex.call(this, id, key, prevValue, value);\n    }\n}\n"],"names":["root","factory","exports","module","define","amd","window","global","self","this","World","BecsyStorage","constructor","storage","options","super","actors","Map","components","entities","inputs","worldOptions","defs","world","key","types","type","set","Boolean","Number","String","component","values","indexOf","push","create","async","__dispatcher","registry","releaseComponentTypes","terminate","err","derefEntity","id","has","get","destroyId","entity","Component","updateIndexes","prevValue","findComponent","removeComponentsIndex","delete","list","_","undefined","findComponentProcess","schema","value","view","read","i","prop","getActors","query","pageSize","Array","from","keys","paginate","getComponents","ids","map","page","compList","componentsIndex","getEntities","getInputs","isActor","isEntity","setActors","setComponents","setEntities","setInputs","storeId","add","write","updateComponentsIndex","createEntity","reference","__registry","holdEntity","__id","input","tick","now","storeInput","StoragePrototype","AsyncStorage","destroyActor","call","destroyComponent","destroyEntity","findComponents","findInputs","index","findInput","Infinity","storeActor","storeComponent","storeEntity","queryComponents"],"sourceRoot":""}