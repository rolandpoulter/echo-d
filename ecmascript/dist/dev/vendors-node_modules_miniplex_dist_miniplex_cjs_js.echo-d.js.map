{"version":3,"file":"vendors-node_modules_miniplex_dist_miniplex_cjs_js.echo-d.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEc;;;;;;;;;;;;;;;ACTd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;ACvBU;;AAEjC;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAAK;AACpD;AACA;AACA;AACA,iDAAiD,2CAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAEiB;;;;;;;;;;;ACxTL;;AAEb,8CAA6C,EAAE,aAAa,EAAC;;AAE7D;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8BAA8B;AAC5D;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,0EAA0E,aAAa;AACvF;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;AAED,aAAa;;;;;;;;;;;ACvQA;;AAEb,8CAA6C,EAAE,aAAa,EAAC;;AAE7D,aAAa,mBAAO,CAAC,qFAAkB;AACvC,SAAS,mBAAO,CAAC,gEAAW;AAC5B,cAAc,mBAAO,CAAC,yEAAc;;AAEpC;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gFAAgF,aAAa;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mFAAmF,eAAe;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mFAAmF,eAAe;AAClG;AACA;AACA,8DAA8D,kBAAkB;AAChF;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mFAAmF,eAAe;AAClG;AACA;AACA,8DAA8D,kBAAkB;AAChF;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8DAA8D,kBAAkB;AAChF;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAAyC;AACzC;AACA,qBAAqB;AACrB,CAAC,EAAC;AACF,aAAa;AACb,aAAa;AACb,aAAa;;;;;;;;;;;AClxBA;;AAEb,IAAI,KAAqC,EAAE,EAE1C,CAAC;AACF,EAAE,qHAAiD;AACnD","sources":["webpack://echoD/./node_modules/@hmans/id/dist/hmans-id.esm.js","webpack://echoD/./node_modules/@hmans/queue/dist/hmans-queue.esm.js","webpack://echoD/./node_modules/@miniplex/bucket/dist/miniplex-bucket.esm.js","webpack://echoD/./node_modules/eventery/dist/eventery.cjs.dev.js","webpack://echoD/./node_modules/miniplex/dist/miniplex.cjs.dev.js","webpack://echoD/./node_modules/miniplex/dist/miniplex.cjs.js"],"sourcesContent":["var entityToId = new WeakMap();\nvar nextId = 0;\nvar id = function id(object) {\n  var id = entityToId.get(object);\n  if (id !== undefined) return id;\n  entityToId.set(object, nextId);\n  return nextId++;\n};\n\nexport { id };\n","function createQueue() {\n  var queue = new Array();\n\n  function add(fn) {\n    queue.push(fn);\n  }\n\n  function clear() {\n    queue.length = 0;\n  }\n\n  function flush() {\n    queue.forEach(function (fn) {\n      return fn();\n    });\n    clear();\n  }\n\n  add.clear = clear;\n  add.flush = flush;\n  return add;\n}\n\nexport { createQueue };\n","import { Event } from 'eventery';\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nvar _Symbol$iterator;\n\n/**\n * A class wrapping an array of entities of a specific type, providing\n * performance-optimized methods for adding, looking up and removing entities, and events\n * for when entities are added or removed.\n */\n_Symbol$iterator = Symbol.iterator;\nvar Bucket = /*#__PURE__*/function () {\n  function Bucket() {\n    var _entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classCallCheck(this, Bucket);\n    /* VERSIONING */\n    _defineProperty(this, \"_version\", 0);\n    /**\n     * Fired when an entity has been added to the bucket.\n     */\n    _defineProperty(this, \"onEntityAdded\", new Event());\n    /**\n     * Fired when an entity is about to be removed from the bucket.\n     */\n    _defineProperty(this, \"onEntityRemoved\", new Event());\n    /**\n     * A map of entity positions, used for fast lookups.\n     */\n    _defineProperty(this, \"entityPositions\", new Map());\n    this._entities = _entities;\n    this.add = this.add.bind(this);\n    this.remove = this.remove.bind(this);\n\n    /* Register all entity positions */\n    for (var i = 0; i < _entities.length; i++) {\n      this.entityPositions.set(_entities[i], i);\n    }\n  }\n  _createClass(Bucket, [{\n    key: \"version\",\n    get:\n    /**\n     * The current version of the bucket. Increases every time an entity is\n     * added or removed.\n     */\n    function get() {\n      return this._version;\n    }\n\n    /**\n     * An array of all entities within the bucket. Please note that for iterating\n     * over the entities in this bucket, it is recommended that you use the\n     * `for (const entity of bucket)` iterator form.\n     */\n  }, {\n    key: \"entities\",\n    get: function get() {\n      return this._entities;\n    }\n\n    /* Custom iterator that iterates over all entities in reverse order. */\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      var _this = this;\n      var index = this._entities.length;\n      var result = {\n        value: undefined,\n        done: false\n      };\n      return {\n        next: function next() {\n          result.value = _this._entities[--index];\n          result.done = index < 0;\n          return result;\n        }\n      };\n    }\n  }, {\n    key: \"size\",\n    get:\n    /**\n     * Returns the total size of the bucket, i.e. the number of entities it contains.\n     */\n    function get() {\n      return this.entities.length;\n    }\n\n    /**\n     * Returns the first entity in the bucket, or `undefined` if the bucket is empty.\n     */\n  }, {\n    key: \"first\",\n    get: function get() {\n      return this.entities[0];\n    }\n\n    /**\n     * Returns true if the bucket contains the given entity.\n     *\n     * @param entity The entity to check for.\n     * @returns `true` if the specificed entity is in this bucket, `false` otherwise.\n     */\n  }, {\n    key: \"has\",\n    value: function has(entity) {\n      return this.entityPositions.has(entity);\n    }\n\n    /**\n     * Adds the given entity to the bucket. If the entity is already in the bucket, it is\n     * not added again.\n     *\n     * @param entity The entity to add to the bucket.\n     * @returns The entity passed into this function (regardless of whether it was added or not).\n     */\n  }, {\n    key: \"add\",\n    value: function add(entity) {\n      if (entity && !this.has(entity)) {\n        this.entities.push(entity);\n        this.entityPositions.set(entity, this.entities.length - 1);\n\n        /* Increase version */\n        this._version++;\n\n        /* Emit our own onEntityAdded event */\n        this.onEntityAdded.emit(entity);\n      }\n      return entity;\n    }\n\n    /**\n     * Removes the given entity from the bucket. If the entity is not in the bucket, nothing\n     * happens.\n     *\n     * @param entity The entity to remove from the bucket.\n     * @returns The entity passed into this function (regardless of whether it was removed or not).\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(entity) {\n      /* TODO: Return early if entity is not in bucket. */\n      if (this.has(entity)) {\n        /* Emit our own onEntityRemoved event. */\n        this.onEntityRemoved.emit(entity);\n\n        /* Get the entity's current position. */\n        var index = this.entityPositions.get(entity);\n        this.entityPositions[\"delete\"](entity);\n\n        /* Perform shuffle-pop if there is more than one entity. */\n        var other = this.entities[this.entities.length - 1];\n        if (other !== entity) {\n          this.entities[index] = other;\n          this.entityPositions.set(other, index);\n        }\n\n        /* Remove the entity from the entities array. */\n        this.entities.pop();\n\n        /* Bump version */\n        this._version++;\n      }\n      return entity;\n    }\n\n    /**\n     * Removes all entities from the bucket. Will cause the `onEntityRemoved` event to be\n     * fired for each entity.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _iterator = _createForOfIteratorHelper(this),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _entity = _step.value;\n          this.remove(_entity);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n  return Bucket;\n}();\n\nexport { Bucket };\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nvar Event = /*#__PURE__*/function () {\n  function Event() {\n    _classCallCheck(this, Event);\n    _defineProperty(this, \"subscribers\", new Set());\n  }\n  _createClass(Event, [{\n    key: \"onSubscribe\",\n    get:\n    /**\n     * Event that is emitted when a new subscription is added.\n     */\n    function get() {\n      if (!this._onSubscribe) this._onSubscribe = new Event();\n      return this._onSubscribe;\n    }\n\n    /**\n     * Event that is emitted when a subscription is removed.\n     */\n  }, {\n    key: \"onUnsubscribe\",\n    get: function get() {\n      if (!this._onUnsubscribe) this._onUnsubscribe = new Event();\n      return this._onUnsubscribe;\n    }\n\n    /**\n     * Subscribes a callback to the event.\n     *\n     * @param callback The callback to subscribe to the event.\n     */\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(callback) {\n      var _this$_onSubscribe,\n        _this = this;\n      this.subscribers.add(callback);\n      (_this$_onSubscribe = this._onSubscribe) === null || _this$_onSubscribe === void 0 ? void 0 : _this$_onSubscribe.emit(callback);\n\n      /* Return a function that will unsubscribe the callback */\n      return function () {\n        return _this.unsubscribe(callback);\n      };\n    }\n\n    /**\n     * Unsubscribes a callback from the event.\n     *\n     * @param callback The callback to unsubscribe from the event.\n     */\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(callback) {\n      var _this$_onUnsubscribe;\n      this.subscribers[\"delete\"](callback);\n      (_this$_onUnsubscribe = this._onUnsubscribe) === null || _this$_onUnsubscribe === void 0 ? void 0 : _this$_onUnsubscribe.emit(callback);\n    }\n\n    /**\n     * Clears all existing subscriptions.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this._onUnsubscribe) {\n        var _iterator = _createForOfIteratorHelper(this.subscribers),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _callback = _step.value;\n            this._onUnsubscribe.emit(_callback);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      this.subscribers.clear();\n    }\n\n    /**\n     * Emit the event. This will invoke all stored listeners, passing the\n     * given payload to each of them.\n     *\n     * @param args Arguments to pass to the listeners.\n     */\n  }, {\n    key: \"emit\",\n    value: function emit() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      this.subscribers.forEach(function (callback) {\n        return callback.apply(void 0, args);\n      });\n    }\n\n    /**\n     * Emit the event. This will invoke all stored listeners, passing the\n     * given payload to each of them. This method supports asynchronous\n     * listeners and returns a promise that resolves when all listeners\n     * have completed their work.\n     *\n     * @param args Arguments to pass to the listeners.\n     * @returns A promise that resolves when all listeners have been invoked.\n     */\n  }, {\n    key: \"emitAsync\",\n    value: function emitAsync() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return Promise.all(_toConsumableArray(this.subscribers).map(function (listener) {\n        return listener.apply(void 0, args);\n      }));\n    }\n  }]);\n  return Event;\n}();\n\nexports.Event = Event;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar bucket = require('@miniplex/bucket');\nvar id = require('@hmans/id');\nvar queue$1 = require('@hmans/queue');\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar _Symbol$iterator;\n\n/**\n * A utility type that marks the specified properties as required.\n */\n\n/**\n * A utility type that removes all optional properties.\n */\n\n/* Utility types */\n\n/* Query configuration */\n\nvar World = /*#__PURE__*/function (_ref) {\n  _inherits(World, _ref);\n  var _super = _createSuper(World);\n  function World() {\n    var _this;\n    var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classCallCheck(this, World);\n    _this = _super.call(this, entities);\n\n    /* When entities are added, reindex them immediately */\n    /* QUERIES */\n    _defineProperty(_assertThisInitialized(_this), \"queries\", new Set());\n    /* IDs */\n    _defineProperty(_assertThisInitialized(_this), \"entityToId\", new Map());\n    _defineProperty(_assertThisInitialized(_this), \"idToEntity\", new Map());\n    _defineProperty(_assertThisInitialized(_this), \"nextId\", 0);\n    _this.onEntityAdded.subscribe(function (entity) {\n      _this.reindex(entity);\n    });\n\n    /* When entities are removed, remove them from all known queries, and delete\n    their IDs */\n    _this.onEntityRemoved.subscribe(function (entity) {\n      _this.queries.forEach(function (query) {\n        return query.remove(entity);\n      });\n      if (_this.entityToId.has(entity)) {\n        var _id = _this.entityToId.get(entity);\n        _this.idToEntity[\"delete\"](_id);\n        _this.entityToId[\"delete\"](entity);\n      }\n    });\n    return _this;\n  }\n  _createClass(World, [{\n    key: \"update\",\n    value: function (_update) {\n      function update(_x, _x2, _x3) {\n        return _update.apply(this, arguments);\n      }\n      update.toString = function () {\n        return _update.toString();\n      };\n      return update;\n    }(function (entity, update, value) {\n      /* Apply the update */\n      if (typeof update === \"function\") {\n        var partial = update(entity);\n        partial && Object.assign(entity, partial);\n      } else if (typeof update === \"string\") {\n        entity[update] = value;\n      } else if (update) {\n        Object.assign(entity, update);\n      }\n\n      /* If this world knows about the entity, reindex it. */\n      this.reindex(entity);\n      return entity;\n    }\n\n    /**\n     * Adds a component to an entity. If the entity already has the component, the\n     * existing component will not be overwritten.\n     *\n     * After the component was added, the entity will be reindexed, causing it to be\n     * added to or removed from any queries depending on their criteria.\n     *\n     * @param entity The entity to modify.\n     * @param component The name of the component to add.\n     * @param value The value of the component to add.\n     */)\n  }, {\n    key: \"addComponent\",\n    value: function addComponent(entity, component, value) {\n      /* Return early if the entity already has the component. */\n      if (entity[component] !== undefined) return;\n\n      /* Set the component */\n      entity[component] = value;\n\n      /* Trigger a reindexing */\n      this.reindex(entity);\n    }\n\n    /**\n     * Removes a component from an entity. If the entity does not have the component,\n     * this function does nothing.\n     *\n     * After the component was removed, the entity will be reindexed, causing it to be\n     * added to or removed from any queries depending on their criteria.\n     *\n     * @param entity The entity to modify.\n     * @param component The name of the component to remove.\n     */\n  }, {\n    key: \"removeComponent\",\n    value: function removeComponent(entity, component) {\n      /* Return early if the entity doesn't even have the component. */\n      if (entity[component] === undefined) return;\n\n      /* If this world knows about the entity, notify any derived buckets about the change. */\n      if (this.has(entity)) {\n        var future = _objectSpread2({}, entity);\n        delete future[component];\n        this.reindex(entity, future);\n      }\n\n      /* Remove the component. */\n      delete entity[component];\n    }\n  }, {\n    key: \"query\",\n    value:\n    /**\n     * Creates (or reuses) a query that matches the given configuration.\n     *\n     * @param config The query configuration.\n     * @returns A query that matches the given configuration.\n     */\n    function query(config) {\n      var normalizedConfig = normalizeQueryConfiguration(config);\n      var key = configKey(normalizedConfig);\n\n      /* Use existing query if we can find one */\n      var _iterator = _createForOfIteratorHelper(this.queries),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _query = _step.value;\n          if (_query.key === key) {\n            return _query;\n          }\n        }\n\n        /* Otherwise, create new query */\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var query = new Query(this, normalizedConfig);\n      this.queries.add(query);\n      return query;\n    }\n\n    /**\n     * Creates (or reuses) a query that holds entities that have all of the specified\n     * components.\n     *\n     * @param components One or more component names to query for.\n     * @returns A query that holds entities that have all of the given components.\n     */\n  }, {\n    key: \"with\",\n    value: function _with() {\n      for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {\n        components[_key] = arguments[_key];\n      }\n      return this.query({\n        \"with\": components,\n        without: [],\n        predicates: []\n      });\n    }\n\n    /**\n     * Creates (or reuses) a query that holds entities that do not have any of the\n     * specified components.\n     *\n     * @param components One or more component names to query for.\n     * @returns A query that holds entities that do not have any of the given components.\n     */\n  }, {\n    key: \"without\",\n    value: function without() {\n      for (var _len2 = arguments.length, components = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        components[_key2] = arguments[_key2];\n      }\n      return this.query({\n        \"with\": [],\n        without: components,\n        predicates: []\n      });\n    }\n\n    /**\n     * Creates (or reuses) a query that holds entities that match the given predicate.\n     * Please note that as soon as you are building queries that use predicates, you\n     * will need to explicitly reindex entities when their properties change.\n     *\n     * @param predicate The predicate that entities must match.\n     * @returns A query that holds entities that match the given predicate.\n     */\n  }, {\n    key: \"where\",\n    value: function where(predicate) {\n      return this.query({\n        \"with\": [],\n        without: [],\n        predicates: [predicate]\n      });\n    }\n\n    /**\n     * Reindexes the specified entity. This will iteratere over all registered queries\n     * and ask them to reevaluate the entity.\n     *\n     * If the `future` parameter is specified,\n     * it will be used in the evaluation instead of the entity itself. This is useful\n     * if you are about to perform a destructive change on the entity (like removing\n     * a component), but want emitted events to still have access to the unmodified entity\n     * before the change.\n     *\n     * @param entity The entity to reindex.\n     * @param future The entity that the entity will become in the future.\n     */\n  }, {\n    key: \"reindex\",\n    value: function reindex(entity) {\n      var future = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : entity;\n      /* Return early if this world doesn't know about the entity. */\n      if (!this.has(entity)) return;\n\n      /* Notify all queries about the change. */\n      var _iterator2 = _createForOfIteratorHelper(this.queries),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var query = _step2.value;\n          query.evaluate(entity, future);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"id\",\n    value:\n    /**\n     * Generate and return a numerical identifier for the given entity. The ID can later\n     * be used to retrieve the entity again through the `entity(id)` method.\n     *\n     * @param entity The entity to get the ID for.\n     * @returns An ID for the entity, or undefined if the entity is not in the world.\n     */\n    function id(entity) {\n      /* We only ever want to generate IDs for entities that are actually in the world. */\n      if (!this.has(entity)) return undefined;\n\n      /* Lazily generate an ID. */\n      if (!this.entityToId.has(entity)) {\n        var _id2 = this.nextId++;\n        this.entityToId.set(entity, _id2);\n        this.idToEntity.set(_id2, entity);\n      }\n      return this.entityToId.get(entity);\n    }\n\n    /**\n     * Given an entity ID that was previously generated through the `id(entity)` function,\n     * returns the entity matching that ID, or undefined if no such entity exists.\n     *\n     * @param id The ID of the entity to retrieve.\n     * @returns The entity with the given ID, or undefined if no such entity exists.\n     */\n  }, {\n    key: \"entity\",\n    value: function entity(id) {\n      return this.idToEntity.get(id);\n    }\n  }]);\n  return World;\n}(bucket.Bucket);\n_Symbol$iterator = Symbol.iterator;\nvar Query = /*#__PURE__*/function (_Bucket) {\n  _inherits(Query, _Bucket);\n  var _super2 = _createSuper(Query);\n  function Query(world, config) {\n    var _this2;\n    _classCallCheck(this, Query);\n    _this2 = _super2.call(this);\n    _defineProperty(_assertThisInitialized(_this2), \"_isConnected\", false);\n    _this2.world = world;\n    _this2.config = config;\n    _this2.key = configKey(config);\n\n    /* Automatically connect this query if event listeners are added to our\n    onEntityAdded or onEntityRemoved events. */\n    _this2.onEntityAdded.onSubscribe.subscribe(function () {\n      return _this2.connect();\n    });\n    _this2.onEntityRemoved.onSubscribe.subscribe(function () {\n      return _this2.connect();\n    });\n    return _this2;\n  }\n\n  /**\n   * An array containing all entities that match this query. For iteration, it\n   * is recommended to use the `for (const entity of query) {}` syntax instead.\n   */\n  _createClass(Query, [{\n    key: \"isConnected\",\n    get:\n    /**\n     * True if this query is connected to the world, and will automatically\n     * re-evaluate when entities are added or removed.\n     */\n    function get() {\n      return this._isConnected;\n    }\n\n    /**\n     * A unique, string-based key for this query, based on its configuration.\n     */\n  }, {\n    key: \"entities\",\n    get: function get() {\n      if (!this._isConnected) this.connect();\n      return _get(_getPrototypeOf(Query.prototype), \"entities\", this);\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      if (!this._isConnected) this.connect();\n      return _get(_getPrototypeOf(Query.prototype), Symbol.iterator, this).call(this);\n    }\n\n    /**\n     * Connects this query to the world. While connected, it will automatically\n     * re-evaluate when entities are added or removed, and store those that match\n     * its query configuration.\n     *\n     * @returns The query object.\n     */\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      if (!this._isConnected) {\n        this._isConnected = true;\n\n        /* Evaluate all entities in the world */\n        var _iterator3 = _createForOfIteratorHelper(this.world),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _entity = _step3.value;\n            this.evaluate(_entity);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Disconnects this query from the world. This essentially stops the query from\n     * automatically receiving entities.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this._isConnected = false;\n      return this;\n    }\n\n    /**\n     * Returns a new query that extends this query and also matches entities that\n     * have all of the components specified.\n     *\n     * @param components The components that entities must have.\n     * @returns A new query representing the extended query configuration.\n     */\n  }, {\n    key: \"with\",\n    value: function _with() {\n      for (var _len3 = arguments.length, components = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        components[_key3] = arguments[_key3];\n      }\n      return this.world.query(_objectSpread2(_objectSpread2({}, this.config), {}, {\n        \"with\": [].concat(_toConsumableArray(this.config[\"with\"]), components)\n      }));\n    }\n\n    /**\n     * Returns a new query that extends this query and also matches entities that\n     * have none of the components specified.\n     *\n     * @param components The components that entities must not have.\n     * @returns A new query representing the extended query configuration.\n     */\n  }, {\n    key: \"without\",\n    value: function without() {\n      for (var _len4 = arguments.length, components = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        components[_key4] = arguments[_key4];\n      }\n      return this.world.query(_objectSpread2(_objectSpread2({}, this.config), {}, {\n        without: [].concat(_toConsumableArray(this.config.without), components)\n      }));\n    }\n\n    /**\n     * Returns a new query that extends this query and also matches entities that\n     * match the given predicate.\n     *\n     * @param predicate The predicate that entities must match.\n     * @returns A new query representing the extended query configuration.\n     */\n  }, {\n    key: \"where\",\n    value: function where(predicate) {\n      return this.world.query(_objectSpread2(_objectSpread2({}, this.config), {}, {\n        predicates: [].concat(_toConsumableArray(this.config.predicates), [predicate])\n      }));\n    }\n\n    /**\n     * Checks the given entity against this query's configuration, and returns\n     * true if the entity matches the query, false otherwise.\n     *\n     * @param entity The entity to check.\n     * @returns True if the entity matches this query, false otherwise.\n     */\n  }, {\n    key: \"want\",\n    value: function want(entity) {\n      return this.config[\"with\"].every(function (component) {\n        return entity[component] !== undefined;\n      }) && this.config.without.every(function (component) {\n        return entity[component] === undefined;\n      }) && this.config.predicates.every(function (predicate) {\n        return predicate(entity);\n      });\n    }\n\n    /**\n     * Evaluate the given entity against this query's configuration, and add or\n     * remove it from the query if necessary.\n     *\n     * If `future` is specified, the entity will be evaluated against that entity\n     * instead. This is useful for checking if an entity will match the query\n     * after some potentially destructive change has been made to it, before\n     * actually applying that change to the entity itself.\n     *\n     * @param entity The entity to evaluate.\n     * @param future The entity to evaluate against. If not specified, the entity will be evaluated against itself.\n     */\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(entity) {\n      var future = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : entity;\n      if (!this.isConnected) return;\n      var wanted = this.want(future);\n      var has = this.has(entity);\n      if (wanted && !has) {\n        this.add(entity);\n      } else if (!wanted && has) {\n        this.remove(entity);\n      }\n    }\n  }]);\n  return Query;\n}(bucket.Bucket);\nvar normalizeComponents = function normalizeComponents(components) {\n  return _toConsumableArray(new Set(components.sort().filter(function (c) {\n    return !!c && c !== \"\";\n  })));\n};\nfunction normalizePredicates(predicates) {\n  return _toConsumableArray(new Set(predicates));\n}\nfunction normalizeQueryConfiguration(config) {\n  return {\n    \"with\": normalizeComponents(config[\"with\"]),\n    without: normalizeComponents(config.without),\n    predicates: normalizePredicates(config.predicates)\n  };\n}\nfunction configKey(config) {\n  return \"\".concat(config[\"with\"].join(\",\"), \":\").concat(config.without.join(\",\"), \":\").concat(config.predicates.map(function (p) {\n    return id.id(p);\n  }).join(\",\"));\n}\n\n/**\n * A simple queue (powered by [@hmans/queue](https://github.com/hmans/things/tree/main/packages/hmans-queue))\n * that can be used to schedule work to be done later. This is mostly provided as a convenience\n * to make upgrading from Miniplex 1.0 (which had queuing functionality built-in) a little easier,\n * and it will be deprecated in a future version.\n */\nvar queue = queue$1.createQueue();\n\nObject.defineProperty(exports, 'Bucket', {\n  enumerable: true,\n  get: function () { return bucket.Bucket; }\n});\nexports.Query = Query;\nexports.World = World;\nexports.queue = queue;\n","'use strict';\n\nif (process.env.NODE_ENV === \"production\") {\n  module.exports = require(\"./miniplex.cjs.prod.js\");\n} else {\n  module.exports = require(\"./miniplex.cjs.dev.js\");\n}\n"],"names":[],"sourceRoot":""}