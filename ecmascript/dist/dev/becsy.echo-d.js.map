{"version":3,"file":"becsy.echo-d.js","mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;ACVuD;AACX;AACG;AAC/C;AACA;AACA;AACA,QAAQ,QAAQ,oUAAwC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO,2BAA2B,2DAAY;AAC9C;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,UAAU,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8CAAG;AAC1C;AACA;AACA;;;;;;;;;;;;;;;;;;AC3T6D;AAC7D,yBAAyB,0DAAiB;AAC1C;AACA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB,cAAc,YAAY;AAC1B,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACO;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,4BAA4B,cAAc;AAC1C,QAAQ,+DAAkB;AAC1B;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB;AACjB;AACA;AACA;AACA;AACA","sources":["webpack://echoD/webpack/universalModuleDefinition","webpack://echoD/./lib/extra/storage/becsy.js","webpack://echoD/./lib/storage/async.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echoD\"] = factory();\n\telse\n\t\troot[\"echoD\"] = factory();\n})(typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : this, () => {\nreturn ","import { AsyncStorage, } from '../../storage/async.js';\nimport { ArrayTypes } from '../../types.js';\nimport { paginate, now } from '../../utils.js';\nconst { \n// System,\n// Type,\nWorld } = await import('@lastolivegames/becsy/index.js');\n/*\nexport function defaultGetGroupedValue (value: any | any[], i: number, types: Types, key: string): any {\n    const type = types[key]\n    if (Array.isArray(type)) {\n        return value.slice(i * type[1], (i + 1) * type[1])\n    }\n    return value[i]\n}\n\nexport function defaultSetGroupedValue (value: any, _types: Types, _key: string): any {\n    return value;\n}\n*/\nexport class BecsyStorage extends AsyncStorage {\n    // declare eids: Map<string, any>;\n    constructor(storage, options) {\n        super({\n            ...(storage || {}),\n            actors: new Map(),\n            components: new Map(),\n            entities: new Map(),\n            // inputs: new Map(),\n            inputs: null,\n        }, options);\n        const { \n        // types,\n        // indexes,\n        worldOptions = { defs: [] }, world = null, } = options;\n        for (let key in this.types) {\n            const type = this.types[key];\n            if (typeof type[0] === 'string') {\n                this.components.set(key, type[2]);\n            }\n            else\n                switch (type) {\n                    case Boolean:\n                    case Number:\n                    case String:\n                        this.components.set(key, new Map());\n                        break;\n                }\n        }\n        if (worldOptions && !worldOptions.defs) {\n            worldOptions.defs = [];\n        }\n        // if (!((worldOptions as WorldOptions).defs as any[]).length) {\n        for (let component of this.components.values()) {\n            if (!component) {\n                continue;\n            }\n            if (component instanceof Map) {\n                continue;\n            }\n            if (worldOptions.defs.indexOf(component) === -1) {\n                worldOptions.defs.push(component);\n            }\n        }\n        // }\n        this.worldOptions = worldOptions;\n        this.world = world || World.create(this.worldOptions);\n        /*\n        this.eids = storage?.eids || new Map();\n        \n        for (let key in this.actors) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.entities) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.components) {\n            for (let id in this.components[key]) {\n                addComponent(this.world, this.components[key][id], this.ids[id]);\n            }\n        }\n        */\n    }\n    async cleanup() {\n        const world = await this.world;\n        try {\n            world.__dispatcher.registry.releaseComponentTypes();\n            await world.terminate();\n        }\n        catch (err) {\n            // console.warn(err)\n        }\n    }\n    derefEntity(id) {\n        if (this.actors.has(id)) {\n            return this.actors.get(id);\n        }\n        if (this.entities.has(id)) {\n            return this.entities.get(id);\n        }\n        return;\n    }\n    async destroyActor(id) {\n        return this.destroyId(this.actors, id);\n    }\n    async destroyComponent(id, key) {\n        const entity = this.derefEntity(id);\n        const Component = this.components.get(key);\n        if (entity === null || entity === undefined || !Component) {\n            return;\n        }\n        const updateIndexes = () => {\n            const prevValue = this.findComponent(id, key);\n            this.removeComponentsIndex(id, key, prevValue);\n        };\n        if (Component instanceof Map) {\n            const entity = Component.get(id);\n            if (entity) {\n                Component.delete(id);\n            }\n            updateIndexes();\n        }\n        else {\n            // removeComponent(this.world, Component, eid);\n            updateIndexes();\n        }\n    }\n    async destroyEntity(id) {\n        return this.destroyId(this.entities, id);\n    }\n    async destroyId(list, id) {\n        const entity = list.get(id);\n        if (entity) {\n            entity.delete();\n            list.delete(id);\n            return true;\n        }\n        return false;\n    }\n    async findComponents(id) {\n        const entity = this.derefEntity(id);\n        if (entity === null || entity === undefined) {\n            return;\n        }\n        return entity;\n    }\n    findComponent(id, key) {\n        const _ = undefined;\n        return this.findComponentProcess(id, key, _, _);\n    }\n    findComponentProcess(id, key, entity, Component) {\n        entity = (entity === null || entity === undefined) ? this.derefEntity(id) : entity;\n        Component = Component || this.components.get(key);\n        if (entity === null || entity === undefined || !Component) {\n            return;\n        }\n        if (Component instanceof Map) {\n            return Component.get(id);\n        }\n        else {\n            const type = this.types[key];\n            const schema = type[3];\n            const Type = ArrayTypes.get(type[0]);\n            const size = type[1];\n            const value = new Type(size);\n            const view = entity.has(Component) ? entity.read(Component) : undefined;\n            let i = 0;\n            if (view === null || view === undefined) {\n                return value;\n            }\n            for (let prop in schema) {\n                if (prop === '$val') {\n                    value.set(view);\n                    break;\n                }\n                value[i] = view[prop];\n                i++;\n            }\n            return value;\n        }\n    }\n    getActors(query = null, pageSize) {\n        if (query !== null) {\n            return super.getActors(query, pageSize);\n        }\n        const actors = Array.from(this.actors.keys());\n        const pages = paginate(actors, pageSize);\n        return pages;\n        // return new Emitter<string[][]>(pages, true)\n    }\n    getComponents(query = null, pageSize) {\n        // const queryKeys = Object.keys(query);\n        // const entities = this.world.with(...queryKeys);\n        let ids;\n        if (query !== null) {\n            ids = query;\n        }\n        else {\n            const actors = this.actors.keys();\n            const entities = this.entities.keys();\n            ids = [\n                ...actors,\n                ...entities\n            ];\n        }\n        const pages = paginate(ids, pageSize);\n        const _ = undefined;\n        return pages.map((page) => {\n            const components = {};\n            for (let id of page) {\n                const entity = this.derefEntity(id);\n                if (entity === null || entity === undefined) {\n                    continue;\n                }\n                const compList = this.componentsIndex.get(id);\n                const component = {};\n                for (let key of compList) {\n                    component[key] = this.findComponentProcess(id, key, entity, _);\n                }\n                components[id] = component;\n            }\n            return components;\n        });\n        // return pages;\n        // return new Emitter<Components[]>(pages, true)\n    }\n    getEntities(query = null, pageSize) {\n        if (query !== null) {\n            return super.getEntities(query, pageSize);\n        }\n        const entities = this.entities.keys();\n        const pages = paginate(entities, pageSize);\n        return pages;\n        // return new Emitter<string[][]>(pages, true)\n    }\n    getInputs(query = null, pageSize) {\n        return super.getInputs(query, pageSize);\n    }\n    isActor(id) {\n        return this.actors.has(id);\n    }\n    isEntity(id) {\n        return this.entities.has(id);\n    }\n    async setActors(actors) {\n        return super.setActors(actors);\n    }\n    async setComponents(components) {\n        return super.setComponents(components);\n    }\n    async setEntities(entities) {\n        return super.setEntities(entities);\n    }\n    async setInputs(inputs) {\n        return super.setInputs(inputs);\n    }\n    async storeActor(id) {\n        return await this.storeId(this.actors, id);\n    }\n    async storeComponent(id, key, value) {\n        const entity = this.derefEntity(id);\n        if (entity !== null && entity !== undefined) {\n            const Component = this.components.get(key);\n            if (!Component) {\n                return;\n            }\n            if (!entity.has(Component)) {\n                entity.add(Component, {});\n            }\n            let prevValue = [];\n            if (Component instanceof Map) {\n                prevValue = Component.get(id);\n                Component.set(id, value);\n            }\n            else {\n                // entity[key] = value\n                const type = this.types[key];\n                const schema = type[3];\n                const component = entity.write(Component);\n                let i = 0;\n                for (let prop in schema) {\n                    if (prop === '$val') {\n                        component.set(value);\n                        break;\n                    }\n                    component[prop] = value[i];\n                    i++;\n                }\n                // const world = await this.world;\n                // world.addComponent(entity, key, component);\n            }\n            await this.updateComponentsIndex(id, key, prevValue, value);\n        }\n    }\n    async storeEntity(id) {\n        return await this.storeId(this.entities, id);\n    }\n    async storeId(list, id) {\n        let entity = list.get(id);\n        if (entity === null || entity === undefined) {\n            const world = await this.world;\n            const entity = world.__dispatcher.createEntity([] // (this.worldOptions.defaultComponents || this.worldOptions.defs)\n            );\n            const reference = entity.__registry.holdEntity(entity.__id);\n            // const reference = entity.hold();\n            list.set(id, reference);\n            return true;\n        }\n        return false;\n    }\n    async storeInput(id, input, tick = now()) {\n        return super.storeInput(id, input, tick);\n    }\n}\n","import { createStorageProps, Storage, } from '../storage.js';\nconst StoragePrototype = Storage.prototype;\n/**\n * The AsyncStorage class represents an asynchronous store with actors, entities, components, and inputs.\n *\n * @property {string[]} actors - The actors in the store.\n * @property {string[]} entities - The entities in the store.\n * @property {Components} components - The components in the store.\n * @property {Inputs} inputs - The inputs in the store.\n * @property {Inputs} inputs - The inputs in the store.\n */\nexport class AsyncStorage {\n    /**\n     * Constructs a new AsyncStorage object.\n     *\n     * @param {StorageProps} storage - The properties of the store.\n     */\n    constructor(storage = {}, options = {}) {\n        createStorageProps(this, storage, options);\n    }\n    /**\n     * Removes an actor ID asynchronously.\n     *\n     * @param {string} id - The ID of the actor to remove.\n     * @returns {Promise<boolean>} A Promise that resolves with true if the actor ID was removed, false otherwise.\n     */\n    async destroyActor(id) {\n        return StoragePrototype.destroyActor.call(this, id);\n    }\n    /**\n     * Removes a component asynchronously.\n     *\n     * @param {string} id - The ID of the component to remove.\n     * @param {string} key - The key of the component to remove.\n     */\n    async destroyComponent(id, key) {\n        return StoragePrototype.destroyComponent.call(this, id, key);\n    }\n    /**\n     * Removes an entity ID asynchronously.\n     *\n     * @param {string} id - The ID of the entity to remove.\n     * @returns {Promise<boolean>} A Promise that resolves with true if the entity ID was removed, false otherwise.\n     */\n    async destroyEntity(id) {\n        return StoragePrototype.destroyEntity.call(this, id);\n    }\n    /**\n     * Removes an ID from a list if it exists asynchronously.\n     *\n     * @param {string[]} list - The list to remove the ID from.\n     * @param {string} id - The ID to remove.\n     * @returns {Promise<boolean>} A Promise that resolves with true if the ID was removed, false otherwise.\n     */\n    async destroyId(list, id) {\n        return StoragePrototype.destroyId.call(this, list, id);\n    }\n    /**\n     * Fetches a components container for an entity.\n     *\n     * @param {string} id - The ID of the entity.\n     * @returns {Components} The fetched components container.\n     */\n    async findComponents(id) {\n        return StoragePrototype.findComponents.call(this, id);\n    }\n    /**\n     * Fetches a component.\n     *\n     * @param {string} id - The ID of the component to fetch.\n     * @param {string} key - The key of the component to fetch.\n     * @returns {any} The fetched component.\n     */\n    async findComponent(id, key) {\n        return StoragePrototype.findComponent.call(this, id, key);\n    }\n    /**\n     * Fetches an actors inputs\n     *\n     * @param {string} id - The ID of the actor.\n     * @returns {InputPayload} The fetched inputs.\n     */\n    async findInputs(id) {\n        return StoragePrototype.findInputs.call(this, id);\n    }\n    /**\n     * Fetches an actors input\n     *\n     * @param {string} id - The ID of the actor.\n     * @param {number} index - The index of the input.\n     * @returns {InputPayload} The fetched inputs.\n     */\n    async findInput(id, index) {\n        return StoragePrototype.findInput.call(this, id, index);\n    }\n    /**\n     * Gets the actors.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {string[][]} The actors.\n     */\n    getActors(query = null, pageSize = Infinity) {\n        const pages = StoragePrototype.getActors.call(this, query, pageSize);\n        return pages;\n        // const emitter = new Emitter<string[][]>(pages as string[][], true); \n        // return emitter;\n    }\n    /**\n     * Gets the components.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {Components} The components.\n     */\n    getComponents(query = null, pageSize = Infinity) {\n        const pages = StoragePrototype.getComponents.call(this, query, pageSize);\n        return pages;\n        // const emitter = new Emitter<Components[]>(pages as Components[], true); \n        // return emitter;\n    }\n    /**\n     * Gets the entities.\n     *\n     * @param {any} query - The query to use.\n     * @param {number} pageSize - The page size to use.\n     * @returns {string[]} The entities.\n     */\n    getEntities(query = null, pageSize = Infinity) {\n        const pages = StoragePrototype.getEntities.call(this, query, pageSize);\n        return pages;\n        // const emitter = new Emitter<string[][]>(pages as string[][], true); \n        // return emitter;\n    }\n    /**\n     * Gets the inputs.\n     *\n     * @returns {Inputs} The inputs.\n     */\n    getInputs(query = null, pageSize = Infinity) {\n        const pages = StoragePrototype.getInputs.call(this, query, pageSize);\n        return pages;\n        // const emitter = new Emitter<Inputs[]>(pages as Inputs[], true); \n        // return emitter;\n    }\n    /**\n     * Checks if an ID is an actor.\n     *\n     * @param {string} id - The ID to check.\n     * @returns {boolean} True if the ID is an actor, false otherwise.\n     */\n    isActor(id) {\n        return StoragePrototype.isActor.call(this, id);\n    }\n    /**\n     * Checks if an ID is an entity.\n     *\n     * @param {string} id - The ID to check.\n     * @returns {boolean} True if the ID is an entity, false otherwise.\n     */\n    isEntity(id) {\n        return StoragePrototype.isEntity.call(this, id);\n    }\n    /**\n     * Sets the actors.\n     *\n     * @param {string[]} actors - The actors to set.\n     * @returns {string[]} The actors.\n     */\n    async setActors(actors) {\n        return StoragePrototype.setActors.call(this, actors);\n    }\n    /**\n     * Sets the components.\n     *\n     * @param {Components} components - The components to set.\n     * @returns {Components} The components.\n     */\n    async setComponents(components) {\n        return StoragePrototype.setComponents.call(this, components);\n    }\n    /**\n     * Sets the entities.\n     *\n     * @param {string[]} entities - The entities to set.\n     * @returns {string[]} The entities.\n     */\n    async setEntities(entities) {\n        return StoragePrototype.setEntities.call(this, entities);\n    }\n    /**\n     * Sets the inputs.\n     *\n     * @param {Inputs} inputs - The inputs to set.\n     * @returns {Inputs} The inputs.\n     */\n    async setInputs(inputs) {\n        return StoragePrototype.setInputs.call(this, inputs);\n    }\n    /**\n     * Stores an actor ID.\n     *\n     * @param {string} id - The ID of the actor to store.\n     * @returns {boolean} True if the actor ID was stored, false otherwise.\n     */\n    async storeActor(id) {\n        return StoragePrototype.storeActor.call(this, id);\n    }\n    /**\n     * Stores a component.\n     *\n     * @param {string} id - The ID of the component to store.\n     * @param {string} key - The key of the component to store.\n     * @param {any} value - The value of the component to store.\n     */\n    async storeComponent(id, key, value) {\n        return StoragePrototype.storeComponent.call(this, id, key, value);\n    }\n    /**\n     * Stores an entity ID.\n     *\n     * @param {string} id - The ID of the entity to store.\n     * @returns {boolean} True if the entity ID was stored, false otherwise.\n     */\n    async storeEntity(id) {\n        return StoragePrototype.storeEntity.call(this, id);\n    }\n    /**\n     * Stores an ID in a list if it doesn't exist already.\n     *\n     * @param {string[]} list - The list to store the ID in.\n     * @param {string} id - The ID to store.\n     * @returns {boolean} True if the ID was stored, false otherwise.\n     */\n    async storeId(list, id) {\n        return StoragePrototype.storeId.call(this, list, id);\n    }\n    /**\n     * Stores an input.\n     *\n     * @param {string} id - The ID of the input to store.\n     * @param {InputPayload} input - The payload of the input to store.\n     * @returns {number} The new index of the stored input.\n     */\n    async storeInput(id, input, tick = 0) {\n        return StoragePrototype.storeInput.call(this, id, input, tick);\n    }\n    /**\n     * Queries the store for entities by component.\n     *\n     * @param {any} query - The query to use.\n     * @returns {Set<any>} The entities.\n     */\n    queryComponents(query) {\n        return StoragePrototype.queryComponents.call(this, query);\n    }\n    /**\n   * Removes a component from the components index.\n   *\n   * @param {string} id - The ID of the component to remove.\n   * @param {string} key - The key of the component to remove.\n   * @param {any} prevValue - The previous value of the component.\n   * @returns {void}\n   */\n    removeComponentsIndex(id, key, prevValue) {\n        StoragePrototype.removeComponentsIndex.call(this, id, key, prevValue);\n    }\n    /**\n     * Updates a component in the components index.\n     *\n     * @param {string} id - The ID of the component to update.\n     * @param {string} key - The key of the component to update.\n     * @param {any} prevValue - The previous value of the component.\n     * @param {any} value - The new value of the component.\n     * @returns {void}\n     */\n    updateComponentsIndex(id, key, prevValue, value) {\n        StoragePrototype.updateComponentsIndex.call(this, id, key, prevValue, value);\n    }\n}\n"],"names":[],"sourceRoot":""}