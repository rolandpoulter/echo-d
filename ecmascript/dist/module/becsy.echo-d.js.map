{"version":3,"file":"becsy.echo-d.js","mappings":";;;;;;;;;;;;;;;;;;;AAA2C;AACI;AAC/C;AACA;AACA;AACA,QAAQ,QAAQ,2NAAwC;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO,2BAA2B,gDAAO;AACzC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB;AACvB,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8CAAG;AACpC;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA,uDAAuD,mBAAmB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA,wGAAwG,iBAAiB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA,8GAA8G,iBAAiB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA,4HAA4H,iBAAiB;AAC7I;AACA;AACA;AACA;AACA,kEAAkE,eAAe;AACjF,kEAAkE,eAAe;AACjF;AACA,gFAAgF,kCAAkC;AAClH,gFAAgF,kCAAkC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,6DAA6D,EAAE;AAC/D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,6DAA6D,EAAE;AAC/D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gEAAgE,cAAc,iCAAiC,OAAO;AACtH;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA,kEAAkE,kBAAkB,GAAG,YAAY;AACnG;AACA,oCAAoC,YAAY;AAChD;AACA,sEAAsE,kBAAkB,GAAG,YAAY;AACvG,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA,kEAAkE,eAAe;AACjF,kEAAkE,eAAe;AACjF;AACA,gFAAgF,kCAAkC;AAClH,gFAAgF,kCAAkC;AAClH;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,6DAA6D,EAAE;AAC/D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,6DAA6D,EAAE;AAC/D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gEAAgE,cAAc,iCAAiC,OAAO;AACtH;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA,kEAAkE,kBAAkB,GAAG,YAAY;AACnG;AACA,oCAAoC,YAAY;AAChD;AACA,sEAAsE,kBAAkB,GAAG,YAAY;AACvG,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA,6GAA6G,iBAAiB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,MAAM;AACnF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2EAA2E,MAAM;AACjF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,MAAM;AACnF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,MAAM;AACnF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2EAA2E,MAAM;AACjF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,MAAM;AACnF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wEAAwE,eAAe,kBAAkB,MAAM;AAC/G;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wEAAwE,eAAe,kBAAkB,MAAM;AAC/G;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,iBAAiB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,gBAAgB,SAAS,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB,GAAG,YAAY;AACxF,wCAAwC,eAAe,GAAG,eAAe;AACzE;AACA;AACA,uDAAuD,kBAAkB,GAAG,YAAY;AACxF,+BAA+B,eAAe,GAAG,gBAAgB;AACjE;AACA;AACA,wFAAwF,kBAAkB,GAAG,WAAW;AACxH;AACA;AACA,uDAAuD,kBAAkB,GAAG,YAAY;AACxF,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB,GAAG,YAAY;AAC5F;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB,GAAG,YAAY;AAC5F;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY,IAAI,+BAA+B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C,wBAAwB,YAAY,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,WAAW,YAAY;AACzD,cAAc,+BAA+B,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,UAAU,KAAK,eAAe;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,UAAU,KAAK,eAAe;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW,aAAa;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,yBAAyB;AACzG,wDAAwD,sBAAsB;AAC9E;AACA;AACA,8FAA8F,wBAAwB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,IAAI,eAAe,wBAAwB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,qBAAqB,2DAA2D,qBAAqB;AACvK;AACA;AACA,kEAAkE,qBAAqB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,qBAAqB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,yBAAyB;AACjG,gDAAgD,sBAAsB;AACtE;AACA;AACA,sFAAsF,wBAAwB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA,oDAAoD,IAAI,eAAe,wBAAwB;AAC/F;AACA;AACA;AACA;AACA,8DAA8D,qBAAqB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK,4BAA4B,UAAU;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,0BAA0B,4DAA4D;AACtF;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,WAAW;AAClE;AACA;AACA,uDAAuD,WAAW,+CAA+C,SAAS;AAC1H;AACA;AACA,uDAAuD,WAAW;AAClE;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA,+CAA+C,aAAoB;AACnE,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW,EAAE,sBAAsB;AACjF;AACA;AACA,8CAA8C,WAAW,cAAc,uBAAuB;AAC9F;AACA;AACA;AACA,8CAA8C,WAAW,sBAAsB,8BAA8B;AAC7G;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,mGAAmG,KAAK;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,WAAW;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa,wBAAwB,WAAW,KAAK,KAAK;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC,gBAAgB,iEAAiE,mBAAmB;AACpI,gCAAgC,gBAAgB,mEAAmE,uBAAuB;AAC1I;AACA;AACA,2EAA2E,sBAAsB;AACjG;AACA,oCAAoC,gBAAgB,qEAAqE,yBAAyB;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2BAA2B,cAAc,sBAAsB;AACpH,mBAAmB,iDAAiD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,qBAAqB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,qBAAqB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,qBAAqB;AACnH;AACA;AACA,kFAAkF,qBAAqB;AACvG;AACA;AACA;AACA;AACA,oEAAoE,sBAAsB,QAAQ,gBAAgB;AAClH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY,IAAI,UAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,UAAU;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8CAA8C;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,YAAY;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO,gCAAgC,QAAQ;AAC1F,0BAA0B,kBAAkB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK,IAAI,UAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE,4CAA4C,sBAAsB;AAClE;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,oBAAoB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kCAAkC;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,qBAAqB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qBAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,UAAU;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACA;AACA;AACA,iGAAiG,UAAU;AAC3G;AACA;AACA,mFAAmF,UAAU;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,UAAU;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0BAA0B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,WAAW,yCAAyC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,qBAAqB;AACrB;AACA,uCAAuC;AACvC;AACA;AACA,kBAAkB;AAClB;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,6GAA6G,UAAU;AACvH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6GAA6G,UAAU;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sCAAsC;AACzF;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,eAAe;AACf,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,uBAAuB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,kCAAkC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kCAAkC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,sBAAsB,QAAQ,cAAc;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB,sDAAsD,mBAAmB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,sBAAsB,QAAQ,cAAc;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wFAAwF,sBAAsB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,qBAAqB,KAAK,sBAAsB;AAC1H;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,sBAAsB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,qBAAqB,KAAK,sBAAsB;AAC1H;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kBAAkB;AAClB;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H,8BAA8B;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oBAAoB,uBAAuB,GAAG;AACpG;AACA;AACA;AACA,2EAA2E,YAAY;AACvF;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,2BAA2B;AAC3F;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA,yGAAyG,KAAK;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,4BAA4B,wBAAwB,WAAW;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,aAAa;AACpF;AACA;AACA;AACA;AACA;AACA,2DAA2D,mBAAmB,WAAW,aAAa;AACtG,mCAAmC,WAAW,eAAe,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mCAAmC,KAAK,mCAAmC,iBAAiB,+BAA+B;AAC7I;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,cAAc,mCAAmC,KAAK,mCAAmC;AACzF,UAAU,6CAA6C;AACvD,UAAU,+CAA+C,2BAA2B,yCAAyC;AAC7H,iBAAiB,0CAA0C;AAC3D;AACA;AACA,8BAA8B,KAAK,IAAI,uBAAuB,OAAO,sBAAsB;AAC3F,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA,+CAA+C,KAAK,sBAAsB,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK,qBAAqB,IAAI;AAC7E;AACA;AACA;AACA;AACA,2CAA2C,KAAK,mBAAmB,kBAAkB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,8BAA8B;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA,6BAA6B,0CAA0C;AACvE;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA,qBAAqB,qBAAqB;AAC1C;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kCAAkC;AACzE;AACA;AACA,uCAAuC,yCAAyC;AAChF;AACA,wCAAwC,gBAAgB;AACxD;AACA,2CAA2C,mBAAmB;AAC9D,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,OAAO;AAC5E;AACA;AACA;AACA;AACA,qEAAqE,OAAO;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,UAAU,IAAI,iBAAiB;AAC9F;AACA;AACA,+DAA+D,UAAU,IAAI,iBAAiB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B,4BAA4B,OAAO;AACnC;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gBAAgB;AAC3E;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,aAAoB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B,OAAO;AAC1D;AACA,gCAAgC,uBAAuB;AACvD;AACA,6BAA6B,oEAAoE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kPAAkP;AACpQ;AACA;AACA;AACA;AACA;AACA,uEAAuE,iBAAiB;AACxF;AACA,gBAAgB,6FAA6F;AAC7G;AACA,2EAA2E,mBAAmB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,4EAA4E;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,4EAA4E;AACxK;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,iEAAiE,oBAAoB,uBAAuB,GAAG;AAC/G;AACA;AACA;AACA,+EAA+E,mBAAmB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yGAAyG;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,SAAS;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACnF","sources":["webpack://echo-d/./lib/extra/storage/becsy.js","webpack://echo-d/./node_modules/.deno/@lastolivegames+becsy@0.15.5/node_modules/@lastolivegames/becsy/index.js"],"sourcesContent":["import { Storage } from '../../storage.js';\nimport { paginate, now } from '../../utils.js';\nconst { \n// System,\n// Type,\nWorld } = await import('@lastolivegames/becsy/index.js');\nexport function defaultGetGroupedValue(value, i, types, key) {\n    const type = types[key];\n    if (Array.isArray(type)) {\n        return value.slice(i * type[1], (i + 1) * type[1]);\n    }\n    return value[i];\n}\nexport function defaultSetGroupedValue(value, _types, _key) {\n    return value;\n}\nexport class BecsyStorage extends Storage {\n    constructor(storage, options) {\n        super({\n            ...(storage || {}),\n            actors: new Map(),\n            components: new Map(),\n            entities: new Map(),\n            // inputs: new Map(),\n            inputs: null,\n        }, options);\n        let { \n        // types,\n        // indexes,\n        worldOptions } = options;\n        worldOptions = worldOptions || { defs: [] };\n        if (worldOptions && !worldOptions.defs) {\n            worldOptions.defs = [];\n        }\n        // if (!((worldOptions as WorldOptions).defs as any[]).length) {\n        //      for (let component of this.components.values()) {\n        //         if (!component) {\n        //             continue\n        //         }\n        //         if ((component as any) instanceof Map) {\n        //             continue\n        //         }\n        //         (worldOptions as WorldOptions).defs.push(component)\n        //     }\n        // }\n        this.worldOptions = worldOptions;\n        this.world = storage?.world || World.create(this.worldOptions);\n        this.eids = storage?.eids || new Map();\n        // for (let key in this.types) {\n        //     const type = this.types[key];\n        //     if (typeof type[0] === 'string') {\n        //         this.components.set(key, defineComponent(type[2]));\n        //     } else switch (type) {\n        //         case Boolean:\n        //         case Number:\n        //         case String:\n        //             this.components.set(key, new Map());\n        //             break;\n        //     }\n        // }\n        /*\n        for (let key in this.actors) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.entities) {\n            this.eids.set(key, addEntity(this.world));\n        }\n\n        for (let key in this.components) {\n            for (let id in this.components[key]) {\n                addComponent(this.world, this.components[key][id], this.ids[id]);\n            }\n        }\n        */\n    }\n    destroyActor(id) {\n        return this.destroyId(this.actors, id);\n    }\n    destroyComponent(id, key) {\n        const eid = this.actors.get(id) || this.entities.get(id);\n        const Component = this.components.get(key);\n        if (!eid || !Component) {\n            return;\n        }\n        const updateIndexes = () => {\n            const prevValue = this.fetchComponent(id, key);\n            if (this.indexes[key]) {\n                const index = this.indexes[key];\n                if (this.isActor(id)) {\n                    index.actors.remove(id, prevValue);\n                }\n                else {\n                    index.entities.remove(id, prevValue);\n                }\n            }\n        };\n        if (Component instanceof Map) {\n            const entity = Component.get(eid);\n            if (entity) {\n                Component.delete(eid);\n            }\n            updateIndexes();\n        }\n        else {\n            // removeComponent(this.world, Component, eid);\n            updateIndexes();\n        }\n    }\n    destroyEntity(id) {\n        return this.destroyId(this.entities, id);\n    }\n    destroyId(list, id) {\n        const eid = list.get(id);\n        if (eid) {\n            // removeEntity(this.world, eid);\n            list.delete(id);\n            return true;\n        }\n        return false;\n    }\n    fetchComponents(id) {\n        const eid = this.actors.get(id) || this.entities.get(id);\n        if (!eid) {\n            return;\n        }\n        return eid;\n    }\n    fetchComponent(id, key) {\n        const eid = this.actors.get(id) || this.entities.get(id);\n        const Component = this.components.get(key);\n        if (!eid || !Component) {\n            return;\n        }\n        if (Component instanceof Map) {\n            return Component.get(eid);\n        }\n        else {\n            // const type = this.types[key];\n            // const schema = type[3]\n            // const Type = ArrayTypes.get(type[0])\n            // const size = type[1]\n            // const value = new Type(size)\n            // let i = 0\n            // for (let prop in schema) {\n            //     // value[i] = Component[prop][eid]\n            //     i++\n            // }\n            // return value\n        }\n    }\n    getActors(query, pageSize) {\n        if (query !== null) {\n            return super.getActors(query, pageSize);\n        }\n        const actors = Array.from(this.actors.keys());\n        return paginate(actors, pageSize);\n    }\n    getComponents(query, pageSize) {\n        // const queryKeys = Object.keys(query);\n        // const entities = this.world.with(...queryKeys);\n        let ids;\n        if (query !== null) {\n            ids = query;\n        }\n        else {\n            const actors = Array.from(this.actors.keys());\n            const entities = Array.from(this.entities.keys());\n            ids = actors.concat(entities);\n        }\n        const pages = paginate(ids, pageSize);\n        return pages.map((page) => {\n            const components = {};\n            for (let id of page) {\n                components[id] = this.actors.get(id) || this.entities.get(id);\n            }\n            return components;\n        });\n    }\n    getEntities(query, pageSize) {\n        if (query !== null) {\n            return super.getEntities(query, pageSize);\n        }\n        const entities = Array.from(this.entities.keys());\n        return paginate(entities, pageSize);\n    }\n    getInputs(query, pageSize) {\n        return super.getInputs(query, pageSize);\n    }\n    isActor(id) {\n        return this.actors.has(id);\n    }\n    isEntity(id) {\n        return this.entities.has(id);\n    }\n    setActors(actors) {\n        return super.setActors(actors);\n    }\n    setComponents(components) {\n        return super.setComponents(components);\n    }\n    setEntities(entities) {\n        return super.setEntities(entities);\n    }\n    setInputs(inputs) {\n        return super.setInputs(inputs);\n    }\n    storeActor(id) {\n        return this.storeId(this.actors, id);\n    }\n    storeComponent(id, key, value) {\n        const entity = this.actors.get(id) || this.entities.get(id);\n        if (entity) {\n            const prevValue = entity[key];\n            // entity[key] = value\n            const type = this.types[key];\n            const schema = type[3];\n            const component = {};\n            let i = 0;\n            for (let prop in schema) {\n                component[prop] = value[i];\n                i++;\n            }\n            this.world.addComponent(entity, key, component);\n            // this.world.reindex(entity)\n            if (this.indexes[key]) {\n                const index = this.indexes[key];\n                if (this.isActor(id)) {\n                    index.actors.remove(id, prevValue);\n                    index.actors.set(id, value);\n                }\n                else {\n                    index.entities.remove(id, prevValue);\n                    index.entities.set(id, value);\n                }\n            }\n        }\n    }\n    storeEntity(id) {\n        return this.storeId(this.entities, id);\n    }\n    storeId(list, id) {\n        const entity = list.get(id);\n        if (!entity) {\n            list.set(id, entity);\n            this.world.add(entity);\n            return true;\n        }\n        return false;\n    }\n    storeInput(id, input, tick = now()) {\n        return super.storeInput(id, input, tick);\n    }\n}\n","const ENTITY_ID_BITS = 22;\r\nconst COMPONENT_ID_BITS = 9;\r\nconst FIELD_SEQ_BITS = 7;\r\nconst MAX_NUM_ENTITIES = 2 ** ENTITY_ID_BITS;\r\nconst ENTITY_ID_MASK = MAX_NUM_ENTITIES - 1;\r\nconst MAX_NUM_COMPONENTS = 2 ** COMPONENT_ID_BITS;\r\nconst COMPONENT_ID_MASK = MAX_NUM_COMPONENTS - 1;\r\nconst MAX_NUM_FIELDS = 2 ** FIELD_SEQ_BITS;\r\nconst FIELD_SEQ_MASK = MAX_NUM_FIELDS - 1;\r\n// TODO: enforce max length of ref structs/arrays\n\nclass InternalError extends Error {\r\n    constructor(message) {\r\n        super(`Internal error: ${message}. Please report a bug!`);\r\n    }\r\n}\r\nclass CheckError extends Error {\r\n}\n\nconst encoder = new TextEncoder();\r\nconst decoder = new TextDecoder();\r\nfunction throwNotWritable(binding) {\r\n    throw new CheckError(`Component is not writable; ` +\r\n        `use entity.write(${binding.type.name}) to acquire a writable version`);\r\n}\r\nfunction checkInvalid(component, binding) {\r\n    if (component.__invalid) {\r\n        throw new CheckError(`Component instance for ${binding.type.name} is no longer valid, as you already bound it ` +\r\n            `to another entity`);\r\n    }\r\n}\r\nclass Type {\r\n    defaultValue;\r\n    shared;\r\n    constructor(defaultValue, shared = true) {\r\n        this.defaultValue = defaultValue;\r\n        this.shared = shared;\r\n    }\r\n    get internallyIndexed() { return false; }\r\n    /* eslint-disable lines-between-class-members */\r\n    static boolean;\r\n    static uint8;\r\n    static int8;\r\n    static uint16;\r\n    static int16;\r\n    static uint32;\r\n    static int32;\r\n    static float32;\r\n    static float64;\r\n    static vector;\r\n    static staticString;\r\n    static dynamicString;\r\n    static object;\r\n    static weakObject;\r\n    // TODO: add autoremove/autodelete when nulled out\r\n    static ref;\r\n    static backrefs;\r\n}\r\nclass BooleanType extends Type {\r\n    constructor() { super(false); }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity, Uint8Array, (newData) => { data = newData; });\r\n        };\r\n        field.updateBuffer();\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return Boolean(data[binding.writableIndex]);\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value ? 1 : 0;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return Boolean(data[binding.readonlyIndex]);\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, Uint8Array);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return Boolean(data[binding.writableIndex]);\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value ? 1 : 0;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return Boolean(data[binding.readonlyIndex]);\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass NumberType extends Type {\r\n    NumberArray;\r\n    constructor(NumberArray) {\r\n        super(0);\r\n        this.NumberArray = NumberArray;\r\n    }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.NumberArray, (newData) => { data = newData; });\r\n        };\r\n        field.updateBuffer();\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.writableIndex];\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.readonlyIndex];\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.NumberArray);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.writableIndex];\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.readonlyIndex];\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass VectorType extends Type {\r\n    type;\r\n    Class;\r\n    stride;\r\n    elementNames;\r\n    constructor(type, elements, Class) {\r\n        super(new Array(typeof elements === 'number' ? elements : elements.length).fill(0));\r\n        this.type = type;\r\n        this.Class = Class;\r\n        if (typeof elements === 'number') {\r\n            this.stride = elements;\r\n        }\r\n        else {\r\n            this.stride = elements.length;\r\n            this.elementNames = elements;\r\n        }\r\n    }\r\n    get internallyIndexed() { return true; }\r\n    defineElastic(binding, field) {\r\n        const stride = this.stride;\r\n        const elementNames = this.elementNames;\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity * stride, this.type.NumberArray, (newData) => { data = newData; });\r\n        };\r\n        field.updateBuffer();\r\n        const masterWritableAccessor = this.Class ? new this.Class() : {};\r\n        const masterReadonlyAccessor = this.Class ? new this.Class() : {};\r\n        Object.defineProperty(masterWritableAccessor, 'length', { value: stride });\r\n        Object.defineProperty(masterReadonlyAccessor, 'length', { value: stride });\r\n        {\r\n            Object.defineProperty(masterWritableAccessor, '__becsyComponent', { value: undefined, writable: true });\r\n            Object.defineProperty(masterReadonlyAccessor, '__becsyComponent', { value: undefined, writable: true });\r\n        }\r\n        let writableAccessor = Object.create(masterWritableAccessor);\r\n        Object.seal(writableAccessor);\r\n        let readonlyAccessor = Object.create(masterReadonlyAccessor);\r\n        Object.seal(readonlyAccessor);\r\n        /* eslint-disable no-loop-func */\r\n        for (let i = 0; i < this.stride; i++) {\r\n            Object.defineProperty(masterWritableAccessor, `${i}`, {\r\n                enumerable: true,\r\n                get() {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    return data[binding.writableIndex * stride + i];\r\n                },\r\n                set(value) {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    data[binding.writableIndex * stride + i] = value;\r\n                }\r\n            });\r\n            Object.defineProperty(masterReadonlyAccessor, `${i}`, {\r\n                enumerable: true,\r\n                get() {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    return data[binding.readonlyIndex * stride + i];\r\n                },\r\n                set(value) {\r\n                    throwNotWritable(binding);\r\n                }\r\n            });\r\n            if (this.elementNames?.[i]) {\r\n                Object.defineProperty(masterWritableAccessor, this.elementNames[i], {\r\n                    enumerable: true,\r\n                    get() {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        return data[binding.writableIndex * stride + i];\r\n                    },\r\n                    set(value) {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        data[binding.writableIndex * stride + i] = value;\r\n                    }\r\n                });\r\n                Object.defineProperty(masterReadonlyAccessor, this.elementNames[i], {\r\n                    enumerable: true,\r\n                    get() {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        return data[binding.readonlyIndex * stride + i];\r\n                    },\r\n                    set(value) {\r\n                        throwNotWritable(binding);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        /* eslint-enable no-loop-func */\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                {\r\n                    checkInvalid(this, binding);\r\n                    writableAccessor = Object.create(masterWritableAccessor);\r\n                    writableAccessor.__becsyComponent = this;\r\n                    Object.seal(writableAccessor);\r\n                }\r\n                return writableAccessor;\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value.length) {\r\n                    if (value.length !== stride) {\r\n                        throw new CheckError(`Value of length ${value.length} doesn't match vector of length ${stride}`);\r\n                    }\r\n                    for (let i = 0; i < stride; i++)\r\n                        data[binding.writableIndex * stride + i] = value[i];\r\n                }\r\n                else {\r\n                    if (!elementNames) {\r\n                        throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} must be an array`);\r\n                    }\r\n                    for (let i = 0; i < stride; i++) {\r\n                        if (typeof value[elementNames[i]] !== 'number') {\r\n                            throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} is missing element ` +\r\n                                `\"${elementNames[i]}`);\r\n                        }\r\n                        data[binding.writableIndex * stride + i] = value[elementNames[i]];\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                {\r\n                    checkInvalid(this, binding);\r\n                    readonlyAccessor = Object.create(masterReadonlyAccessor);\r\n                    readonlyAccessor.__becsyComponent = this;\r\n                    Object.seal(readonlyAccessor);\r\n                }\r\n                return readonlyAccessor;\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const stride = this.stride;\r\n        const elementNames = this.elementNames;\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity * stride, this.type.NumberArray);\r\n        const masterWritableAccessor = this.Class ? new this.Class() : {};\r\n        const masterReadonlyAccessor = this.Class ? new this.Class() : {};\r\n        Object.defineProperty(masterWritableAccessor, 'length', { value: stride });\r\n        Object.defineProperty(masterReadonlyAccessor, 'length', { value: stride });\r\n        {\r\n            Object.defineProperty(masterWritableAccessor, '__becsyComponent', { value: undefined, writable: true });\r\n            Object.defineProperty(masterReadonlyAccessor, '__becsyComponent', { value: undefined, writable: true });\r\n        }\r\n        let writableAccessor = Object.create(masterWritableAccessor);\r\n        Object.seal(writableAccessor);\r\n        let readonlyAccessor = Object.create(masterReadonlyAccessor);\r\n        Object.seal(readonlyAccessor);\r\n        for (let i = 0; i < this.stride; i++) {\r\n            Object.defineProperty(masterWritableAccessor, `${i}`, {\r\n                enumerable: true,\r\n                get() {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    return data[binding.writableIndex * stride + i];\r\n                },\r\n                set(value) {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    data[binding.writableIndex * stride + i] = value;\r\n                }\r\n            });\r\n            Object.defineProperty(masterReadonlyAccessor, `${i}`, {\r\n                enumerable: true,\r\n                get() {\r\n                    checkInvalid(this.__becsyComponent, binding);\r\n                    return data[binding.readonlyIndex * stride + i];\r\n                },\r\n                set(value) {\r\n                    throwNotWritable(binding);\r\n                }\r\n            });\r\n            if (this.elementNames?.[i]) {\r\n                Object.defineProperty(masterWritableAccessor, this.elementNames[i], {\r\n                    enumerable: true,\r\n                    get() {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        return data[binding.writableIndex * stride + i];\r\n                    },\r\n                    set(value) {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        data[binding.writableIndex * stride + i] = value;\r\n                    }\r\n                });\r\n                Object.defineProperty(masterReadonlyAccessor, this.elementNames[i], {\r\n                    enumerable: true,\r\n                    get() {\r\n                        checkInvalid(this.__becsyComponent, binding);\r\n                        return data[binding.readonlyIndex * stride + i];\r\n                    },\r\n                    set(value) {\r\n                        throwNotWritable(binding);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                {\r\n                    checkInvalid(this, binding);\r\n                    writableAccessor = Object.create(masterWritableAccessor);\r\n                    writableAccessor.__becsyComponent = this;\r\n                    Object.seal(writableAccessor);\r\n                }\r\n                return writableAccessor;\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value.length) {\r\n                    if (value.length !== stride) {\r\n                        throw new CheckError(`Value of length ${value.length} doesn't match vector of length ${stride}`);\r\n                    }\r\n                    for (let i = 0; i < stride; i++)\r\n                        data[binding.writableIndex * stride + i] = value[i];\r\n                }\r\n                else {\r\n                    if (!elementNames) {\r\n                        throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} must be an array`);\r\n                    }\r\n                    for (let i = 0; i < stride; i++) {\r\n                        if (typeof value[elementNames[i]] !== 'number') {\r\n                            throw new CheckError(`Value assigned to ${binding.type.name}.${field.name} is missing element ` +\r\n                                `\"${elementNames[i]}`);\r\n                        }\r\n                        data[binding.writableIndex * stride + i] = value[elementNames[i]];\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                {\r\n                    checkInvalid(this, binding);\r\n                    readonlyAccessor = Object.create(masterReadonlyAccessor);\r\n                    readonlyAccessor.__becsyComponent = this;\r\n                    Object.seal(readonlyAccessor);\r\n                }\r\n                return readonlyAccessor;\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass StaticStringType extends Type {\r\n    choices;\r\n    choicesIndex = new Map();\r\n    TypedArray;\r\n    constructor(choices) {\r\n        super(choices[0]);\r\n        this.choices = choices;\r\n        {\r\n            if (!choices?.length)\r\n                throw new CheckError('No choices specified for Type.staticString');\r\n        }\r\n        if (choices.length < 1 << 8)\r\n            this.TypedArray = Uint8Array;\r\n        else if (choices.length < 1 << 16)\r\n            this.TypedArray = Uint16Array;\r\n        else\r\n            this.TypedArray = Uint32Array;\r\n        for (let i = 0; i < choices.length; i++)\r\n            this.choicesIndex.set(choices[i], i);\r\n    }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        const choices = this.choices, choicesIndex = this.choicesIndex;\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.TypedArray, (newData) => { data = newData; });\r\n        };\r\n        field.updateBuffer();\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const index = data[binding.writableIndex];\r\n                const result = choices[index];\r\n                {\r\n                    if (result === undefined)\r\n                        throw new CheckError(`Invalid static string index: ${index}`);\r\n                }\r\n                return result;\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                const index = choicesIndex.get(value);\r\n                {\r\n                    if (index === undefined)\r\n                        throw new CheckError(`Static string not in set: \"${value}\"`);\r\n                }\r\n                data[binding.writableIndex] = index;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const index = data[binding.readonlyIndex];\r\n                const result = choices[index];\r\n                {\r\n                    if (result === undefined)\r\n                        throw new CheckError(`Invalid static string index: ${index}`);\r\n                }\r\n                return result;\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const choices = this.choices, choicesIndex = this.choicesIndex;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, this.TypedArray);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const index = data[binding.writableIndex];\r\n                const result = choices[index];\r\n                {\r\n                    if (result === undefined)\r\n                        throw new CheckError(`Invalid static string index: ${index}`);\r\n                }\r\n                return result;\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                const index = choicesIndex.get(value);\r\n                {\r\n                    if (index === undefined)\r\n                        throw new CheckError(`Static string not in set: \"${value}\"`);\r\n                }\r\n                data[binding.writableIndex] = index;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const index = data[binding.readonlyIndex];\r\n                const result = choices[index];\r\n                {\r\n                    if (result === undefined)\r\n                        throw new CheckError(`Invalid static string index: ${index}`);\r\n                }\r\n                return result;\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass DynamicStringType extends Type {\r\n    maxUtf8Length;\r\n    lengthsStride;\r\n    bytesStride;\r\n    constructor(maxUtf8Length) {\r\n        super('');\r\n        this.maxUtf8Length = maxUtf8Length + (maxUtf8Length % 2);\r\n        this.bytesStride = this.maxUtf8Length + 2; // account for length field\r\n        this.lengthsStride = this.bytesStride / 2;\r\n    }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let lengths;\r\n        let bytes;\r\n        const maxUtf8Length = this.maxUtf8Length;\r\n        const lengthsStride = this.lengthsStride, bytesStride = this.bytesStride;\r\n        field.updateBuffer = () => {\r\n            const size = binding.capacity * (this.maxUtf8Length + Uint16Array.BYTES_PER_ELEMENT);\r\n            binding.dispatcher.buffers.register(bufferKey, size, Uint8Array, (newData) => {\r\n                bytes = newData;\r\n                lengths = new Uint16Array(bytes.buffer);\r\n            });\r\n        };\r\n        field.updateBuffer();\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const length = lengths[binding.writableIndex * lengthsStride];\r\n                return decoder.decode(new Uint8Array(bytes.buffer, binding.writableIndex * bytesStride + 2, length));\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                const encodedString = encoder.encode(value);\r\n                {\r\n                    if (encodedString.byteLength > maxUtf8Length) {\r\n                        throw new CheckError(`Dynamic string length > ${maxUtf8Length} after encoding: ${value}`);\r\n                    }\r\n                }\r\n                lengths[binding.writableIndex * lengthsStride] = encodedString.byteLength;\r\n                bytes.set(encodedString, binding.writableIndex * bytesStride + 2);\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const length = lengths[binding.readonlyIndex * lengthsStride];\r\n                return decoder.decode(new Uint8Array(bytes.buffer, binding.readonlyIndex * bytesStride + 2, length));\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const maxUtf8Length = this.maxUtf8Length;\r\n        const lengthsStride = this.lengthsStride, bytesStride = this.bytesStride;\r\n        const size = binding.capacity * (this.maxUtf8Length + Uint16Array.BYTES_PER_ELEMENT);\r\n        const bytes = binding.dispatcher.buffers.register(bufferKey, size, Uint8Array);\r\n        const lengths = new Uint16Array(bytes.buffer);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const length = lengths[binding.writableIndex * lengthsStride];\r\n                return decoder.decode(new Uint8Array(bytes.buffer, binding.writableIndex * bytesStride + 2, length));\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                const encodedString = encoder.encode(value);\r\n                {\r\n                    if (encodedString.byteLength > maxUtf8Length) {\r\n                        throw new CheckError(`Dynamic string length > ${maxUtf8Length} after encoding: ${value}`);\r\n                    }\r\n                }\r\n                lengths[binding.writableIndex * lengthsStride] = encodedString.byteLength;\r\n                bytes.set(encodedString, binding.writableIndex * bytesStride + 2);\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const length = lengths[binding.readonlyIndex * lengthsStride];\r\n                return decoder.decode(new Uint8Array(bytes.buffer, binding.readonlyIndex * bytesStride + 2, length));\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nconst STALE_REF_BIT = 2 ** 31;\r\nclass RefType extends Type {\r\n    constructor() {\r\n        super(undefined);\r\n    }\r\n    defineElastic(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        let data;\r\n        const indexer = binding.dispatcher.indexer;\r\n        const registry = binding.dispatcher.registry;\r\n        const pool = registry.pool;\r\n        indexer.registerSelector();\r\n        field.updateBuffer = () => {\r\n            binding.dispatcher.buffers.register(bufferKey, binding.capacity, Int32Array, (newData) => { data = newData; }, -1);\r\n        };\r\n        field.updateBuffer();\r\n        field.clearRef = (final, targetId, internalIndex) => {\r\n            if (internalIndex)\r\n                throw new InternalError('Ref fields have no internal index');\r\n            if (data[binding.writableIndex] === -1)\r\n                return;\r\n            const stale = (data[binding.writableIndex] & STALE_REF_BIT) !== 0;\r\n            if (stale && !final)\r\n                return;\r\n            if (!stale && final)\r\n                throw new InternalError('Wrong ref stale state');\r\n            const id = (data[binding.writableIndex] & ENTITY_ID_MASK);\r\n            const targetIdGiven = targetId !== undefined;\r\n            if (targetIdGiven && id !== targetId)\r\n                return;\r\n            if (final) {\r\n                data[binding.writableIndex] = -1;\r\n            }\r\n            else {\r\n                data[binding.writableIndex] |= STALE_REF_BIT;\r\n            }\r\n            indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, id, -1, !final, final);\r\n        };\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const id = data[binding.writableIndex];\r\n                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)\r\n                    return;\r\n                return pool.borrowTemporarily((id & ENTITY_ID_MASK));\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value && !registry.hasShape(value.__id, registry.Alive, false)) {\r\n                    throw new CheckError('Referencing a deleted entity is not allowed');\r\n                }\r\n                let oldId = data[binding.writableIndex];\r\n                if (oldId !== -1)\r\n                    oldId = (oldId & ENTITY_ID_MASK);\r\n                const stale = oldId !== -1 && !!(data[binding.writableIndex] & STALE_REF_BIT);\r\n                const newId = (value?.__id ?? -1);\r\n                if (oldId === newId && !stale)\r\n                    return;\r\n                data[binding.writableIndex] = newId;\r\n                indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, oldId, newId, !stale, true);\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const id = data[binding.readonlyIndex];\r\n                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)\r\n                    return;\r\n                return pool.borrowTemporarily((id & ENTITY_ID_MASK));\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const bufferKey = `component.${binding.type.id}.field.${field.seq}`;\r\n        const data = binding.dispatcher.buffers.register(bufferKey, binding.capacity, Int32Array, undefined, -1);\r\n        const indexer = binding.dispatcher.indexer;\r\n        const registry = binding.dispatcher.registry;\r\n        const pool = registry.pool;\r\n        indexer.registerSelector();\r\n        field.clearRef = (final, targetId, internalIndex) => {\r\n            if (internalIndex)\r\n                throw new InternalError('Ref fields have no internal index');\r\n            if (data[binding.writableIndex] === -1)\r\n                return;\r\n            const stale = (data[binding.writableIndex] & STALE_REF_BIT) !== 0;\r\n            if (stale && !final)\r\n                return;\r\n            if (!stale && final)\r\n                throw new InternalError('Wrong ref stale state');\r\n            const id = (data[binding.writableIndex] & ENTITY_ID_MASK);\r\n            const targetIdGiven = targetId !== undefined;\r\n            if (targetIdGiven && id !== targetId)\r\n                return;\r\n            if (final) {\r\n                data[binding.writableIndex] = -1;\r\n            }\r\n            else {\r\n                data[binding.writableIndex] |= STALE_REF_BIT;\r\n            }\r\n            indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, id, -1, !final, final);\r\n        };\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const id = data[binding.writableIndex];\r\n                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)\r\n                    return;\r\n                return pool.borrowTemporarily((id & ENTITY_ID_MASK));\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value && !registry.hasShape(value.__id, registry.Alive, false)) {\r\n                    throw new CheckError('Referencing a deleted entity is not allowed');\r\n                }\r\n                let oldId = data[binding.writableIndex];\r\n                if (oldId !== -1)\r\n                    oldId = (oldId & ENTITY_ID_MASK);\r\n                const stale = oldId !== -1 && !!(data[binding.writableIndex] & STALE_REF_BIT);\r\n                const newId = (value?.__id ?? -1);\r\n                if (oldId === newId && !stale)\r\n                    return;\r\n                data[binding.writableIndex] = newId;\r\n                indexer.trackRefChange(binding.writableEntityId, binding.type, field.seq, undefined, oldId, newId, !stale, true);\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const id = data[binding.readonlyIndex];\r\n                if (id === -1 || (id & STALE_REF_BIT) && !registry.includeRecentlyDeleted)\r\n                    return;\r\n                return pool.borrowTemporarily((id & ENTITY_ID_MASK));\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nconst EMPTY_ARRAY = [];\r\nclass BackrefsType extends Type {\r\n    type;\r\n    fieldName;\r\n    trackDeletedBackrefs;\r\n    constructor(type, fieldName, trackDeletedBackrefs) {\r\n        super(EMPTY_ARRAY);\r\n        this.type = type;\r\n        this.fieldName = fieldName;\r\n        this.trackDeletedBackrefs = trackDeletedBackrefs;\r\n    }\r\n    // TODO: build benchmarks for backrefs and see if storing pointers to the trackers' entities\r\n    // arrays for direct access performs significantly better than looking them up in the indexer's\r\n    // Map each time.\r\n    defineElastic(binding, field) {\r\n        field.updateBuffer = () => { };\r\n        const refField = this.fieldName ?\r\n            this.type?.__binding.fields.find(aField => aField.name === this.fieldName) : undefined;\r\n        {\r\n            if (this.fieldName && !refField) {\r\n                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +\r\n                    `an unknown field ${this.type.name}.${this.fieldName}`);\r\n            }\r\n            if (refField && refField.type !== Type.ref) {\r\n                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +\r\n                    `a field ${this.type.name}.${this.fieldName} that is not a ref`);\r\n            }\r\n            if (this.fieldName && !this.type) {\r\n                throw new CheckError(`Backrefs selector has field but no component in ${binding.type.name}.${field.name}`);\r\n            }\r\n            if (this.type && !this.fieldName && !this.type.__binding.refFields.length) {\r\n                throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} refers to ` +\r\n                    `component ${this.type.name} that has no ref fields`);\r\n            }\r\n        }\r\n        const trackDeletedBackrefs = this.trackDeletedBackrefs;\r\n        const indexer = binding.dispatcher.indexer;\r\n        indexer.registerSelector(); // make sure global selector always registered first\r\n        const selectorId = indexer.registerSelector(binding.type, this.type, refField?.seq, this.trackDeletedBackrefs);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                if (!trackDeletedBackrefs && binding.dispatcher.registry.includeRecentlyDeleted) {\r\n                    throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} not configured to track recently ` +\r\n                        `deleted refs`);\r\n                }\r\n                return indexer.getBackrefs(binding.writableEntityId, selectorId);\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value !== EMPTY_ARRAY) {\r\n                    throw new CheckError('Backrefs properties are computed automatically, you cannot set them');\r\n                }\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                if (!trackDeletedBackrefs && binding.dispatcher.registry.includeRecentlyDeleted) {\r\n                    throw new CheckError(`Backrefs field ${binding.type.name}.${field.name} not configured to track recently ` +\r\n                        `deleted refs`);\r\n                }\r\n                return indexer.getBackrefs(binding.readonlyEntityId, selectorId);\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value !== EMPTY_ARRAY) {\r\n                    throw new CheckError('Backrefs properties are computed automatically, you cannot set them');\r\n                }\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        this.defineElastic(binding, field);\r\n    }\r\n}\r\nclass ObjectType extends Type {\r\n    constructor() { super(undefined, false); }\r\n    defineElastic(binding, field) {\r\n        const data = [];\r\n        field.updateBuffer = () => { };\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.writableIndex];\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.readonlyIndex];\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        const data = new Array(binding.capacity);\r\n        field.updateBuffer = () => { };\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.writableIndex];\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                return data[binding.readonlyIndex];\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass WeakObjectType extends Type {\r\n    finalizers;\r\n    constructor() { super(undefined, false); }\r\n    defineElastic(binding, field) {\r\n        const data = [];\r\n        field.updateBuffer = () => { };\r\n        const finalizers = this.initFinalizers(binding);\r\n        Object.defineProperty(binding.writableMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const value = data[binding.writableIndex];\r\n                if (value === null || value === undefined)\r\n                    return value;\r\n                return value.deref();\r\n            },\r\n            set(value) {\r\n                checkInvalid(this, binding);\r\n                if (value !== null && value !== undefined) {\r\n                    const weakRef = new WeakRef(value);\r\n                    finalizers?.register(value, {\r\n                        type: binding.type, data, weakRef, id: binding.writableEntityId,\r\n                        index: binding.writableIndex\r\n                    });\r\n                    value = weakRef;\r\n                }\r\n                data[binding.writableIndex] = value;\r\n            }\r\n        });\r\n        Object.defineProperty(binding.readonlyMaster, field.name, {\r\n            enumerable: true, configurable: true,\r\n            get() {\r\n                checkInvalid(this, binding);\r\n                const value = data[binding.readonlyIndex];\r\n                if (value === null || value === undefined)\r\n                    return value;\r\n                return value.deref();\r\n            },\r\n            set(value) {\r\n                throwNotWritable(binding);\r\n            }\r\n        });\r\n    }\r\n    defineFixed(binding, field) {\r\n        this.defineElastic(binding, field);\r\n    }\r\n    initFinalizers(binding) {\r\n        if (!binding.trackedWrites)\r\n            return;\r\n        if (this.finalizers)\r\n            return this.finalizers;\r\n        const dispatcher = binding.dispatcher;\r\n        if (!dispatcher.writeLog || typeof FinalizationRegistry === 'undefined')\r\n            return;\r\n        this.finalizers = new FinalizationRegistry(({ type, data, weakRef, id, index }) => {\r\n            if (data[index] === weakRef)\r\n                dispatcher.registry.trackWrite(id, type);\r\n        });\r\n        return this.finalizers;\r\n    }\r\n}\r\n// The fields below are replicated in the @field decorator, keep them in sync.\r\nType.boolean = new BooleanType();\r\nType.uint8 = new NumberType(Uint8Array);\r\nType.int8 = new NumberType(Int8Array);\r\nType.uint16 = new NumberType(Uint16Array);\r\nType.int16 = new NumberType(Int16Array);\r\nType.uint32 = new NumberType(Uint32Array);\r\nType.int32 = new NumberType(Int32Array);\r\nType.float32 = new NumberType(Float32Array);\r\nType.float64 = new NumberType(Float64Array);\r\nType.vector = (type, elements, Class) => new VectorType(type, elements, Class);\r\nType.staticString = (choices) => new StaticStringType(choices);\r\nType.dynamicString = (maxUtf8Length) => new DynamicStringType(maxUtf8Length);\r\nType.ref = new RefType();\r\nType.backrefs = (type, fieldName, trackDeletedBackrefs = false) => new BackrefsType(type, fieldName, trackDeletedBackrefs);\r\nType.object = new ObjectType();\r\nType.weakObject = new WeakObjectType();\n\nclass Binding {\r\n    type;\r\n    fields;\r\n    dispatcher;\r\n    capacity;\r\n    storage;\r\n    elastic;\r\n    constructor(type, fields, shapeSpec, dispatcher, capacity, storage, elastic) {\r\n        this.type = type;\r\n        this.fields = fields;\r\n        this.dispatcher = dispatcher;\r\n        this.capacity = capacity;\r\n        this.storage = storage;\r\n        this.elastic = elastic;\r\n        this.readonlyMaster = this.readonlyInstance = new type(); // eslint-disable-line new-cap\r\n        this.writableMaster = this.writableInstance = new type(); // eslint-disable-line new-cap\r\n        {\r\n            this.readonlyInstance = Object.create(this.readonlyMaster);\r\n            this.readonlyInstance.__invalid = !this.elastic && this.capacity > 1;\r\n            this.writableInstance = Object.create(this.writableMaster);\r\n            this.writableInstance.__invalid = !this.elastic && this.capacity > 1;\r\n        }\r\n        this.shapeOffset = shapeSpec.offset;\r\n        this.shapeMask = shapeSpec.mask;\r\n        this.shapeValue = shapeSpec.value;\r\n        this.refFields = fields.filter(field => field.type === Type.ref);\r\n        this.trackedWrites = false;\r\n        this.writableEntityId = 0;\r\n        this.writableIndex = 0;\r\n        this.readonlyEntityId = 0;\r\n        this.readonlyIndex = 0;\r\n        // eslint-disable-next-line no-new-func\r\n        this.initDefault = new Function('component', fields\r\n            .filter(field => field.default !== EMPTY_ARRAY)\r\n            .map(field => `component.${field.name} = ${JSON.stringify(field.default)};`)\r\n            .join('\\n'));\r\n        let backrefFieldInits = [];\r\n        {\r\n            backrefFieldInits = fields\r\n                .filter(field => field.default === EMPTY_ARRAY)\r\n                .map(field => `\n          if (${JSON.stringify(field.name)} in values) {\n            component.${field.name} = values.${field.name};\n          }\n        `);\r\n        }\r\n        // eslint-disable-next-line no-new-func\r\n        this.init = new Function('component', 'values', fields\r\n            .filter(field => field.default !== EMPTY_ARRAY)\r\n            .map(field => `\n          component.${field.name} = values.${field.name} === undefined ?\n            ${JSON.stringify(field.default)} : values.${field.name};\n        `)\r\n            .concat(backrefFieldInits)\r\n            .join('\\n'));\r\n    }\r\n    resetWritableInstance(entityId, index) {\r\n        if (index === -1) {\r\n            throw new InternalError(`Attempt to bind unacquired entity ${entityId} to ${this.type.name}`);\r\n        }\r\n        this.writableEntityId = entityId;\r\n        this.writableIndex = index;\r\n        if (this.elastic || this.capacity > 1) {\r\n            this.writableInstance.__invalid = true;\r\n            this.writableInstance = Object.create(this.writableMaster);\r\n        }\r\n        return this.writableInstance;\r\n    }\r\n    resetReadonlyInstance(entityId, index) {\r\n        if (index === -1) {\r\n            throw new InternalError(`Attempt to bind unacquired entity ${entityId} to ${this.type.name}`);\r\n        }\r\n        this.readonlyEntityId = entityId;\r\n        this.readonlyIndex = index;\r\n        if (this.elastic || this.capacity > 1) {\r\n            this.readonlyInstance.__invalid = true;\r\n            this.readonlyInstance = Object.create(this.readonlyMaster);\r\n        }\r\n        return this.readonlyInstance;\r\n    }\r\n}\r\nfunction checkTypeDefined(type) {\r\n    if (!type.__binding) {\r\n        throw new CheckError(`Component ${type.name} not defined; add to world defs`);\r\n    }\r\n}\r\nclass PackedStorage {\r\n    maxEntities;\r\n    binding;\r\n    fields;\r\n    constructor(maxEntities, binding, fields) {\r\n        this.maxEntities = maxEntities;\r\n        this.binding = binding;\r\n        this.fields = fields;\r\n        this.growSpares();\r\n        this.growCapacity();\r\n    }\r\n    acquireIndex(id) {\r\n        let index = this.index[id];\r\n        if (index === -1) {\r\n            if (this.spares[3] > 0) {\r\n                index = this.spares[--this.spares[3] + 4];\r\n            }\r\n            else {\r\n                if (this.spares[1] === this.spares[2]) {\r\n                    if (!this.binding.elastic) {\r\n                        throw new CheckError(`Storage exhausted for component ${this.binding.type.name}; ` +\r\n                            `raise its capacity above ${this.binding.capacity}`);\r\n                    }\r\n                    if (this.binding.capacity === this.maxEntities) {\r\n                        throw new InternalError(`Trying to grow storage index for component ${this.binding.type.name} beyond ` +\r\n                            `maxEntities`);\r\n                    }\r\n                    this.binding.capacity = Math.min(this.maxEntities, this.binding.capacity * 2);\r\n                    this.growCapacity();\r\n                }\r\n                index = this.spares[1]++;\r\n            }\r\n            this.index[id] = index;\r\n        }\r\n        return index;\r\n    }\r\n    releaseIndex(id) {\r\n        if (this.index[id] === -1) {\r\n            throw new InternalError(`Index for entity ${id} in component ${this.binding.type.name} not allocated`);\r\n        }\r\n        if (this.spares[3] === this.spares.length - 4)\r\n            this.growSpares();\r\n        this.spares[this.spares[3]++ + 4] = this.index[id];\r\n        this.index[id] = -1;\r\n    }\r\n    growCapacity() {\r\n        const capacity = this.binding.capacity;\r\n        this.binding.dispatcher.stats.forComponent(this.binding.type).capacity = capacity;\r\n        const ArrayType = this.ArrayType;\r\n        const elementSizeChanged = ArrayType.BYTES_PER_ELEMENT !== this.spares?.[0];\r\n        if (!this.index || elementSizeChanged) {\r\n            this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.index`, this.maxEntities, ArrayType, (index) => { this.index = index; }, -1);\r\n        }\r\n        if (elementSizeChanged) {\r\n            this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.spares`, this.spares.length, ArrayType, this.updateSpares.bind(this));\r\n        }\r\n        else {\r\n            this.spares[2] = capacity;\r\n        }\r\n        if (this.binding.elastic)\r\n            for (const field of this.fields)\r\n                field.updateBuffer();\r\n    }\r\n    growSpares() {\r\n        const maxSpares = this.spares ? Math.min(this.maxEntities, (this.spares.length - 4) * 2) : 8;\r\n        this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.spares`, 4 + maxSpares, this.ArrayType, this.updateSpares.bind(this));\r\n    }\r\n    updateSpares(spares) {\r\n        spares[2] = this.binding.capacity = Math.max(this.binding.capacity, spares[2]);\r\n        spares[0] = this.ArrayType.BYTES_PER_ELEMENT;\r\n        this.spares = spares;\r\n    }\r\n    get ArrayType() {\r\n        const capacity = Math.max(this.spares?.[2] ?? 0, this.binding.capacity);\r\n        return capacity < (1 << 7) ? Int8Array : capacity < (1 << 15) ? Int16Array : Int32Array;\r\n    }\r\n}\r\nclass CompactStorage {\r\n    maxEntities;\r\n    binding;\r\n    fields;\r\n    constructor(maxEntities, binding, fields) {\r\n        this.maxEntities = maxEntities;\r\n        this.binding = binding;\r\n        this.fields = fields;\r\n        this.growCapacity();\r\n    }\r\n    findIndex(id) {\r\n        for (let i = 0; i < this.index.length; i++) {\r\n            if (this.index[i] === id)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n    acquireIndex(id) {\r\n        let firstEmpty;\r\n        for (let i = 0; i < this.index.length; i++) {\r\n            if (this.index[i] === id)\r\n                return i;\r\n            if (firstEmpty === undefined && this.index[i] === -1)\r\n                firstEmpty = i;\r\n        }\r\n        if (firstEmpty === undefined) {\r\n            if (!this.binding.elastic) {\r\n                throw new CheckError(`Storage exhausted for component ${this.binding.type.name}; ` +\r\n                    `raise its capacity above ${this.binding.capacity}`);\r\n            }\r\n            if (this.binding.capacity === this.maxEntities) {\r\n                throw new InternalError(`Trying to grow storage index for component ${this.binding.type.name} beyond ` +\r\n                    `maxEntities`);\r\n            }\r\n            firstEmpty = this.index.length;\r\n            this.binding.capacity = Math.min(this.maxEntities, this.binding.capacity * 2);\r\n            this.growCapacity();\r\n        }\r\n        this.index[firstEmpty] = id;\r\n        return firstEmpty;\r\n    }\r\n    releaseIndex(id) {\r\n        for (let i = 0; i < this.index.length; i++) {\r\n            if (this.index[i] === id) {\r\n                this.index[i] = -1;\r\n                return;\r\n            }\r\n        }\r\n        throw new InternalError(`Index for entity ${id} in component ${this.binding.type.name} not allocated`);\r\n    }\r\n    growCapacity() {\r\n        const capacity = this.binding.capacity;\r\n        this.binding.dispatcher.stats.forComponent(this.binding.type).capacity = capacity;\r\n        this.binding.dispatcher.buffers.register(`component.${this.binding.type.id}.storage.index`, capacity, Int32Array, this.updateIndex.bind(this), -1);\r\n        if (this.binding.elastic)\r\n            for (const field of this.fields)\r\n                field.updateBuffer();\r\n    }\r\n    updateIndex(index) {\r\n        this.index = index;\r\n        this.binding.capacity = this.index.length;\r\n    }\r\n}\r\nfunction initComponent(type, id, values) {\r\n    {\r\n        checkTypeDefined(type);\r\n        if (values !== undefined) {\r\n            for (const key in values) {\r\n                if (!type.schema?.[key]) {\r\n                    throw new CheckError(`Property ${key} not defined for component ${type.name}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const component = type.__allocate(id);\r\n    if (values) {\r\n        type.__binding.init(component, values);\r\n    }\r\n    else {\r\n        type.__binding.initDefault(component);\r\n    }\r\n}\r\nfunction gatherFields(type) {\r\n    const schema = type.schema;\r\n    const fields = [];\r\n    if (schema) {\r\n        let seq = 0;\r\n        for (const name in schema) {\r\n            let entry = schema[name];\r\n            if (entry instanceof Type || typeof entry === 'function')\r\n                entry = { type: entry };\r\n            if (typeof entry.type === 'function')\r\n                entry.type = entry.type();\r\n            if (!('default' in entry))\r\n                entry.default = entry.type.defaultValue;\r\n            fields.push({ name, seq: seq++, type: entry.type, default: entry.default });\r\n        }\r\n        if (seq > MAX_NUM_FIELDS) {\r\n            throw new CheckError(`Component ${type.name} declares too many fields`);\r\n        }\r\n    }\r\n    return fields;\r\n}\r\nfunction assimilateComponentType(typeId, type, shapeSpec, dispatcher) {\r\n    const fields = gatherFields(type);\r\n    // For tag components, force sparse storage since we don't actually need to allocate anything.\r\n    const storage = fields.length ? (type.options?.storage ?? dispatcher.defaultComponentStorage) : 'sparse';\r\n    const capacity = storage === 'sparse' ?\r\n        dispatcher.maxEntities : Math.min(dispatcher.maxEntities, type.options?.capacity ?? 0);\r\n    const initialCapacity = type.options?.initialCapacity ?? 8;\r\n    {\r\n        if (typeof type.options?.capacity !== 'undefined') {\r\n            if (storage === 'sparse') {\r\n                throw new CheckError(`Component type ${type.name} cannot combine custom capacity with sparse storage`);\r\n            }\r\n            if (type.options.capacity <= 0) {\r\n                throw new CheckError(`Component type ${type.name} capacity option must be great than zero: got ${capacity}`);\r\n            }\r\n            if (typeof type.options.initialCapacity !== 'undefined') {\r\n                throw new CheckError(`Component type ${type.name} cannot have both capacity and initialCapacity options`);\r\n            }\r\n        }\r\n        if (type.options?.restrictedToMainThread && fields.every(field => field.type.shared)) {\r\n            throw new CheckError(`Component type ${type.name} is restrictedToMainThread but has no thread-exclusive fields`);\r\n        }\r\n        if ((typeof process === 'undefined' || process.env.NODE_ENV !== 'test') && type.__bind) {\r\n            throw new CheckError(`Component type ${type.name} is already in use in another world`);\r\n        }\r\n    }\r\n    type.id = typeId;\r\n    const binding = new Binding(type, fields, shapeSpec, dispatcher, capacity || initialCapacity, storage, !capacity);\r\n    type.__binding = binding;\r\n}\r\nfunction defineAndAllocateComponentType(type) {\r\n    const binding = type.__binding;\r\n    for (const field of binding.fields) {\r\n        if (binding.elastic) {\r\n            field.type.defineElastic(binding, field);\r\n        }\r\n        else {\r\n            field.type.defineFixed(binding, field);\r\n        }\r\n    }\r\n    switch (binding.storage) {\r\n        case 'sparse':\r\n            // Inline the trivial storage manager for performance.\r\n            binding.dispatcher.stats.forComponent(type).capacity = binding.capacity; // fixed\r\n            type.__bind = (id, writable) => {\r\n                return writable ?\r\n                    binding.resetWritableInstance(id, id) :\r\n                    binding.resetReadonlyInstance(id, id);\r\n            };\r\n            type.__allocate = (id) => {\r\n                return binding.resetWritableInstance(id, id);\r\n            };\r\n            break;\r\n        case 'packed': {\r\n            const storageManager = new PackedStorage(binding.dispatcher.maxEntities, binding, binding.fields);\r\n            type.__bind = (id, writable) => {\r\n                return writable ?\r\n                    binding.resetWritableInstance(id, storageManager.index[id]) :\r\n                    binding.resetReadonlyInstance(id, storageManager.index[id]);\r\n            };\r\n            type.__allocate = (id) => {\r\n                return binding.resetWritableInstance(id, storageManager.acquireIndex(id));\r\n            };\r\n            type.__free = (id) => {\r\n                storageManager.releaseIndex(id);\r\n            };\r\n            break;\r\n        }\r\n        case 'compact': {\r\n            const storageManager = new CompactStorage(binding.dispatcher.maxEntities, binding, binding.fields);\r\n            type.__bind = (id, writable) => {\r\n                return writable ?\r\n                    binding.resetWritableInstance(id, storageManager.findIndex(id)) :\r\n                    binding.resetReadonlyInstance(id, storageManager.findIndex(id));\r\n            };\r\n            type.__allocate = (id) => {\r\n                return binding.resetWritableInstance(id, storageManager.acquireIndex(id));\r\n            };\r\n            type.__free = (id) => {\r\n                storageManager.releaseIndex(id);\r\n            };\r\n            break;\r\n        }\r\n        default:\r\n            throw new CheckError(`Invalid storage type \"${binding.storage}`);\r\n    }\r\n}\r\nfunction dissimilateComponentType(type) {\r\n    delete type.id;\r\n    delete type.__binding;\r\n    delete type.__bind;\r\n    delete type.__allocate;\r\n    delete type.__free;\r\n}\r\nfunction declareSingleton(type) {\r\n    if (!type.options)\r\n        type.options = {};\r\n    {\r\n        if (type.options.storage && type.options.storage !== 'compact') {\r\n            throw new CheckError(`Component ${type.name} ${type.options.storage} storage is incompatible with singletons`);\r\n        }\r\n        if (type.options.capacity && type.options.capacity !== 1) {\r\n            throw new CheckError(`Component ${type.name} capacity of ${type.options.capacity} ` +\r\n                `is incompatible with singletons`);\r\n        }\r\n        if (type.options.initialCapacity) {\r\n            throw new CheckError(`Component ${type.name} initial capacity of ${type.options.initialCapacity} ` +\r\n                `is incompatible with singletons`);\r\n        }\r\n    }\r\n    type.options.storage = 'compact';\r\n    type.options.capacity = 1;\r\n}\n\n/**\r\n * An entity represents a collection of distinct components with a unique identity.\r\n *\r\n * You can obtain entities from queries in your system.  You must not keep references to entities\r\n * thus obtained, as they may be pointed to another entity at any time between system executions.\r\n * Instead, call {@link Entity.hold} to obtain a long-lived version of the object.\r\n */\r\nclass EntityImpl {\r\n    __registry;\r\n    constructor(__registry) {\r\n        this.__registry = __registry;\r\n        this.__id = undefined;\r\n        this.__sortKey = undefined;\r\n        {\r\n            this.__valid = true;\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether the entity is alive, i.e. has not been deleted.  Turning on\r\n     * `accessRecentlyDeletedData` doesn't affect the return value.\r\n     */\r\n    get alive() {\r\n        this.__checkValid();\r\n        return this.__registry.hasShape(this.__id, this.__registry.Alive, false);\r\n    }\r\n    /**\r\n     * Returns the entity's ordinal number, as determined by the order of entity creation.  Entities\r\n     * created in systems running concurrently may have overlapping ordinals.\r\n     */\r\n    get ordinal() {\r\n        return this.__registry.entityOrdinals[this.__id];\r\n    }\r\n    /**\r\n     * Adds a component to the entity.  If the entity already possesses a component of this type the\r\n     * call will fail.\r\n     * @param type The type of component to add.\r\n     * @param values An optional object with field values to initialize the new component.\r\n     */\r\n    add(type, values) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'write');\r\n            if (!this.__registry.hasShape(this.__id, this.__registry.Alive, false)) {\r\n                throw new CheckError('Entity has been deleted');\r\n            }\r\n            if (this.__registry.hasShape(this.__id, type, false)) {\r\n                throw new CheckError(`Entity already has a ${type.name} component`);\r\n            }\r\n        }\r\n        this.__registry.setShape(this.__id, type);\r\n        this.__registry.dispatcher.stats.forComponent(type).numEntities += 1;\r\n        initComponent(type, this.__id, values);\r\n    }\r\n    /**\r\n     * Adds a list of components to the entity.  If entity already possesses a component of any of\r\n     * the given types, the call will fail.\r\n     * @param args A list of component types to add, optionally interleaved wth objects that specify\r\n     *  fields values for initializing the immediately preceding component.\r\n     */\r\n    addAll(...args) {\r\n        this.__checkValid();\r\n        {\r\n            const enums = new Set();\r\n            for (const arg of args) {\r\n                if (typeof arg === 'function' && arg.enum) {\r\n                    if (enums.has(arg.enum)) {\r\n                        throw new CheckError(`Can't add multiple components from the same enum`);\r\n                    }\r\n                    enums.add(arg.enum);\r\n                }\r\n            }\r\n        }\r\n        for (let i = 0; i < args.length; i++) {\r\n            const type = args[i];\r\n            {\r\n                if (typeof type !== 'function') {\r\n                    throw new CheckError(`Bad arguments to addAll: expected component type, got: ${type}`);\r\n                }\r\n            }\r\n            let value = args[i + 1];\r\n            if (typeof value === 'function')\r\n                value = undefined;\r\n            else\r\n                i++;\r\n            this.add(type, value);\r\n        }\r\n    }\r\n    /**\r\n     * Remove a component from the entity.  If the entity doesn't possess a component of this type\r\n     * the call will fail.\r\n     * @param type The type of component to remove.\r\n     */\r\n    remove(type) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'write');\r\n            if (typeof type === 'function')\r\n                this.__checkHas(type, false);\r\n        }\r\n        if (typeof type !== 'function') {\r\n            const currentType = this.__registry.getEnumShape(this.__id, type, false);\r\n            if (!currentType) {\r\n                throw new CheckError(`Entity doesn't have any components from ${type.name} enumeration`);\r\n            }\r\n            type = currentType;\r\n        }\r\n        this.__registry.clearShape(this.__id, type);\r\n    }\r\n    /**\r\n     * Remove a list of components from the entity.  If the entity doesn't possess a component of any\r\n     * of the given types, the call will fail.\r\n     * @param types A list of component types to remove.\r\n     */\r\n    removeAll(...types) {\r\n        for (const type of types)\r\n            this.remove(type);\r\n    }\r\n    /**\r\n     * Returns whether the entity currently contains a component of the given type.  If a system is\r\n     * running in `accessRecentlyDeletedData` mode, this will also return true for recently removed\r\n     * components.\r\n     *\r\n     * @param type The type of component to check for.\r\n     * @returns Whether the entity has a component of the given type.\r\n     */\r\n    has(type) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'check');\r\n        }\r\n        if (typeof type === 'function')\r\n            return this.__registry.hasShape(this.__id, type, true);\r\n        return !!this.__registry.getEnumShape(this.__id, type, true);\r\n    }\r\n    // TODO: see if precomputing the masks and using Registry.match gets better performance on the\r\n    // following has* methods.\r\n    /**\r\n     * Returns whether the entity currently contains a component of any of the given types.  If a\r\n     * system is running in `accessRecentlyDeletedData` mode, this will also consider recently removed\r\n     * components.\r\n     * @param types A list of component types to check for.\r\n     * @returns Whether the entity has a component of at least one of the given types.\r\n     */\r\n    hasSomeOf(...types) {\r\n        this.__checkValid();\r\n        for (const type of types)\r\n            if (this.has(type))\r\n                return true;\r\n        return false;\r\n    }\r\n    /**\r\n     * Returns whether the entity currently contains a component of every one of the given types.  If\r\n     * a system is running in `accessRecentlyDeletedData` mode, this will also consider recently\r\n     * removed components.\r\n     * @param types A list of component types to check for.\r\n     * @returns Whether the entity has a component of every one of the given types.\r\n     */\r\n    hasAllOf(...types) {\r\n        this.__checkValid();\r\n        for (const type of types)\r\n            if (!this.has(type))\r\n                return false;\r\n        return true;\r\n    }\r\n    /**\r\n     * Returns whether the entity currently contains a component of any type other than the given\r\n     * ones.  If a system is running in `accessRecentlyDeletedData` mode, this will also consider\r\n     * recently removed components.\r\n     * @param types A list of component types to exclude from the check.\r\n     * @returns Whether the entity has a component of a type not given.\r\n     */\r\n    hasAnyOtherThan(...types) {\r\n        this.__checkValid();\r\n        const typeSet = new Set(types);\r\n        for (const type of this.__registry.types) {\r\n            this.__checkMask(type, 'check');\r\n            if (!(typeSet.has(type) || type.enum && typeSet.has(type.enum)) &&\r\n                this.__registry.hasShape(this.__id, type, true))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Counts the number of components of the given types the entity currently contains. If a system\r\n     * is running in `accessRecentlyDeletedData` mode, this will also consider recently removed\r\n     * components.\r\n     * @param types A list of component types to count.\r\n     * @returns The number of components present from among the given types.\r\n     */\r\n    countHas(...types) {\r\n        this.__checkValid();\r\n        let count = 0;\r\n        for (const type of types)\r\n            if (this.has(type))\r\n                count += 1;\r\n        return count;\r\n    }\r\n    /**\r\n     * Returns the type from the given enumeration currently contained by the entity, if any.  If a\r\n     * system is running in `accessRecentlyDeletedData` mode, this will also consider recently removed\r\n     * components.\r\n     * @param enumeration The enumeration of the desired types.\r\n     * @returns A type from the enumeration if contained by the entity, or `undefined` if none.\r\n     */\r\n    hasWhich(enumeration) {\r\n        this.__checkValid();\r\n        this.__checkMask(enumeration, 'check');\r\n        return this.__registry.getEnumShape(this.__id, enumeration, true);\r\n    }\r\n    /**\r\n     * Obtains a component of the entity that will not allow writing to its fields.  If a component of\r\n     * the given type is not part of this entity this method will fail, unless a system is running in\r\n     * `accessRecentlyDeletedData` mode and the component was only recently removed.\r\n     *\r\n     * The component returned must be used immediately; you must not retain a reference to it beyond\r\n     * the local scope.  Any subsequent request to read the same component type on any entity will\r\n     * invalidate the object.\r\n     * @param type The type of component to obtain.\r\n     * @returns The component of the given type that is part of the entity, ready for reading.\r\n     */\r\n    read(type) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'read');\r\n            this.__checkHas(type, true);\r\n        }\r\n        return type.__bind(this.__id, false);\r\n    }\r\n    /**\r\n     * Obtains a component of the entity that will allow writing to its fields, and mark the component\r\n     * as having been written to (for `changed` queries).  If a component of the given type is not\r\n     * part of this entity this method will fail, unless a system is running in\r\n     * `accessRecentlyDeletedData` mode and the component was only recently removed.\r\n     *\r\n     * The component returned must be used immediately; you must not retain a reference to it beyond\r\n     * the local scope.  Any subsequent request to write the same component type on any entity will\r\n     * invalidate the object.\r\n     * @param type The type of component to obtain.\r\n     * @returns The component of the given type that is part of the entity, ready for reading and\r\n     *  writing.\r\n     */\r\n    write(type) {\r\n        {\r\n            this.__checkValid();\r\n            this.__checkMask(type, 'write');\r\n            this.__checkHas(type, true);\r\n        }\r\n        if (type.__binding.trackedWrites)\r\n            this.__registry.trackWrite(this.__id, type);\r\n        return type.__bind(this.__id, true);\r\n    }\r\n    /**\r\n     * Deletes this entity and removes all its components.\r\n     */\r\n    delete() {\r\n        this.__checkValid();\r\n        const Alive = this.__registry.Alive;\r\n        if (!this.__registry.hasShape(this.__id, Alive, false)) {\r\n            throw new CheckError('Entity already deleted');\r\n        }\r\n        for (const type of this.__registry.types) {\r\n            if (this.__registry.hasShape(this.__id, type, false)) {\r\n                if (type !== Alive)\r\n                    this.__checkMask(type, 'write');\r\n                this.__registry.clearShape(this.__id, type);\r\n            }\r\n        }\r\n        this.__registry.dispatcher.indexer.clearAllRefs(this.__id, false);\r\n    }\r\n    /**\r\n     * Creates a long-lived version of this entity object, that you can safely keep for as long as the\r\n     * entity exists.  Once the entity is deleted (and swept up after the end of the next frame) all\r\n     * further calls on the object will fail.\r\n     * @returns A long-lived version of this entity object.\r\n     */\r\n    hold() {\r\n        this.__checkValid();\r\n        return this.__registry.holdEntity(this.__id);\r\n    }\r\n    /**\r\n     * Returns whether this entity and another one are in fact the same entity.  This can be useful\r\n     * for comparing held entities to transient query ones.\r\n     * @param other The other entity to match against.\r\n     * @returns Whether this entity and the other one are the same.\r\n     */\r\n    isSame(other) {\r\n        this.__checkValid();\r\n        return this.__id === other.__id;\r\n    }\r\n    __checkMask(type, kind) {\r\n        checkMask(type, this.__registry.executingSystem, kind);\r\n    }\r\n    __checkHas(type, allowRecentlyDeleted) {\r\n        if (!this.__registry.hasShape(this.__id, type, allowRecentlyDeleted)) {\r\n            throw new CheckError(`Entity doesn't have a ${type.name} component`);\r\n        }\r\n    }\r\n    __checkValid() {\r\n        if (!this.__valid)\r\n            throw new CheckError('Entity handle no longer valid');\r\n    }\r\n}\r\nfunction checkMask(type, system, kind) {\r\n    checkTypeDefined(type);\r\n    const mask = system?.accessMasks[kind];\r\n    if (!mask)\r\n        return;\r\n    // Inline isMaskFlagSet for performance.\r\n    const binding = type.__binding;\r\n    if (((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) === 0) {\r\n        throw new CheckError(`System ${system.name} didn't mark component ${type.name} as ${kind}able`);\r\n    }\r\n}\r\nfunction isMaskFlagSet(mask, type) {\r\n    const binding = type.__binding;\r\n    return ((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) !== 0;\r\n}\r\nfunction extendMaskAndSetFlag(mask, type, useValues = false) {\r\n    checkTypeDefined(type);\r\n    const flagOffset = type.__binding.shapeOffset;\r\n    if (flagOffset >= mask.length) {\r\n        const oldLength = mask.length;\r\n        mask.length = flagOffset + 1;\r\n        mask.fill(0, oldLength, flagOffset);\r\n    }\r\n    mask[flagOffset] |=\r\n        useValues ? type.__binding.shapeValue : type.__binding.shapeMask;\r\n}\n\nconst HEADER_LENGTH$1 = 2;\r\nconst EMPTY_TUPLE = [];\r\n/**\r\n * A circular log of u32 numbers with smart pointers into it.  When the log wraps around it\r\n * increments a generation counter so you can tell if your pointer got lapped and is now invalid.\r\n */\r\nclass Log {\r\n    maxEntries;\r\n    configParamName;\r\n    options;\r\n    /* layout: [index, generation, ...entries] */\r\n    data;\r\n    /* layout: [length, generation, ...entries] */\r\n    corral;\r\n    /* layout: [length, unused, ...entries] */\r\n    staging;\r\n    typeCounters;\r\n    constructor(maxEntries, configParamName, buffers, options = {\r\n        localProcessingAllowed: false, sortedByComponentType: false, numComponentTypes: 0\r\n    }) {\r\n        this.maxEntries = maxEntries;\r\n        this.configParamName = configParamName;\r\n        this.options = options;\r\n        buffers.register(`log.${configParamName}.buffer`, maxEntries + HEADER_LENGTH$1, Uint32Array, (data) => { this.data = data; });\r\n        buffers.register(`log.${configParamName}.corral`, maxEntries + HEADER_LENGTH$1, Uint32Array, (corral) => { this.corral = corral; });\r\n        if (options.sortedByComponentType) {\r\n            if (options.numComponentTypes === undefined) {\r\n                throw new InternalError(`numComponentTypes required when ${this.configParamName} is sortedByComponentType`);\r\n            }\r\n            buffers.register(`log.${configParamName}.staging`, maxEntries + HEADER_LENGTH$1, Uint32Array, (staging) => { this.staging = staging; });\r\n            this.typeCounters = new Uint32Array(this.options.numComponentTypes);\r\n        }\r\n    }\r\n    push(value, type) {\r\n        const corralLength = this.corral[0];\r\n        if (corralLength >= this.maxEntries)\r\n            this.throwCapacityExceeded();\r\n        if (corralLength && this.corral[corralLength] === value)\r\n            return;\r\n        this.corral[corralLength + HEADER_LENGTH$1] = value;\r\n        this.corral[0] += 1;\r\n        if (!!type !== !!this.options.sortedByComponentType) {\r\n            throw new InternalError(`Pushing value ${type ? 'with' : 'without'} type to log ${this.configParamName} ` +\r\n                `${this.options.sortedByComponentType ? '' : 'not '}sorted by component type`);\r\n        }\r\n        if (type)\r\n            this.typeCounters[type.id] += 1;\r\n    }\r\n    commit(pointer) {\r\n        if (!pointer && this.options.localProcessingAllowed) {\r\n            throw new InternalError(`Cannot use blind commit when local processing is allowed in log ${this.configParamName}`);\r\n        }\r\n        if (!this.corral[0])\r\n            return true;\r\n        if (pointer && !(pointer.generation === this.data[1] && pointer.index === this.data[0] &&\r\n            pointer.corralGeneration === this.corral[1] && pointer.corralIndex === this.corral[0]))\r\n            return false;\r\n        this.copyToData(this.staging ? this.sortCorral() : this.corral);\r\n        this.corral[0] = 0;\r\n        this.corral[1] += 1;\r\n        if (pointer) {\r\n            pointer.index = this.data[0];\r\n            pointer.generation = this.data[1];\r\n        }\r\n        return true;\r\n    }\r\n    sortCorral() {\r\n        let offset = HEADER_LENGTH$1, soleTypeId = -1, soleTypeCount = 0, numNonZeroTypes = 0;\r\n        for (let typeId = 0; typeId < this.typeCounters.length; typeId++) {\r\n            const count = this.typeCounters[typeId];\r\n            if (!count)\r\n                continue;\r\n            numNonZeroTypes += 1;\r\n            if (soleTypeId === -1) {\r\n                soleTypeId = typeId;\r\n                soleTypeCount = count;\r\n            }\r\n            else if (soleTypeId >= 0) {\r\n                soleTypeId = -2;\r\n            }\r\n            if (count === 1) {\r\n                this.typeCounters[typeId] = offset;\r\n                offset += 1;\r\n            }\r\n            else {\r\n                this.typeCounters[typeId] = offset + 1;\r\n                this.staging[offset] = count | (typeId << ENTITY_ID_BITS) | 2 ** 31;\r\n                offset += count + 1;\r\n            }\r\n        }\r\n        if (soleTypeId >= 0) {\r\n            if (soleTypeCount > 1) {\r\n                if (this.corral[0] === this.maxEntries)\r\n                    this.throwCapacityExceeded();\r\n                this.corral[this.corral[0] + HEADER_LENGTH$1] = this.corral[HEADER_LENGTH$1];\r\n                this.corral[HEADER_LENGTH$1] = this.corral[0] | (soleTypeId << ENTITY_ID_BITS) | 2 ** 31;\r\n                this.corral[0] += 1;\r\n            }\r\n            this.typeCounters.fill(0);\r\n            return this.corral;\r\n        }\r\n        if (this.corral[0] + numNonZeroTypes > this.maxEntries)\r\n            this.throwCapacityExceeded();\r\n        const corralAndHeaderLength = this.corral[0] + HEADER_LENGTH$1;\r\n        for (let i = HEADER_LENGTH$1; i < corralAndHeaderLength; i++) {\r\n            const value = this.corral[i];\r\n            const typeId = value >>> ENTITY_ID_BITS;\r\n            this.staging[this.typeCounters[typeId]++] = value;\r\n        }\r\n        this.staging[0] = offset - HEADER_LENGTH$1;\r\n        this.typeCounters.fill(0);\r\n        return this.staging;\r\n    }\r\n    copyToData(source) {\r\n        let index = this.data[0];\r\n        const length = source[0];\r\n        const firstSegmentLength = Math.min(length, this.maxEntries - index);\r\n        this.data.set(source.subarray(HEADER_LENGTH$1, firstSegmentLength + HEADER_LENGTH$1), index + HEADER_LENGTH$1);\r\n        if (firstSegmentLength < length) {\r\n            this.data.set(source.subarray(firstSegmentLength + HEADER_LENGTH$1, length + HEADER_LENGTH$1), HEADER_LENGTH$1);\r\n        }\r\n        index += length;\r\n        while (index >= this.maxEntries) {\r\n            index -= this.maxEntries;\r\n            this.data[1] += 1;\r\n        }\r\n        this.data[0] = index;\r\n    }\r\n    createPointer(pointer) {\r\n        if (!pointer) {\r\n            return {\r\n                index: this.data[0], generation: this.data[1],\r\n                corralIndex: this.corral[0], corralGeneration: this.corral[1]\r\n            };\r\n        }\r\n        pointer.index = this.data[0];\r\n        pointer.generation = this.data[1];\r\n        pointer.corralIndex = this.corral[0];\r\n        pointer.corralGeneration = this.corral[1];\r\n        return pointer;\r\n    }\r\n    copyPointer(pointer) {\r\n        return {\r\n            index: pointer.index, generation: pointer.generation,\r\n            corralIndex: pointer.corralIndex, corralGeneration: pointer.corralGeneration\r\n        };\r\n    }\r\n    hasUpdatesSince(pointer) {\r\n        this.checkPointer(pointer);\r\n        return !(pointer.index === this.data[0] && pointer.generation === this.data[1] &&\r\n            (pointer.corralGeneration === this.corral[1] ?\r\n                pointer.corralIndex === this.corral[0] : this.corral[0] === 0));\r\n    }\r\n    processSince(startPointer, endPointer) {\r\n        this.checkPointers(startPointer, endPointer);\r\n        let result = EMPTY_TUPLE;\r\n        const endIndex = endPointer?.index ?? this.data[0];\r\n        const endGeneration = endPointer?.generation ?? this.data[1];\r\n        if (startPointer.generation === endGeneration) {\r\n            if (startPointer.index < endIndex) {\r\n                result = [\r\n                    this.data, startPointer.index + HEADER_LENGTH$1, endIndex + HEADER_LENGTH$1, false\r\n                ];\r\n                startPointer.index = endIndex;\r\n            }\r\n            else {\r\n                const corralLength = this.corral[0];\r\n                const corralGeneration = this.corral[1];\r\n                const corralHasNewEntries = startPointer.corralGeneration === corralGeneration ?\r\n                    startPointer.corralIndex < corralLength : corralLength;\r\n                if (corralHasNewEntries) {\r\n                    result = [\r\n                        this.corral, startPointer.corralIndex + HEADER_LENGTH$1,\r\n                        corralLength + HEADER_LENGTH$1, true\r\n                    ];\r\n                    startPointer.corralIndex = corralLength;\r\n                    startPointer.corralGeneration = corralGeneration;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            result = [this.data, startPointer.index + HEADER_LENGTH$1, this.data.length, false];\r\n            startPointer.index = 0;\r\n            startPointer.generation = endGeneration;\r\n        }\r\n        return result;\r\n    }\r\n    processAndCommitSince(startPointer) {\r\n        const result = this.processSince(startPointer);\r\n        if (result[0])\r\n            return result;\r\n        if (this.commit(startPointer))\r\n            return EMPTY_TUPLE;\r\n        return this.processSince(startPointer);\r\n    }\r\n    countSince(startPointer, endPointer) {\r\n        this.checkPointers(startPointer, endPointer);\r\n        if (this.corral[0]) {\r\n            throw new InternalError(`Should commit log ${this.configParamName} before counting`);\r\n        }\r\n        const startIndex = startPointer.index;\r\n        const startGeneration = startPointer.generation;\r\n        const endIndex = endPointer?.index ?? this.data[0];\r\n        const endGeneration = endPointer?.generation ?? this.data[1];\r\n        startPointer.index = endIndex;\r\n        startPointer.generation = endGeneration;\r\n        if (startIndex === endIndex && startGeneration === endGeneration)\r\n            return 0;\r\n        if (startIndex < endIndex)\r\n            return endIndex - startIndex;\r\n        return this.maxEntries - (startIndex - endIndex);\r\n    }\r\n    checkPointers(startPointer, endPointer) {\r\n        this.checkPointer(startPointer);\r\n        if (endPointer) {\r\n            this.checkPointer(endPointer);\r\n            {\r\n                if (startPointer.index > endPointer.index &&\r\n                    startPointer.generation >= endPointer.generation) {\r\n                    throw new InternalError(`Start pointer exceeds end pointer in log ${this.configParamName}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    checkPointer(pointer) {\r\n        const index = this.data[0];\r\n        let generation = pointer.generation;\r\n        if (pointer.index === index) {\r\n            if (generation + 1 < this.data[1])\r\n                this.throwCapacityExceeded();\r\n        }\r\n        else {\r\n            if (pointer.index > index)\r\n                generation += 1;\r\n            if (generation !== this.data[1])\r\n                this.throwCapacityExceeded();\r\n        }\r\n        {\r\n            if (pointer.corralGeneration > this.corral[1]) {\r\n                throw new InternalError(`Pointer corral generation older than corral in log ${this.configParamName}`);\r\n            }\r\n            if (pointer.corralGeneration === this.corral[1] && pointer.corralIndex > this.corral[0]) {\r\n                throw new InternalError(`Pointer past end of corral area in log ${this.configParamName}`);\r\n            }\r\n        }\r\n    }\r\n    throwCapacityExceeded() {\r\n        throw new CheckError(`Log capacity exceeded, please raise ${this.configParamName} above ${this.maxEntries}`);\r\n    }\r\n}\n\n/**\r\n * A fixed but arbitrary size bitset.\r\n */\r\nclass Bitset {\r\n    size;\r\n    bytes;\r\n    constructor(size) {\r\n        this.size = size;\r\n        this.bytes = new Uint32Array(Math.ceil(size / 32));\r\n    }\r\n    get(index) {\r\n        {\r\n            if (index < 0 || index >= this.size) {\r\n                throw new InternalError(`Bit index out of bounds: ${index}`);\r\n            }\r\n        }\r\n        return (this.bytes[index >>> 5] & (1 << (index & 31))) !== 0;\r\n    }\r\n    set(index) {\r\n        {\r\n            if (index < 0 || index >= this.size) {\r\n                throw new InternalError(`Bit index out of bounds: ${index}`);\r\n            }\r\n        }\r\n        this.bytes[index >>> 5] |= (1 << (index & 31));\r\n    }\r\n    unset(index) {\r\n        {\r\n            if (index < 0 || index >= this.size) {\r\n                throw new InternalError(`Bit index out of bounds: ${index}`);\r\n            }\r\n        }\r\n        this.bytes[index >>> 5] &= ~(1 << (index & 31));\r\n    }\r\n    clear() {\r\n        this.bytes.fill(0);\r\n    }\r\n}\n\nclass ArrayEntityList {\r\n    pool;\r\n    orderBy;\r\n    entities = [];\r\n    maxOrderKey = -Infinity;\r\n    sorted = true;\r\n    constructor(pool, orderBy) {\r\n        this.pool = pool;\r\n        this.orderBy = orderBy;\r\n    }\r\n    add(id) {\r\n        const entity = this.pool.borrowTemporarily(id);\r\n        if (this.orderBy) {\r\n            const orderKey = this.orderBy(entity);\r\n            if (orderKey >= this.maxOrderKey) {\r\n                this.maxOrderKey = orderKey;\r\n            }\r\n            else {\r\n                this.sorted = false;\r\n            }\r\n        }\r\n        this.entities.push(entity);\r\n    }\r\n    clear() {\r\n        if (this.entities.length)\r\n            this.entities.length = 0;\r\n        this.maxOrderKey = -Infinity;\r\n        this.sorted = true;\r\n    }\r\n    sort() {\r\n        if (this.sorted)\r\n            return;\r\n        const orderBy = this.orderBy;\r\n        for (const entity of this.entities)\r\n            entity.__sortKey = orderBy(entity);\r\n        this.entities.sort((a, b) => {\r\n            return a.__sortKey < b.__sortKey ? -1 : a.__sortKey > b.__sortKey ? +1 : 0;\r\n        });\r\n        this.sorted = true;\r\n    }\r\n}\r\nclass PackedArrayEntityList {\r\n    pool;\r\n    orderBy;\r\n    entities = [];\r\n    lookupTable;\r\n    maxOrderKey = -Infinity;\r\n    sorted = true;\r\n    constructor(pool, orderBy, maxEntities) {\r\n        this.pool = pool;\r\n        this.orderBy = orderBy;\r\n        this.lookupTable = new Int32Array(maxEntities);\r\n        this.lookupTable.fill(-1);\r\n    }\r\n    add(id) {\r\n        const entity = this.pool.borrow(id);\r\n        if (this.orderBy) {\r\n            const orderKey = this.orderBy(entity);\r\n            if (orderKey >= this.maxOrderKey) {\r\n                this.maxOrderKey = orderKey;\r\n            }\r\n            else {\r\n                this.sorted = false;\r\n            }\r\n        }\r\n        const index = this.entities.push(entity) - 1;\r\n        this.lookupTable[id] = index;\r\n    }\r\n    remove(id) {\r\n        const index = this.lookupTable[id];\r\n        if (index < 0)\r\n            throw new InternalError('Entity not in list');\r\n        this.pool.return(id);\r\n        this.lookupTable[id] = -1;\r\n        const entity = this.entities.pop();\r\n        if (index < this.entities.length) {\r\n            this.entities[index] = entity;\r\n            this.lookupTable[entity.__id] = index;\r\n            if (this.orderBy)\r\n                this.sorted = false;\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.lookupTable[id] >= 0;\r\n    }\r\n    clear() {\r\n        for (const entity of this.entities)\r\n            this.pool.return(entity.__id);\r\n        this.entities = [];\r\n        this.lookupTable.fill(-1);\r\n        this.maxOrderKey = -Infinity;\r\n        this.sorted = true;\r\n    }\r\n    sort() {\r\n        if (this.sorted)\r\n            return;\r\n        const orderBy = this.orderBy;\r\n        for (const entity of this.entities)\r\n            entity.__sortKey = orderBy(entity);\r\n        this.entities.sort((a, b) => {\r\n            return a.__sortKey < b.__sortKey ? -1 : a.__sortKey > b.__sortKey ? +1 : 0;\r\n        });\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            this.lookupTable[this.entities[i].__id] = i;\r\n        }\r\n        this.sorted = true;\r\n    }\r\n}\n\nvar QueryFlavor;\r\n(function (QueryFlavor) {\r\n    QueryFlavor[QueryFlavor[\"current\"] = 1] = \"current\";\r\n    QueryFlavor[QueryFlavor[\"added\"] = 2] = \"added\";\r\n    QueryFlavor[QueryFlavor[\"removed\"] = 4] = \"removed\";\r\n    QueryFlavor[QueryFlavor[\"changed\"] = 8] = \"changed\";\r\n    QueryFlavor[QueryFlavor[\"addedOrChanged\"] = 16] = \"addedOrChanged\";\r\n    QueryFlavor[QueryFlavor[\"changedOrRemoved\"] = 32] = \"changedOrRemoved\";\r\n    QueryFlavor[QueryFlavor[\"addedChangedOrRemoved\"] = 64] = \"addedChangedOrRemoved\";\r\n})(QueryFlavor || (QueryFlavor = {}));\r\nconst transientFlavorsMask = QueryFlavor.added | QueryFlavor.removed | QueryFlavor.changed | QueryFlavor.addedOrChanged |\r\n    QueryFlavor.changedOrRemoved | QueryFlavor.addedChangedOrRemoved;\r\nconst changedFlavorsMask = QueryFlavor.changed | QueryFlavor.addedOrChanged | QueryFlavor.changedOrRemoved |\r\n    QueryFlavor.addedChangedOrRemoved;\r\nconst shapeFlavorsMask = QueryFlavor.added | QueryFlavor.removed | QueryFlavor.addedOrChanged |\r\n    QueryFlavor.changedOrRemoved | QueryFlavor.addedChangedOrRemoved;\r\nclass QueryBox {\r\n    system;\r\n    results = {};\r\n    flavors = 0;\r\n    withMask;\r\n    withValues;\r\n    withAnyRecords;\r\n    withoutMask;\r\n    withoutEnumTypes;\r\n    trackWritesMask;\r\n    orderBy;\r\n    hasTransientResults;\r\n    hasChangedResults;\r\n    hasShapeResults;\r\n    hasMatchTracking;\r\n    currentEntities;\r\n    processedEntities;\r\n    changedEntities;\r\n    constructor(query, system) {\r\n        this.system = system;\r\n        query.__results = this.results;\r\n        query.__systemName = system.name;\r\n    }\r\n    complete() {\r\n        const dispatcher = this.system.dispatcher;\r\n        this.hasTransientResults = Boolean(this.flavors & transientFlavorsMask);\r\n        this.hasChangedResults = Boolean(this.flavors & changedFlavorsMask);\r\n        this.hasShapeResults = Boolean(this.flavors & shapeFlavorsMask);\r\n        this.hasMatchTracking = Boolean(this.withAnyRecords?.some(record => record.lastMatches));\r\n        {\r\n            if (this.withMask && this.withoutMask) {\r\n                const minLength = Math.min(this.withMask.length, this.withoutMask.length);\r\n                for (let i = 0; i < minLength; i++) {\r\n                    if ((this.withMask[i] & this.withoutMask[i]) !== 0) {\r\n                        throw new CheckError('Query must not list a component type in both `with` and `without` clauses');\r\n                    }\r\n                }\r\n            }\r\n            if (this.withAnyRecords && this.withoutMask) {\r\n                for (const { mask } of this.withAnyRecords) {\r\n                    const minLength = Math.min(mask.length, this.withoutMask.length);\r\n                    for (let i = 0; i < minLength; i++) {\r\n                        if ((mask[i] & this.withoutMask[i]) !== 0) {\r\n                            throw new CheckError('Query must not list a component type in both `withAny` and `without` clauses');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const hasTrackers = !!this.trackWritesMask || this.withAnyRecords?.some(item => item.lastMatches);\r\n            if (this.hasChangedResults && !hasTrackers) {\r\n                throw new CheckError(`Query for changed entities must track at least one component`);\r\n            }\r\n            if (!this.hasChangedResults && hasTrackers) {\r\n                throw new CheckError('You can only track components if you have a query for changed entities');\r\n            }\r\n        }\r\n        if (this.flavors & QueryFlavor.current) {\r\n            this.results.current =\r\n                new PackedArrayEntityList(dispatcher.registry.pool, this.orderBy, dispatcher.maxEntities);\r\n        }\r\n        else {\r\n            this.currentEntities = new Bitset(dispatcher.maxEntities);\r\n        }\r\n        this.processedEntities = new Bitset(dispatcher.maxEntities);\r\n        if (this.hasTransientResults)\r\n            this.allocateTransientResultLists();\r\n        if (this.flavors)\r\n            this.system.shapeQueries.push(this);\r\n        if (this.hasChangedResults) {\r\n            this.changedEntities = new Bitset(dispatcher.maxEntities);\r\n            this.system.writeQueries.push(this);\r\n        }\r\n    }\r\n    allocateTransientResultLists() {\r\n        if (this.flavors & QueryFlavor.added)\r\n            this.allocateResult('added');\r\n        if (this.flavors & QueryFlavor.removed)\r\n            this.allocateResult('removed');\r\n        if (this.flavors & QueryFlavor.changed)\r\n            this.allocateResult('changed');\r\n        if (this.flavors & QueryFlavor.addedOrChanged)\r\n            this.allocateResult('addedOrChanged');\r\n        if (this.flavors & QueryFlavor.changedOrRemoved)\r\n            this.allocateResult('changedOrRemoved');\r\n        if (this.flavors & QueryFlavor.addedChangedOrRemoved) {\r\n            this.allocateResult('addedChangedOrRemoved');\r\n        }\r\n    }\r\n    allocateResult(name) {\r\n        const dispatcher = this.system.dispatcher;\r\n        this.results[name] = new ArrayEntityList(dispatcher.registry.pool, this.orderBy);\r\n    }\r\n    clearTransientResults() {\r\n        if (!this.hasTransientResults)\r\n            return;\r\n        this.results.added?.clear();\r\n        this.results.removed?.clear();\r\n        this.results.changed?.clear();\r\n        this.results.addedOrChanged?.clear();\r\n        this.results.changedOrRemoved?.clear();\r\n        this.results.addedChangedOrRemoved?.clear();\r\n        this.changedEntities?.clear();\r\n    }\r\n    clearAllResults() {\r\n        this.clearTransientResults();\r\n        this.results.current?.clear();\r\n    }\r\n    clearProcessedEntities() {\r\n        this.processedEntities.clear();\r\n    }\r\n    handleShapeUpdate(id) {\r\n        if (this.processedEntities.get(id))\r\n            return;\r\n        this.processedEntities.set(id);\r\n        const registry = this.system.dispatcher.registry;\r\n        const oldMatch = this.results.current?.has(id) ?? this.currentEntities.get(id);\r\n        const newMatch = registry.matchShape(id, this.withMask, this.withValues, this.withAnyRecords, this.withoutMask, this.withoutEnumTypes);\r\n        if (newMatch && !oldMatch) {\r\n            this.currentEntities?.set(id);\r\n            this.changedEntities?.set(id);\r\n            this.results.current?.add(id);\r\n            this.results.added?.add(id);\r\n            this.results.addedOrChanged?.add(id);\r\n            this.results.addedChangedOrRemoved?.add(id);\r\n        }\r\n        else if (!newMatch && oldMatch) {\r\n            this.currentEntities?.unset(id);\r\n            this.changedEntities?.set(id);\r\n            this.results.current?.remove(id);\r\n            this.results.removed?.add(id);\r\n            this.results.changedOrRemoved?.add(id);\r\n            this.results.addedChangedOrRemoved?.add(id);\r\n        }\r\n        else if (newMatch && oldMatch && this.hasMatchTracking) {\r\n            for (const record of this.withAnyRecords) {\r\n                if (record.changed) {\r\n                    this.changedEntities.set(id);\r\n                    this.results.changed?.add(id);\r\n                    this.results.addedOrChanged?.add(id);\r\n                    this.results.changedOrRemoved?.add(id);\r\n                    this.results.addedChangedOrRemoved?.add(id);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    handleWrite(id, componentFlagOffset, componentFlagMask) {\r\n        if (!this.changedEntities.get(id) &&\r\n            (this.hasShapeResults ?\r\n                (this.results.current?.has(id) ?? this.currentEntities.get(id)) :\r\n                this.system.dispatcher.registry.matchShape(id, this.withMask, this.withValues, this.withAnyRecords, this.withoutMask, this.withoutEnumTypes)) &&\r\n            (this.trackWritesMask[componentFlagOffset] ?? 0) & componentFlagMask) {\r\n            this.changedEntities.set(id);\r\n            this.results.changed?.add(id);\r\n            this.results.addedOrChanged?.add(id);\r\n            this.results.changedOrRemoved?.add(id);\r\n            this.results.addedChangedOrRemoved?.add(id);\r\n        }\r\n    }\r\n    sort() {\r\n        this.results.current?.sort();\r\n        this.results.added?.sort();\r\n        this.results.removed?.sort();\r\n        this.results.changed?.sort();\r\n        this.results.addedOrChanged?.sort();\r\n        this.results.changedOrRemoved?.sort();\r\n        this.results.addedChangedOrRemoved?.sort();\r\n    }\r\n}\r\n/**\r\n * A fluent DSL for specifying a family of queries over the world's entities.\r\n *\r\n * Each query has a number of aspects:\r\n * 1. What components an entity must (`with`) and must not (`without`) have to be selected.\r\n * 2. Whether to return all `current` entities that satisfy the query, only various deltas from the\r\n *    last frame (`added`, `removed`, `changed`, etc.).  It's permitted and encouraged to declare\r\n *    multiple such variants on a single query if needed.  For the delta queries, each entity will\r\n *    be compared against the query's value in the previous frame, so an entity that changes state\r\n *    and changes back again between system executions will not be selected.\r\n * 3. Which component types the query will read and write.  This doesn't affect the results of the\r\n *    query but is used to order and deconflict systems.\r\n */\r\nclass QueryBuilder {\r\n    __callback;\r\n    __userQuery;\r\n    __query;\r\n    __system;\r\n    __lastTypes;\r\n    __lastWasWithAny;\r\n    constructor(__callback, __userQuery) {\r\n        this.__callback = __callback;\r\n        this.__userQuery = __userQuery;\r\n    }\r\n    __build(system) {\r\n        try {\r\n            this.__system = system;\r\n            this.__query = new QueryBox(this.__userQuery, system);\r\n            this.__callback(this);\r\n            if (!this.__query.withMask && this.__query.flavors) {\r\n                this.set('withMask', [this.__system.dispatcher.registry.Alive]);\r\n            }\r\n            this.__query.complete();\r\n        }\r\n        catch (e) {\r\n            e.message = `Failed to build query in system ${system.name}: ${e.message}`;\r\n            throw e;\r\n        }\r\n    }\r\n    // TODO: support partitioned queries in stateless systems\r\n    /**\r\n     * A noop connector to make a query definition read better.\r\n     */\r\n    get and() {\r\n        return this;\r\n    }\r\n    /**\r\n     * A noop connector to make a query definition read better.\r\n     */\r\n    get but() {\r\n        return this;\r\n    }\r\n    /**\r\n     * A noop connector to make a query definition read better.\r\n     */\r\n    get also() {\r\n        return this;\r\n    }\r\n    /**\r\n     * Requests the maintenance of a list of all entities that currently satisfy the query.  This is\r\n     * the most common use of queries.\r\n     */\r\n    get current() {\r\n        this.__query.flavors |= QueryFlavor.current;\r\n        return this;\r\n    }\r\n    /**\r\n     * Requests that a list of all entities that newly satisfy the query be made available each frame.\r\n     */\r\n    get added() {\r\n        this.__query.flavors |= QueryFlavor.added;\r\n        return this;\r\n    }\r\n    /**\r\n     * Requests that a list of all entities that no longer satisfy the query be made available each\r\n     * frame.\r\n     */\r\n    get removed() {\r\n        this.__query.flavors |= QueryFlavor.removed;\r\n        return this;\r\n    }\r\n    /**\r\n     * Requests that a list of all entities that were recently written to and satisfy the query be\r\n     * made available each frame.  You must additionally specify which components the write detection\r\n     * should be sensitive to using `trackWrites`.\r\n     */\r\n    get changed() {\r\n        this.__query.flavors |= QueryFlavor.changed;\r\n        return this;\r\n    }\r\n    /**\r\n     * A combination of the `added` and `changed` query types, with the advantage that an entity that\r\n     * satisfies both will only appear once.\r\n     */\r\n    get addedOrChanged() {\r\n        this.__query.flavors |= QueryFlavor.addedOrChanged;\r\n        return this;\r\n    }\r\n    /**\r\n     * A combination of the `changed` and `removed` query types, with the advantage that an entity\r\n     * that satisfies both will only appear once.\r\n     */\r\n    get changedOrRemoved() {\r\n        this.__query.flavors |= QueryFlavor.changedOrRemoved;\r\n        return this;\r\n    }\r\n    /**\r\n     * A combination of the `added`, `changed`, and `removed` query types, with the advantage that an\r\n     * entity that satisfies multiple ones will only appear once.\r\n     */\r\n    get addedChangedOrRemoved() {\r\n        this.__query.flavors |= QueryFlavor.addedChangedOrRemoved;\r\n        return this;\r\n    }\r\n    /**\r\n     * Order query results in ascending order of the given function's output for each entity.\r\n     * @example\r\n     *   q.added.orderBy(entity => entity.ordinal)\r\n     * @param transformer A function that transforms an entity to a number for sorting.\r\n     */\r\n    orderBy(transformer) {\r\n        this.__query.orderBy = transformer;\r\n        return this;\r\n    }\r\n    /**\r\n     * Constrains the query to entities that possess components of all the given types.  All given\r\n     * types are also marked as `read`.\r\n     *\r\n     * All `with` clauses are combined into a single `O(1)` check.\r\n     *\r\n     * You cannot pass in enums since by definition it's impossible for an entity to possess more than\r\n     * one component from an enum.  See {@link QueryBuilder.withAny} instead.\r\n     * @param types The types of components required to match the query.\r\n     */\r\n    with(...types) {\r\n        this.set(this.__system.accessMasks.read, types);\r\n        this.set('withMask');\r\n        return this;\r\n    }\r\n    /**\r\n     * Constrains the query to entities that possess a component of at least one of the given types.\r\n     * All given types are also marked as `read`.\r\n     *\r\n     * Unlike `with`, `withAny` clauses are not combined; each is evaluated as a separate check, which\r\n     * may affect performance.\r\n     *\r\n     * You cannot pass in enum component types, only whole enums.\r\n     * @param types\r\n     */\r\n    withAny(...types) {\r\n        for (const type of types) {\r\n            if (typeof type === 'function' && type.enum) {\r\n                throw new CheckError(`Cannot use enum types in a withAny clause: ${type.name}`);\r\n            }\r\n        }\r\n        this.set(this.__system.accessMasks.read, types);\r\n        if (!this.__query.withAnyRecords)\r\n            this.__query.withAnyRecords = [];\r\n        const mask = [];\r\n        this.__query.withAnyRecords.push({ mask, lastMatches: undefined, changed: false });\r\n        this.set(mask);\r\n        return this;\r\n    }\r\n    /**\r\n     * Constrains the query to entities that don't possess components of any of the given types.  All\r\n     * given types are also marked as `read`.\r\n     *\r\n     * While you can pass in enum component types, evaluating such queries is inefficient (`O(n)` in\r\n     * the number of enum types passed).  Passing in whole enums is fine, though (the query stays\r\n     * `O(1)`).\r\n     * @param types The types of components that must not be present to match the query.\r\n     */\r\n    without(...types) {\r\n        this.set(this.__system.accessMasks.read, types);\r\n        this.set('withoutMask');\r\n        return this;\r\n    }\r\n    /**\r\n     * Mentions some component types for follow-up modifiers.\r\n     * @param types The types of components for follow-up modifiers, but that don't constrain the\r\n     * query.\r\n     */\r\n    using(...types) {\r\n        this.__lastTypes = types;\r\n        return this;\r\n    }\r\n    /**\r\n     * Makes all component types in the world available for follow-up modifiers.  This can be modified\r\n     * with a `.write` as usual, and may be useful in \"sweeper\" systems that want to be able to, e.g.,\r\n     * delete any entity without having to worry what it might hold refs to or what components might\r\n     * have backrefs pointing to it.\r\n     */\r\n    get usingAll() {\r\n        // All types except Alive, which is always at index 0.\r\n        this.__lastTypes = this.__system.dispatcher.registry.types.slice(1);\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks writes to the most recently mentioned component types as trackable for `changed` query\r\n     * flavors.  An entity will be considered changed if any system called `write` on one of those\r\n     * components since the last frame.\r\n     */\r\n    get trackWrites() {\r\n        this.set('trackWritesMask');\r\n        for (const type of this.__lastTypes) {\r\n            if (typeof type === 'function') {\r\n                type.__binding.trackedWrites = true;\r\n            }\r\n            else {\r\n                for (const enumType of type.__types)\r\n                    enumType.__binding.trackedWrites = true;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks changes in the matching set of the immediately preceding `withAny` component types as\r\n     * trackable for `changed` query flavors.  An entity will be considered changed if it matched the\r\n     * query in the last frame and still matches it in the current frame, but satisfied the `withAny`\r\n     * constraint with a different set of components.\r\n     *\r\n     * This tracking is particularly useful for detecting changing enum states, but can be applied to\r\n     * any set of components.\r\n     */\r\n    get trackMatches() {\r\n        if (!this.__lastWasWithAny) {\r\n            throw new Error('You can only apply trackMatches to a withAny clause');\r\n        }\r\n        this.__query.withAnyRecords[this.__query.withAnyRecords.length - 1].lastMatches = [];\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks the most recently mentioned component types as read by the system.  This declaration\r\n     * is enforced: you will only be able to read components of types thus declared.\r\n     */\r\n    get read() {\r\n        this.set(this.__system.accessMasks.read);\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks the most recently mentioned component types as created (and only created!) by the system.\r\n     * This means that the component types will only be used in `createEntity` calls; they cannot be\r\n     * otherwise read, checked for (`has` methods), or written.  It can run concurrently with other\r\n     * `create` entitlements but counts as a `write` for purposes of system ordering.\r\n     */\r\n    get create() {\r\n        this.set(this.__system.accessMasks.create);\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks the most recently mentioned component types as indirectly updated by the system.  This\r\n     * covers automatic change propagation to non-writable fields such as updates of `backrefs`\r\n     * properties; however, it doesn't cover automatic clearing of refs to a deleted entity.  It can\r\n     * run concurrently with other `read` and `update` entitlements but counts as a `write` for\r\n     * purposes of system ordering.\r\n     */\r\n    get update() {\r\n        this.set(this.__system.accessMasks.update);\r\n        return this;\r\n    }\r\n    /**\r\n     * Marks the most recently mentioned component types as read, written, created and/or updated by\r\n     * the system.  This declaration is enforced: you will only be able to read and write to component\r\n     * of types thus declared. You should try to declare the minimum writable set that your system\r\n     * will need to improve ordering and concurrency.\r\n     */\r\n    get write() {\r\n        this.set(this.__system.accessMasks.write);\r\n        this.set(this.__system.accessMasks.read);\r\n        this.set(this.__system.accessMasks.create);\r\n        this.set(this.__system.accessMasks.update);\r\n        return this;\r\n    }\r\n    set(mask, types) {\r\n        if (!mask)\r\n            return;\r\n        if (types) {\r\n            for (const type of types)\r\n                checkTypeDefined(type);\r\n        }\r\n        if (!types)\r\n            types = this.__lastTypes;\r\n        if (!types)\r\n            throw new InternalError('No component type to apply query modifier to');\r\n        this.__lastTypes = types;\r\n        if (typeof mask === 'string') {\r\n            if (!this.__query[mask])\r\n                this.__query[mask] = [];\r\n            mask = this.__query[mask];\r\n        }\r\n        this.__lastWasWithAny = this.__query.withAnyRecords?.some(item => item.mask === mask) ?? false;\r\n        const readMask = mask === this.__system.accessMasks.read;\r\n        const updateMask = mask === this.__system.accessMasks.update;\r\n        const createMask = mask === this.__system.accessMasks.create;\r\n        const writeMask = mask === this.__system.accessMasks.write;\r\n        const withMask = mask === this.__query.withMask;\r\n        const withoutMask = mask === this.__query.withoutMask;\r\n        const shapeMask = mask === this.__query.withMask || mask === this.__query.withoutMask || this.__lastWasWithAny;\r\n        const trackMask = mask === this.__query.trackWritesMask;\r\n        const map = readMask ? this.__system.dispatcher.planner.readers :\r\n            writeMask || createMask || updateMask ? this.__system.dispatcher.planner.writers :\r\n                undefined;\r\n        for (const type of types) {\r\n            {\r\n                if (!isMaskFlagSet(this.__system.accessMasks.write, type) && (readMask && isMaskFlagSet(this.__system.accessMasks.create, type) ||\r\n                    createMask && isMaskFlagSet(this.__system.accessMasks.read, type))) {\r\n                    throw new CheckError(`Cannot combine create and read entitlements for component type ${type.name}; ` +\r\n                        `just use a write entitlement instead`);\r\n                }\r\n            }\r\n            if (withoutMask && typeof type === 'function' && type.enum) {\r\n                this.__query.withoutEnumTypes = this.__query.withoutEnumTypes ?? [];\r\n                this.__query.withoutEnumTypes.push(type);\r\n            }\r\n            else {\r\n                extendMaskAndSetFlag(mask, type);\r\n                if (withMask) {\r\n                    if (!this.__query.withValues)\r\n                        this.__query.withValues = [];\r\n                    extendMaskAndSetFlag(this.__query.withValues, type, true);\r\n                }\r\n            }\r\n            if (readMask)\r\n                extendMaskAndSetFlag(this.__system.accessMasks.check, type);\r\n            if (typeof type === 'function') {\r\n                if (map)\r\n                    map.get(type).add(this.__system);\r\n                if (shapeMask)\r\n                    this.categorize(this.__system.shapeQueriesByComponent, type);\r\n                if (trackMask)\r\n                    this.categorize(this.__system.writeQueriesByComponent, type);\r\n            }\r\n            else {\r\n                for (const enumType of type.__types) {\r\n                    if (map)\r\n                        map.get(enumType).add(this.__system);\r\n                    if (shapeMask)\r\n                        this.categorize(this.__system.shapeQueriesByComponent, enumType);\r\n                    if (trackMask)\r\n                        this.categorize(this.__system.writeQueriesByComponent, enumType);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    categorize(index, type) {\r\n        const id = type.id;\r\n        if (!index[id])\r\n            index[id] = [];\r\n        if (!index[id].includes(this.__query))\r\n            index[id].push(this.__query);\r\n    }\r\n}\r\nclass Query {\r\n    __results;\r\n    __systemName;\r\n    // TODO: add an API for freezing/thawing a query\r\n    /**\r\n     * A list of all entities that match this query as of the beginning of the system's current (or\r\n     * last) execution.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get current() {\r\n        this.__checkList('current');\r\n        return this.__results.current.entities;\r\n    }\r\n    /**\r\n     * A list of all entities that newly started matching this query between the system's current (or\r\n     * last) and previous executions.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get added() {\r\n        this.__checkList('added');\r\n        return this.__results.added.entities;\r\n    }\r\n    /**\r\n     * A list of all entities that newly stopped matching this query between the system's current (or\r\n     * last) and previous executions.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get removed() {\r\n        this.__checkList('removed');\r\n        return this.__results.removed.entities;\r\n    }\r\n    /**\r\n     * A list of all entities that match this query as of the beginning of of the system's current (or\r\n     * last) execution, and that had tracked components written to between the system's current (or\r\n     * last) and previous executions.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get changed() {\r\n        this.__checkList('changed');\r\n        return this.__results.changed.entities;\r\n    }\r\n    /**\r\n     * A list that combines `added` and `changed`, but without duplicate entities.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get addedOrChanged() {\r\n        this.__checkList('addedOrChanged');\r\n        return this.__results.addedOrChanged.entities;\r\n    }\r\n    /**\r\n     * A list that combines `changed` and `removed`, but without duplicate entities.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get changedOrRemoved() {\r\n        this.__checkList('changedOrRemoved');\r\n        return this.__results.changedOrRemoved.entities;\r\n    }\r\n    /**\r\n     * A list that combines `added`, `changed`, and `removed`, but without duplicate entities.\r\n     *\r\n     * You must not keep a reference to these entities beyond the local scope of a system's execution.\r\n     * To obtain an object for long-term use please see {@link Entity.hold}.\r\n     */\r\n    get addedChangedOrRemoved() {\r\n        this.__checkList('addedChangedOrRemoved');\r\n        return this.__results.addedChangedOrRemoved.entities;\r\n    }\r\n    __checkList(flavor) {\r\n        const list = this.__results[flavor];\r\n        if (!list) {\r\n            throw new CheckError(`Query '${flavor}' not configured, please add .${flavor} to your query definition in ` +\r\n                `system ${this.__systemName}`);\r\n        }\r\n    }\r\n}\n\nconst now = typeof window !== 'undefined' && typeof window.performance !== 'undefined' ?\r\n    performance.now.bind(performance) : Date.now.bind(Date);\r\n// TODO: support replicated systems\r\n// TODO: support continuously executed systems\r\n/**\r\n * A fluent DSL for specifying a system's scheduling constraints.\r\n *\r\n * Any given pair of systems will be ordered by the first of the following rules that matches:\r\n * 1. A system was explicitly placed `before` or `after` another.\r\n * 2. A system was explicitly left unordered with respect to another using `inAnyOrderWith`.\r\n * 3. A system was implicitly placed before or after another system based on the components the\r\n *    other system reads or writes, using `beforeReadersOf`, `afterReadersOf`, `beforeWritersOf` or\r\n *    `afterWritersOf`.\r\n * 4. A system was explicitly left unordered with respect to another using `inAnyOrderWithReadersOf`\r\n *    or `inAnyOrderWithWritersOf`.\r\n * 5. A system was implicitly placed after another because it reads a component that the other\r\n *    system writes.\r\n *\r\n * If there are multiple constraints at the same priority level they will conflict and create a\r\n * cycle.  If there are any cycles in the order graph (whether due to explicit conflicts or implicit\r\n * circular dependencies), world creation will fail with an informative error and you'll need to\r\n * break the cycles by adding scheduling constraints to the systems involved.\r\n */\r\nclass ScheduleBuilder {\r\n    __callback;\r\n    __schedule;\r\n    __systems;\r\n    __dispatcher;\r\n    constructor(__callback, __schedule) {\r\n        this.__callback = __callback;\r\n        this.__schedule = __schedule;\r\n    }\r\n    __build(systems, name) {\r\n        try {\r\n            this.__systems = systems;\r\n            this.__dispatcher = systems[0].dispatcher;\r\n            this.__callback(this);\r\n        }\r\n        catch (e) {\r\n            e.message = `Failed to build schedule in ${name}: ${e.message}`;\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a group that includes all the world's systems.\r\n     */\r\n    get allSystems() {\r\n        return this.__dispatcher.defaultGroup;\r\n    }\r\n    /**\r\n     * Forces this system to only execute on the main thread.  This is needed for systems that\r\n     * interact with APIs only available in the main thread such as the DOM.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    get onMainThread() {\r\n        this.__checkNoLaneAssigned();\r\n        this.__dispatcher.planner.mainLane?.add(...this.__systems);\r\n        return this;\r\n    }\r\n    /**\r\n     * Executes this system consistently on a single thread.  This is the default behavior to\r\n     * accommodate systems with internal state.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    get onOneThread() {\r\n        this.__checkNoLaneAssigned();\r\n        this.__dispatcher.planner.createLane().add(...this.__systems);\r\n        return this;\r\n    }\r\n    /**\r\n     * Replicates this system among multiple threads and execute it on any one of them, possibly a\r\n     * different one each time.  This allows Becsy to better utilize available CPUs but requires the\r\n     * system to be stateless (except for queries and attached systems).  Note that `prepare` and\r\n     * `initialize` will be called on each replicated instance of the system!\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    get onManyThreads() {\r\n        this.__checkNoLaneAssigned();\r\n        this.__dispatcher.planner.replicatedLane?.add(...this.__systems);\r\n        for (const system of this.__systems)\r\n            system.stateless = true;\r\n        return this;\r\n    }\r\n    __checkNoLaneAssigned() {\r\n        if (this.__systems.some(system => system.lane)) {\r\n            throw new CheckError(`Threading semantics already specified`);\r\n        }\r\n    }\r\n    /**\r\n     * Schedules this system before all the given ones (highest priority).  Any systems present in\r\n     * both the receiver and the target are skipped.\r\n     * @param systemTypes The systems or groups that this one should precede.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    before(...systemTypes) {\r\n        const thisSet = new Set(this.__systems);\r\n        for (const type of systemTypes) {\r\n            for (const other of this.__dispatcher.getSystems(type)) {\r\n                if (thisSet.has(other))\r\n                    continue;\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(system, other, 5);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system after all the given ones (highest priority).  Any systems present in\r\n     * both the receiver and the target are skipped.\r\n     * @param systemTypes The systems or groups that this one should follow.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    after(...systemTypes) {\r\n        const thisSet = new Set(this.__systems);\r\n        for (const type of systemTypes) {\r\n            for (const other of this.__dispatcher.getSystems(type)) {\r\n                if (thisSet.has(other))\r\n                    continue;\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(other, system, 5);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system in any order relative to the given ones (high priority).\r\n     * @param systemTypes The systems or groups whose order doesn't matter relative to this one.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    inAnyOrderWith(...systemTypes) {\r\n        for (const type of systemTypes) {\r\n            for (const other of this.__dispatcher.getSystems(type)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.denyEdge(system, other, 4);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system before all other systems that declared a read dependency on the given\r\n     * component types (medium priority).\r\n     * @param componentTypes The component types whose readers this system should precede.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    beforeReadersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.readers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(system, other, 3);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system after all other systems that declared a read dependency on the given\r\n     * component types (medium priority).\r\n     * @param componentTypes The component types whose readers this system should follow.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    afterReadersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.readers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(other, system, 3);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system before all other systems that declared a write dependency on the given\r\n     * component types (medium priority).\r\n     * @param componentTypes The component types whose writers this system should precede.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    beforeWritersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.writers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(system, other, 3);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system after all other systems that declared a write dependency on the given\r\n     * component types (medium priority).\r\n     * @param componentTypes The component types whose writers this system should follow.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    afterWritersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.writers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.addEdge(other, system, 3);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system in any order relative to systems that declared a read dependency on the\r\n     * given component types (low priority).\r\n     * @param componentTypes The component types whose readers' order doesn't matter relative to this\r\n     *  one.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    inAnyOrderWithReadersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.readers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.denyEdge(other, system, 2);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Schedules this system in any order relative to systems that declared a write dependency on the\r\n     * given component types (low priority).\r\n     * @param componentTypes The component types whose writers' order doesn't matter relative to this\r\n     *  one.\r\n     * @returns The builder for chaining calls.\r\n     */\r\n    inAnyOrderWithWritersOf(...componentTypes) {\r\n        for (const componentType of componentTypes) {\r\n            for (const other of this.__dispatcher.planner.writers.get(componentType)) {\r\n                for (const system of this.__systems) {\r\n                    this.__dispatcher.planner.graph.denyEdge(other, system, 2);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n}\r\n/**\r\n * A placeholder object returned from {@link System.schedule} with no public API.\r\n */\r\nclass Schedule {\r\n}\r\nclass SystemGroupImpl {\r\n    __contents;\r\n    __plan;\r\n    __executed = false;\r\n    __systems;\r\n    __scheduleBuilder;\r\n    constructor(__contents) {\r\n        this.__contents = __contents;\r\n    }\r\n    __collectSystems(dispatcher) {\r\n        if (!this.__systems) {\r\n            this.__systems = [];\r\n            for (const item of this.__contents) {\r\n                if (item instanceof Function && item.__system) {\r\n                    this.__systems.push(dispatcher.systemsByClass.get(item));\r\n                }\r\n                else if (item instanceof SystemGroupImpl) {\r\n                    this.__systems.push(...item.__collectSystems(dispatcher));\r\n                }\r\n            }\r\n        }\r\n        return this.__systems;\r\n    }\r\n    __buildSchedule() {\r\n        this.__scheduleBuilder?.__build(this.__systems, `a group`);\r\n        this.__scheduleBuilder = null;\r\n    }\r\n    /**\r\n     * Creates scheduling constraints for all systems in the group; this works exactly as if the\r\n     * call was made individually to every {@link System.schedule}.  Can be called at most once.\r\n     * @param buildCallback A function that constrains the schedule using a small DSL.  See\r\n     * {@link ScheduleBuilder} for the API.\r\n     * @returns This group for chaining calls.\r\n     */\r\n    schedule(buildCallback) {\r\n        if (this.__scheduleBuilder === null) {\r\n            throw new CheckError(`Attempt to define group schedule after world initialized`);\r\n        }\r\n        if (this.__scheduleBuilder) {\r\n            throw new CheckError(`Attempt to define multiple schedules in a group`);\r\n        }\r\n        this.__scheduleBuilder = new ScheduleBuilder(buildCallback, new Schedule());\r\n        return this;\r\n    }\r\n}\r\nclass FrameImpl {\r\n    dispatcher;\r\n    groups;\r\n    executing;\r\n    time = now() / 1000;\r\n    delta;\r\n    constructor(dispatcher, groups) {\r\n        this.dispatcher = dispatcher;\r\n        this.groups = groups;\r\n        if (groups.length === 0) {\r\n            throw new CheckError('At least one system group needed');\r\n        }\r\n        for (const group of groups) {\r\n            if (!dispatcher.systemGroups.includes(group)) {\r\n                throw new CheckError('Some groups in the frame are not parts of the world defs');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Indicates that execution of a frame has begun and locks in the default `time` and `delta`.\r\n     * Must be called once at the beginning of each frame, prior to any calls to `execute`.  Must be\r\n     * bookended by a call to `end`.\r\n     *\r\n     * You cannot call `begin` while any other executors are running.\r\n     */\r\n    async begin() {\r\n        if (this.executing)\r\n            throw new CheckError('Frame already executing');\r\n        this.executing = true;\r\n        const lastTime = this.dispatcher.lastTime ?? this.time;\r\n        this.time = now() / 1000;\r\n        this.delta = this.time - lastTime;\r\n        this.dispatcher.startFrame(this.time);\r\n    }\r\n    /**\r\n     * Indicates that execution of a frame has completed.  Must be called once at the end of each\r\n     * frame, after any calls to `execute`.\r\n     */\r\n    async end() {\r\n        if (!this.executing)\r\n            throw new CheckError('Frame not executing');\r\n        this.executing = false;\r\n        allExecuted: {\r\n            for (const group of this.groups)\r\n                if (!group.__executed)\r\n                    break allExecuted;\r\n            for (const group of this.groups)\r\n                group.__executed = false;\r\n            this.dispatcher.completeCycle();\r\n        }\r\n        await this.dispatcher.completeFrame();\r\n    }\r\n    /**\r\n     * Executes a group of systems.  If your world is single-threaded then execution is synchronous\r\n     * and you can ignore the returned promise.\r\n     *\r\n     * You cannot execute individual systems, unless you create a singleton group to hold them.\r\n     *\r\n     * @param group The group of systems to execute.  Must be a member of the group list passed in\r\n     * when this executor was created.\r\n     *\r\n     * @param time The time of this frame's execution.  This will be set on every system's `time`\r\n     * property and defaults to the time when `begin` was called.  It's not used internally so you can\r\n     * pass in any numeric value that's expected by your systems.\r\n     *\r\n     * @param delta The duration since the last frame's execution.  This will be set on every system's\r\n     * `delta` property and default to the duration since any previous frame's `begin` was called.\r\n     * It's not used internally so you can pass in any numeric value that's expected by your systems.\r\n     */\r\n    execute(group, time, delta) {\r\n        if (!this.groups.includes(group)) {\r\n            throw new CheckError('Group not included in this frame');\r\n        }\r\n        if (!this.executing)\r\n            throw new CheckError('Frame not executing');\r\n        return group.__plan.execute(time ?? this.time, delta ?? this.delta);\r\n    }\r\n}\n\n/**\r\n * An exception thrown by coroutines when they've been canceled. You should normally rethrow it\r\n * from any catch blocks, and it will be caught and ignored at the top coroutine nesting level.\r\n */\r\nclass CanceledError extends Error {\r\n    canceled = true;\r\n    constructor() {\r\n        super('Canceled');\r\n    }\r\n}\r\nlet currentCoroutine;\r\nclass CoroutineImpl {\r\n    __generator;\r\n    __fn;\r\n    __supervisor;\r\n    __cancellers = [];\r\n    __blocker;\r\n    __scope;\r\n    __done = false;\r\n    __awaited = false;\r\n    __error;\r\n    __value;\r\n    __firstRun = true;\r\n    constructor(__generator, __fn, __supervisor) {\r\n        this.__generator = __generator;\r\n        this.__fn = __fn;\r\n        this.__supervisor = __supervisor;\r\n    }\r\n    __checkCancelation() {\r\n        if (this.__done)\r\n            return;\r\n        for (const canceller of this.__cancellers) {\r\n            if (canceller()) {\r\n                this.cancel();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    __step() {\r\n        currentCoroutine = this; // eslint-disable-line @typescript-eslint/no-this-alias\r\n        try {\r\n            if (!this.__done && (this.__blocker?.isReady() ?? true)) {\r\n                try {\r\n                    let next;\r\n                    if (this.__blocker?.error) {\r\n                        next = this.__generator.throw(this.__blocker.error);\r\n                    }\r\n                    else if (this.__firstRun) {\r\n                        try {\r\n                            next = this.__generator.next(this.__blocker?.value);\r\n                        }\r\n                        finally {\r\n                            this.__firstRun = false;\r\n                            this.__supervisor.cancelMatching(this, this.__scope, this.__fn);\r\n                        }\r\n                    }\r\n                    else {\r\n                        next = this.__generator.next(this.__blocker?.value);\r\n                    }\r\n                    if (next.done) {\r\n                        this.__done = true;\r\n                        this.__value = next.value;\r\n                        this.__blocker = undefined;\r\n                    }\r\n                    else {\r\n                        this.__blocker = next.value;\r\n                        this.__blocker?.markAwaited?.();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    this.__done = true;\r\n                    if (!this.__error)\r\n                        this.__error = e;\r\n                    this.__blocker = undefined;\r\n                }\r\n            }\r\n            if (this.__error && !(this.__awaited || this.__error instanceof CanceledError)) {\r\n                throw this.__error;\r\n            }\r\n        }\r\n        finally {\r\n            currentCoroutine = undefined;\r\n        }\r\n    }\r\n    // Waitable methods\r\n    isReady() {\r\n        return this.__done;\r\n    }\r\n    get value() {\r\n        return this.__value;\r\n    }\r\n    get error() {\r\n        return this.__error;\r\n    }\r\n    markAwaited() {\r\n        this.__awaited = true;\r\n    }\r\n    // CurrentCoroutine methods\r\n    waitForFrames(frames) {\r\n        if (frames <= 0)\r\n            throw new CheckError('Number of frames to wait for must be >0');\r\n        return {\r\n            isReady() { return --frames <= 0; }\r\n        };\r\n    }\r\n    waitForSeconds(seconds) {\r\n        const system = this.__supervisor.system;\r\n        const targetTime = system.time + seconds;\r\n        return {\r\n            isReady() { return system.time >= targetTime; }\r\n        };\r\n    }\r\n    waitUntil(condition) {\r\n        return { isReady: condition };\r\n    }\r\n    // Coroutine methods\r\n    cancel() {\r\n        if (this.__blocker?.cancel) {\r\n            this.__blocker.cancel();\r\n        }\r\n        else {\r\n            this.__error = new CanceledError();\r\n            this.__done = true;\r\n        }\r\n        return this;\r\n    }\r\n    cancelIf(condition) {\r\n        this.__cancellers.push(condition);\r\n        return this;\r\n    }\r\n    scope(entity) {\r\n        if (this.__scope)\r\n            throw new CheckError('Scope already set for this coroutine');\r\n        if (this.__cancellers.length) {\r\n            throw new CheckError('Scope must be set before any cancelation conditions');\r\n        }\r\n        this.__scope = entity;\r\n        this.cancelIf(() => !entity.alive);\r\n        return this;\r\n    }\r\n    cancelIfComponentMissing(type) {\r\n        if (!this.__scope)\r\n            throw new CheckError('Required scope not set for this coroutine');\r\n        this.cancelIf(() => !this.__scope?.has(type));\r\n        return this;\r\n    }\r\n    cancelIfCoroutineStarted(coroutineFn) {\r\n        this.__supervisor.registerCancelIfStarted(this, this.__scope, coroutineFn === coDecorator.self ? this.__fn : coroutineFn);\r\n        return this;\r\n    }\r\n    // We need to stub out all the Generator methods because we're overloading the type.  They must\r\n    // not be called by the user, however.\r\n    return(value) {\r\n        throw new CheckError('Generator methods not available for coroutines');\r\n    }\r\n    throw(e) {\r\n        throw new CheckError('Generator methods not available for coroutines');\r\n    }\r\n    next(...args) {\r\n        throw new CheckError('Generator methods not available for coroutines');\r\n    }\r\n    [Symbol.iterator]() {\r\n        throw new CheckError('Generator methods not available for coroutines');\r\n    }\r\n}\r\nfunction coDecorator(target, name, descriptor) {\r\n    const coroutine = descriptor.value;\r\n    return {\r\n        value(...args) {\r\n            return this.start(coroutine, ...args);\r\n        },\r\n    };\r\n}\r\ncoDecorator.waitForFrames = function (frames) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.waitForFrames(frames);\r\n};\r\ncoDecorator.waitForSeconds = function (seconds) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.waitForSeconds(seconds);\r\n};\r\ncoDecorator.waitUntil = function (condition) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.waitUntil(condition);\r\n};\r\ncoDecorator.cancel = function () {\r\n    checkCurrentCoroutine();\r\n    currentCoroutine.cancel();\r\n};\r\ncoDecorator.cancelIf = function (condition) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.cancelIf(condition);\r\n};\r\ncoDecorator.scope = function (entity) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.scope(entity);\r\n};\r\ncoDecorator.cancelIfComponentMissing = function (type) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.cancelIfComponentMissing(type);\r\n};\r\ncoDecorator.cancelIfCoroutineStarted = function (coroutineFn) {\r\n    checkCurrentCoroutine();\r\n    return currentCoroutine.cancelIfCoroutineStarted(coroutineFn);\r\n};\r\ncoDecorator.self = function* () { yield; };\r\nfunction checkCurrentCoroutine() {\r\n    if (!currentCoroutine)\r\n        throw new CheckError('Cannot call co methods outside coroutine context');\r\n}\r\n/**\r\n * This object can be used in two ways:\r\n * 1. As a decorator, to wrap coroutine methods in a call to {@link System.start} so you can invoke\r\n * them directly.\r\n * 2. As a handle to the currently executing coroutine, so you can invoke coroutine control methods\r\n * from within the coroutine's code.\r\n */\r\nconst co = coDecorator;\r\nclass Supervisor {\r\n    system;\r\n    coroutines = [];\r\n    mutuallyExclusiveCoroutines = new Map();\r\n    constructor(system) {\r\n        this.system = system;\r\n    }\r\n    start(coroutineFn, ...args) {\r\n        const coroutine = new CoroutineImpl(coroutineFn.apply(this.system, args), coroutineFn, this);\r\n        this.coroutines.push(coroutine);\r\n        return coroutine;\r\n    }\r\n    execute() {\r\n        // Execute in reverse order, so that the most recently started coroutines execute first.  That\r\n        // way, if coroutine A started coroutine B and is waiting for it to complete, it will resume in\r\n        // the same frame as B finishes rather than having to wait for another go-around. At the same\r\n        // time, if new coroutines are started while we're processing, keep iterating to execute the\r\n        // extra ones within the same frame.\r\n        let processedLength = 0;\r\n        while (processedLength < this.coroutines.length) {\r\n            const endIndex = processedLength;\r\n            processedLength = this.coroutines.length;\r\n            for (let i = processedLength - 1; i >= endIndex; i--) {\r\n                this.system.accessRecentlyDeletedData(false);\r\n                this.coroutines[i].__checkCancelation();\r\n            }\r\n            for (let i = processedLength - 1; i >= endIndex; i--) {\r\n                this.system.accessRecentlyDeletedData(false);\r\n                const coroutine = this.coroutines[i];\r\n                coroutine.__step();\r\n                if (coroutine.isReady()) {\r\n                    this.coroutines.splice(i, 1);\r\n                    processedLength -= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    registerCancelIfStarted(targetCoroutine, scope, coroutineFn) {\r\n        const key = (scope?.__id ?? '') + (coroutineFn?.name ?? '');\r\n        if (!this.mutuallyExclusiveCoroutines.has(key))\r\n            this.mutuallyExclusiveCoroutines.set(key, []);\r\n        this.mutuallyExclusiveCoroutines.get(key)?.push(targetCoroutine);\r\n    }\r\n    cancelMatching(startingCoroutine, scope, coroutineFn) {\r\n        this.cancelMatchingKey(startingCoroutine, '');\r\n        this.cancelMatchingKey(startingCoroutine, coroutineFn.name);\r\n        if (scope) {\r\n            this.cancelMatchingKey(startingCoroutine, '' + scope.__id);\r\n            this.cancelMatchingKey(startingCoroutine, '' + scope.__id + coroutineFn.name);\r\n        }\r\n    }\r\n    cancelMatchingKey(requestingCoroutine, key) {\r\n        const coroutines = this.mutuallyExclusiveCoroutines.get(key);\r\n        if (coroutines) {\r\n            let hasRequesting = false;\r\n            for (const coroutine of coroutines) {\r\n                if (coroutine === requestingCoroutine) {\r\n                    hasRequesting = true;\r\n                }\r\n                else {\r\n                    coroutine.cancel();\r\n                }\r\n            }\r\n            coroutines.length = 0;\r\n            if (hasRequesting)\r\n                coroutines.push(requestingCoroutine);\r\n        }\r\n    }\r\n}\n\nvar RunState;\r\n(function (RunState) {\r\n    RunState[RunState[\"RUNNING\"] = 0] = \"RUNNING\";\r\n    RunState[RunState[\"STOPPED\"] = 1] = \"STOPPED\";\r\n})(RunState || (RunState = {}));\r\nclass SingletonPlaceholder {\r\n    access;\r\n    type;\r\n    initialValues;\r\n    constructor(access, type, initialValues) {\r\n        this.access = access;\r\n        this.type = type;\r\n        this.initialValues = initialValues;\r\n    }\r\n}\r\nclass AttachPlaceholder {\r\n    type;\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n}\r\n// TODO: support HMR for systems\r\n/**\r\n * An encapsulated piece of functionality for your app that executes every frame, typically by\r\n * iterating over some components returned by a query.\r\n *\r\n * You should subclass and implement {@link System.execute} at a minimum, but take a look at the\r\n * other methods as well.\r\n */\r\nclass System {\r\n    static __system = true;\r\n    /**\r\n     * Create a group of systems that can be scheduled collectively, or used in\r\n     * {@link World.createCustomExecutor} to execute a subset of all the system in a frame. The group\r\n     * needs to be included in the world's defs, which will also automatically include all its member\r\n     * systems.\r\n     * @param systemTypes System classes to include in the group, each optionally followed by an\r\n     *  object to initialize the system's properties.  A system can be a member of more than one\r\n     *  group.\r\n     * @returns A group of the given systems.\r\n     */\r\n    static group(...systemTypes) {\r\n        return new SystemGroupImpl(systemTypes);\r\n    }\r\n    __queryBuilders = [];\r\n    __scheduleBuilder;\r\n    __attachPlaceholders = [];\r\n    __singletonPlaceholders = [];\r\n    __supervisor = new Supervisor(this);\r\n    __dispatcher;\r\n    /**\r\n     * A numeric ID, unique for systems within a world, that you can use for your own purposes.  Don't\r\n     * change it!\r\n     */\r\n    id;\r\n    /**\r\n     * The time that execution of the current frame was started. See {@link World.execute} for\r\n     * details.\r\n     * @typedef {}\r\n     */\r\n    time;\r\n    /**\r\n     * The duration between the execution times of the current and previous frames.  See\r\n     * {@link World.execute} for details.\r\n     */\r\n    delta;\r\n    /**\r\n     * This system's name, as used in error messages and stats reports.\r\n     */\r\n    get name() { return this.constructor.name; }\r\n    // TODO: add an API for making immediate queries\r\n    /**\r\n     * Creates a persistent query for this system.  Can only be called from the constructor, typically\r\n     * by initializing an instance property.\r\n     *\r\n     * Each query is automatically updated each frame immediately before the system executes.\r\n     * @example\r\n     * entities = this.query(q => q.all.with(ComponentFoo).write);\r\n     * execute() {\r\n     *   for (const entity of this.entities) {\r\n     *     entity.write(ComponentFoo).bar += 1;\r\n     *   }\r\n     * }\r\n     * @param buildCallback A function that builds the actual query using a small DSL.  See\r\n     * {@link QueryBuilder} for the API.\r\n     * @returns A live query that you can reference from the `execute` method.  It's also OK to read\r\n     * a query from other attached systems, but note that it will only be updated prior to its host\r\n     * system's execution.\r\n     */\r\n    query(buildCallback) {\r\n        const query = new Query();\r\n        const builder = new QueryBuilder(buildCallback, query);\r\n        if (!this.__queryBuilders) {\r\n            throw new CheckError(`Attempt to create a new query after world initialized in system ${this.name}`);\r\n        }\r\n        this.__queryBuilders.push(builder);\r\n        return query;\r\n    }\r\n    /**\r\n     * Creates scheduling constraints for this system that will help determine its assignment to a\r\n     * thread and the order of execution.  Can be called at most once, and only from the constructor,\r\n     * typically by initializing an instance property.\r\n     * @example\r\n     * sked = this.schedule(s => s.beforeWritesTo(ComponentFoo).after(SystemBar));\r\n     * @param buildCallback A function that constrains the schedule using a small DSL.  See\r\n     * {@link ScheduleBuilder} for the API.\r\n     * @returns A schedule placeholder object with no public API.\r\n     */\r\n    schedule(buildCallback) {\r\n        if (this.__scheduleBuilder === null) {\r\n            throw new CheckError(`Attempt to define schedule after world initialized in system ${this.name}`);\r\n        }\r\n        if (this.__scheduleBuilder) {\r\n            throw new CheckError(`Attempt to define multiple schedules in system ${this.name}`);\r\n        }\r\n        const schedule = new Schedule();\r\n        this.__scheduleBuilder = new ScheduleBuilder(buildCallback, schedule);\r\n        return schedule;\r\n    }\r\n    /**\r\n     * Creates a reference to another system in the world, that you can then use in your `initialize`\r\n     * or `execute` methods.  Be careful not to abuse this feature as it will force all systems that\r\n     * reference each other to be located in the same thread when using multithreading, possibly\r\n     * limiting performance.  Can only be called from the constructor, typically by initializing an\r\n     * instance property.\r\n     * @example\r\n     * foo = this.attach(SystemFoo);\r\n     * @param systemType The type of the system to reference.\r\n     * @returns The unique instance of the system of the given type that exists in the world.\r\n     */\r\n    attach(systemType) {\r\n        if (!this.__attachPlaceholders) {\r\n            throw new CheckError(`Attempt to attach a system after world initialized in system ${this.name}`);\r\n        }\r\n        const placeholder = new AttachPlaceholder(systemType);\r\n        this.__attachPlaceholders.push(placeholder);\r\n        return placeholder;\r\n    }\r\n    /**\r\n     * Creates a new entity.  It works just like {@link World.createEntity} but returns the newly\r\n     * created entity.  You *must not* retain a direct reference to the entity past the end of the\r\n     * `execute` method.\r\n     * @param initialComponents The types of the components to add to the new entity, optionally\r\n     * interleaved with their initial properties.\r\n     * @returns The newly created entity.\r\n     */\r\n    createEntity(...initialComponents) {\r\n        return this.__dispatcher.createEntity(initialComponents);\r\n    }\r\n    /**\r\n     * Enables or disables access to recently deleted data.  When turned on, you'll be able to read\r\n     * components that were removed since the system's last execution, as well as references and\r\n     * back references to entities deleted in the same time frame.\r\n     * @param toggle Whether to turn access to recently deleted data on or off.\r\n     */\r\n    accessRecentlyDeletedData(toggle = true) {\r\n        this.__dispatcher.registry.includeRecentlyDeleted = toggle;\r\n    }\r\n    /**\r\n     * Starts running a coroutine.  The coroutine will execute after each time this system does and\r\n     * run until its next `yield` expression.  You can start coroutines anytime: from within\r\n     * `initialize` or `execute`, from within a coroutine, or even from an event handler between\r\n     * frames.  Coroutines started from within `execute` will begin running in the same frame.  The\r\n     * execution order of coroutines within a system is unspecified and you should not depend on it.\r\n     *\r\n     * If you're using the {@link co} decorator you don't need call this method manually, it'll be\r\n     * handled for you.\r\n     *\r\n     * Inside the coroutine, you can call methods on {@link co} to control the execution of the\r\n     * coroutine.  You can `yield` on the result of the various `co.wait` methods, and also `yield`\r\n     * directly on the result of starting another coroutine to wait for its returned value.\r\n     *\r\n     * @param generator The generator returned by a coroutine method.\r\n     * @param coroutineFn The coroutine being started, to be used with\r\n     *    {@link Coroutine.cancelIfCoroutineStarted}.\r\n     * @returns A coroutine handle that you can use to control it.\r\n     */\r\n    start(coroutineFn, ...args) {\r\n        // TODO: disable coroutines if system is stateless\r\n        return this.__supervisor.start(coroutineFn, ...args);\r\n    }\r\n    /**\r\n     * Prepares any data or other structures needed by the system; to be implemented in a subclass and\r\n     * invoked automatically precisely once when the world is created.  This method is not allowed to\r\n     * create entities or access components.  Instead, it should set any needed data on the system's\r\n     * properties to be used in `initialize`, which will be called afterwards.\r\n     */\r\n    async prepare() { } // eslint-disable-line @typescript-eslint/no-empty-function\r\n    /**\r\n     * Initializes the system; to be implemented in a subclass and invoked automatically precisely\r\n     * once when the world is created and after the system has been prepared.  This method is allowed\r\n     * to access the components as declared in the system's queries.\r\n     */\r\n    initialize() { } // eslint-disable-line @typescript-eslint/no-empty-function\r\n    /**\r\n     * Executes the system's function; to be implemented in a subclass and invoked automatically at\r\n     * regular intervals.\r\n     */\r\n    execute() { } // eslint-disable-line @typescript-eslint/no-empty-function\r\n    /**\r\n     * Finalizes the system; to be implemented in a subclass and invoked automatically precisely\r\n     * once when the world is terminated.  This method is allowed to access the components as declared\r\n     * in the system's queries.\r\n     */\r\n    finalize() { } // eslint-disable-line @typescript-eslint/no-empty-function\r\n}\r\nObject.defineProperty(System.prototype, 'singleton', {\r\n    get() {\r\n        const self = this; // eslint-disable-line @typescript-eslint/no-this-alias\r\n        const singleton = {\r\n            read(type) {\r\n                if (!self.__singletonPlaceholders) {\r\n                    throw new CheckError(`Attempt to declare a singleton after world initialized in system ${self.name}`);\r\n                }\r\n                declareSingleton(type);\r\n                self.query(q => q.using(type).read);\r\n                const placeholder = new SingletonPlaceholder('read', type);\r\n                self.__singletonPlaceholders.push(placeholder);\r\n                return placeholder;\r\n            },\r\n            write(type, initialValues) {\r\n                if (!self.__singletonPlaceholders) {\r\n                    throw new CheckError(`Attempt to declare a singleton after world initialized in system ${self.name}`);\r\n                }\r\n                declareSingleton(type);\r\n                self.query(q => q.using(type).write);\r\n                const placeholder = new SingletonPlaceholder('write', type, initialValues);\r\n                self.__singletonPlaceholders.push(placeholder);\r\n                return placeholder;\r\n            }\r\n        };\r\n        Object.defineProperty(this, 'singleton', { value: singleton, configurable: true });\r\n        return singleton;\r\n    }\r\n});\r\nclass SystemBox {\r\n    system;\r\n    dispatcher;\r\n    get id() { return this.system.id; }\r\n    get name() { return this.system.name; }\r\n    toString() { return this.name; }\r\n    constructor(system, dispatcher) {\r\n        this.system = system;\r\n        this.dispatcher = dispatcher;\r\n        system.__dispatcher = dispatcher;\r\n        this.accessMasks = { read: [], update: [], create: [], write: [], check: [] };\r\n        this.shapeQueries = [];\r\n        this.shapeQueriesByComponent = [];\r\n        this.writeQueries = [];\r\n        this.writeQueriesByComponent = [];\r\n        this.state = RunState.RUNNING;\r\n        this.propsAssigned = false;\r\n        this.stateless = false;\r\n        this.weight = 1;\r\n        this.shapeLogPointer = dispatcher.shapeLog.createPointer();\r\n        this.stats = dispatcher.stats.forSystem(system.constructor);\r\n        this.attachedSystems = this.system.__attachPlaceholders.map(placeholder => this.dispatcher.systemsByClass.get(placeholder.type));\r\n        this.singletonComponentDefs = this.system.__singletonPlaceholders.flatMap(placeholder => {\r\n            return placeholder.initialValues ?\r\n                [placeholder.type, placeholder.initialValues] : [placeholder.type];\r\n        });\r\n        this.singletonStandingWrites = this.system.__singletonPlaceholders\r\n            .filter(placeholder => placeholder.access === 'write')\r\n            .map(placeholder => placeholder.type);\r\n    }\r\n    assignProps(props) {\r\n        if (this.propsAssigned) {\r\n            throw new CheckError(`System ${this.name} has multiple props assigned in world defs`);\r\n        }\r\n        Object.assign(this.system, props);\r\n        this.propsAssigned = true;\r\n    }\r\n    buildQueries() {\r\n        for (const builder of this.system.__queryBuilders)\r\n            builder.__build(this);\r\n        this.system.__queryBuilders = null;\r\n        this.hasNegativeQueries = !!this.shapeQueriesByComponent[this.dispatcher.registry.Alive.id];\r\n        this.hasWriteQueries = !!this.writeQueries.length;\r\n        this.hasTransientQueries = this.shapeQueries.some(query => query.hasTransientResults);\r\n    }\r\n    buildSchedule() {\r\n        const staticScheduler = this.system.constructor.__staticScheduler;\r\n        if (staticScheduler)\r\n            this.system.schedule(staticScheduler);\r\n        this.system.__scheduleBuilder?.__build([this], `system ${this.name}`);\r\n        this.system.__scheduleBuilder = null;\r\n    }\r\n    finishConstructing() {\r\n        this.writeLogPointer = this.dispatcher.writeLog?.createPointer();\r\n        this.singletonStandingWrites =\r\n            this.singletonStandingWrites.filter(type => type.__binding.trackedWrites);\r\n    }\r\n    replacePlaceholders() {\r\n        const openSystem = this.system;\r\n        for (const prop in this.system) {\r\n            const value = openSystem[prop];\r\n            if (value instanceof AttachPlaceholder) {\r\n                const targetSystemType = value.type;\r\n                const targetSystem = this.dispatcher.systemsByClass.get(targetSystemType);\r\n                if (!targetSystem) {\r\n                    throw new CheckError(`Attached system ${targetSystemType.name} not defined in this world`);\r\n                }\r\n                openSystem[prop] = targetSystem.system;\r\n            }\r\n            else if (value instanceof SingletonPlaceholder) {\r\n                openSystem[prop] = this.dispatcher.singleton[value.access](value.type);\r\n            }\r\n        }\r\n        this.system.__attachPlaceholders = null;\r\n        this.system.__singletonPlaceholders = null;\r\n        if (this.dispatcher.singleton) {\r\n            Object.defineProperty(this.system, 'singleton', { value: this.dispatcher.singleton });\r\n        }\r\n    }\r\n    prepare() {\r\n        return this.system.prepare();\r\n    }\r\n    initialize() {\r\n        this.dispatcher.registry.executingSystem = this;\r\n        this.system.initialize();\r\n        this.trackStandingWrites();\r\n    }\r\n    finalize() {\r\n        this.dispatcher.registry.executingSystem = this;\r\n        this.system.finalize();\r\n        this.trackStandingWrites();\r\n    }\r\n    execute(time, delta) {\r\n        if (this.state !== RunState.RUNNING)\r\n            return;\r\n        this.dispatcher.registry.executingSystem = this;\r\n        this.system.time = time;\r\n        this.system.delta = delta;\r\n        let time1, time2, time3, time4;\r\n        time1 = now();\r\n        this.runQueries();\r\n        time2 = now();\r\n        this.system.execute();\r\n        time3 = now();\r\n        this.system.__supervisor.execute();\r\n        this.trackStandingWrites();\r\n        time4 = now();\r\n        {\r\n            this.stats.lastQueryUpdateDuration = time2 - time1;\r\n            this.stats.lastExecutionDuration = time3 - time2;\r\n            this.stats.lastCoroutinesDuration = time4 - time3;\r\n        }\r\n    }\r\n    trackStandingWrites() {\r\n        const singleton = this.dispatcher.singleton;\r\n        for (const type of this.singletonStandingWrites) {\r\n            this.dispatcher.registry.trackWrite(singleton.__id, type);\r\n        }\r\n    }\r\n    runQueries() {\r\n        const ranQueriesLastFrame = this.ranQueriesLastFrame;\r\n        this.ranQueriesLastFrame = false;\r\n        const shapesChanged = this.dispatcher.shapeLog.hasUpdatesSince(this.shapeLogPointer);\r\n        const writesMade = this.hasWriteQueries &&\r\n            this.dispatcher.writeLog.hasUpdatesSince(this.writeLogPointer);\r\n        if (shapesChanged || writesMade || this.hasTransientQueries && ranQueriesLastFrame) {\r\n            if (this.hasTransientQueries) {\r\n                // Every write query is a shape query too.\r\n                for (const query of this.shapeQueries)\r\n                    query.clearTransientResults();\r\n            }\r\n            if (shapesChanged || writesMade) {\r\n                this.ranQueriesLastFrame = true;\r\n                if (shapesChanged)\r\n                    this.__updateShapeQueries();\r\n                if (writesMade)\r\n                    this.__updateWriteQueries();\r\n                for (const query of this.shapeQueries)\r\n                    query.sort();\r\n            }\r\n        }\r\n    }\r\n    __updateShapeQueries() {\r\n        const shapeLog = this.dispatcher.shapeLog;\r\n        if (!this.shapeQueries.length) {\r\n            shapeLog.createPointer(this.shapeLogPointer);\r\n            return;\r\n        }\r\n        for (const query of this.shapeQueries)\r\n            query.clearProcessedEntities();\r\n        let queries, runLength = 0;\r\n        let log, startIndex, endIndex;\r\n        while (true) {\r\n            [log, startIndex, endIndex] = shapeLog.processSince(this.shapeLogPointer);\r\n            if (!log)\r\n                break;\r\n            if (runLength && !queries) {\r\n                startIndex += runLength;\r\n                runLength = 0;\r\n            }\r\n            for (let i = startIndex; i < endIndex; i++) {\r\n                const entry = log[i];\r\n                const entityId = (entry & ENTITY_ID_MASK);\r\n                if (!queries) {\r\n                    const typeId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;\r\n                    const runHeader = entry & 2 ** 31;\r\n                    queries = this.shapeQueriesByComponent[typeId];\r\n                    if (runHeader) {\r\n                        runLength = entityId;\r\n                        if (!queries) {\r\n                            const skip = Math.min(runLength, endIndex - i);\r\n                            i += skip;\r\n                            runLength -= skip;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (!queries)\r\n                        continue;\r\n                    runLength = 1;\r\n                }\r\n                if (entry & 2 ** 31) {\r\n                    throw new InternalError('Trying to process run header as entry in shape log');\r\n                }\r\n                for (let j = 0; j < queries.length; j++)\r\n                    queries[j].handleShapeUpdate(entityId);\r\n                if (--runLength === 0)\r\n                    queries = undefined;\r\n            }\r\n        }\r\n    }\r\n    __updateWriteQueries() {\r\n        const writeLog = this.dispatcher.writeLog;\r\n        if (!this.writeQueries.length) {\r\n            writeLog.createPointer(this.writeLogPointer);\r\n            return;\r\n        }\r\n        let queries, runLength = 0;\r\n        let componentFlagOffset, componentFlagMask;\r\n        let log, startIndex, endIndex;\r\n        while (true) {\r\n            [log, startIndex, endIndex] = writeLog.processSince(this.writeLogPointer);\r\n            if (!log)\r\n                break;\r\n            if (runLength && !queries) {\r\n                startIndex += runLength;\r\n                runLength = 0;\r\n            }\r\n            for (let i = startIndex; i < endIndex; i++) {\r\n                const entry = log[i];\r\n                const entityId = (entry & ENTITY_ID_MASK);\r\n                if (!queries) {\r\n                    const typeId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;\r\n                    const runHeader = entry & 2 ** 31;\r\n                    // Manually recompute flag offset and mask instead of looking up component type.\r\n                    componentFlagOffset = typeId >> 5;\r\n                    componentFlagMask = 1 << (typeId & 31);\r\n                    queries = this.writeQueriesByComponent[typeId];\r\n                    if (runHeader) {\r\n                        runLength = entityId;\r\n                        if (!queries) {\r\n                            const skip = Math.min(runLength, endIndex - i);\r\n                            i += skip;\r\n                            runLength -= skip;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (!queries)\r\n                        continue;\r\n                    runLength = 1;\r\n                }\r\n                if (entry & 2 ** 31) {\r\n                    throw new InternalError('Trying to process run header as entry in write log');\r\n                }\r\n                for (let j = 0; j < queries.length; j++) {\r\n                    queries[j].handleWrite(entityId, componentFlagOffset, componentFlagMask);\r\n                }\r\n                if (--runLength === 0)\r\n                    queries = undefined;\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.state === RunState.STOPPED)\r\n            return;\r\n        this.state = RunState.STOPPED;\r\n        for (const query of this.shapeQueries)\r\n            query.clearAllResults();\r\n    }\r\n    restart() {\r\n        if (this.state === RunState.STOPPED) {\r\n            const registry = this.dispatcher.registry;\r\n            const Alive = registry.Alive;\r\n            for (const query of this.shapeQueries)\r\n                query.clearProcessedEntities();\r\n            for (let id = 0; id < this.dispatcher.maxEntities; id++) {\r\n                if (registry.hasShape(id, Alive, false)) {\r\n                    for (const query of this.shapeQueries)\r\n                        query.handleShapeUpdate(id);\r\n                }\r\n            }\r\n            for (const query of this.shapeQueries) {\r\n                query.clearTransientResults();\r\n                query.sort();\r\n            }\r\n            this.dispatcher.shapeLog.createPointer(this.shapeLogPointer);\r\n            this.dispatcher.writeLog?.createPointer(this.writeLogPointer);\r\n        }\r\n        this.state = RunState.RUNNING;\r\n    }\r\n}\n\nclass ComponentEnum {\r\n    name;\r\n    __types;\r\n    __binding;\r\n    constructor(name, types) {\r\n        this.name = name;\r\n        this.__types = Array.from(new Set(types));\r\n    }\r\n}\n\nconst HEADER_LENGTH = 2;\r\nclass UnsharedPool {\r\n    maxItems;\r\n    configParamName;\r\n    // layout: length, mark, ...uints\r\n    data;\r\n    constructor(maxItems, configParamName) {\r\n        this.maxItems = maxItems;\r\n        this.configParamName = configParamName;\r\n        this.data = new Uint32Array(new ArrayBuffer((maxItems + HEADER_LENGTH) * Uint32Array.BYTES_PER_ELEMENT));\r\n    }\r\n    get length() {\r\n        return this.data[0];\r\n    }\r\n    take() {\r\n        const length = --this.data[0];\r\n        if (length < 0) {\r\n            throw new RangeError(`Pool capacity exceeded, please raise ${this.configParamName} above ${this.maxItems}`);\r\n        }\r\n        return this.data[length + HEADER_LENGTH];\r\n    }\r\n    return(id) {\r\n        if (this.length >= this.maxItems) {\r\n            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');\r\n        }\r\n        this.data[this.length + HEADER_LENGTH] = id;\r\n        this.data[0] += 1;\r\n    }\r\n    mark() {\r\n        this.data[1] = this.data[0];\r\n    }\r\n    peekSinceMark(index) {\r\n        const i = this.data[1] + index;\r\n        if (i < this.data[0])\r\n            return this.data[i + HEADER_LENGTH];\r\n    }\r\n    refill(source) {\r\n        if (!source.length)\r\n            return;\r\n        const length = this.length;\r\n        const newLength = length + source.length;\r\n        if (newLength > this.maxItems) {\r\n            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');\r\n        }\r\n        this.data.set(source, length + HEADER_LENGTH);\r\n        this.data[0] = newLength;\r\n    }\r\n    fillWithDescendingIntegers(first) {\r\n        const lowerBound = this.length + HEADER_LENGTH;\r\n        for (let i = this.data.length - 1; i >= lowerBound; i--) {\r\n            this.data[i] = first++;\r\n        }\r\n        this.data[0] = this.data.length - HEADER_LENGTH;\r\n    }\r\n}\r\n/**\r\n * A shared pool of u32's that uses atomic operations to deconflict concurrent callers of `take`.\r\n * The `return` method is not threadsafe.\r\n */\r\nclass SharedAtomicPool {\r\n    maxItems;\r\n    configParamName;\r\n    // layout: length, mark, ...uints\r\n    data;\r\n    constructor(maxItems, configParamName, buffers) {\r\n        this.maxItems = maxItems;\r\n        this.configParamName = configParamName;\r\n        buffers.register(`pool.${configParamName}`, maxItems + HEADER_LENGTH, Uint32Array, (data) => { this.data = data; });\r\n    }\r\n    get length() {\r\n        return this.data[0];\r\n    }\r\n    take() {\r\n        const length = Atomics.sub(this.data, 0, 1);\r\n        if (length < 0) {\r\n            throw new RangeError(`Pool capacity exceeded, please raise ${this.configParamName} above ${this.maxItems}`);\r\n        }\r\n        return this.data[length + HEADER_LENGTH];\r\n    }\r\n    return(id) {\r\n        if (this.length >= this.maxItems) {\r\n            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');\r\n        }\r\n        this.data[this.length + HEADER_LENGTH] = id;\r\n        this.data[0] += 1;\r\n    }\r\n    mark() {\r\n        this.data[1] = this.data[0];\r\n    }\r\n    peekSinceMark(index) {\r\n        const i = this.data[1] + index;\r\n        if (i < this.data[0])\r\n            return this.data[i + HEADER_LENGTH];\r\n    }\r\n    refill(source) {\r\n        if (!source.length)\r\n            return;\r\n        const length = this.length;\r\n        const newLength = length + source.length;\r\n        if (newLength > this.maxItems) {\r\n            throw new InternalError('Internal error, returned entity ID exceeded pool capacity');\r\n        }\r\n        this.data.set(source, length + HEADER_LENGTH);\r\n        this.data[0] = newLength;\r\n    }\r\n    fillWithDescendingIntegers(first) {\r\n        const lowerBound = this.length + HEADER_LENGTH;\r\n        for (let i = this.data.length - 1; i >= lowerBound; i--) {\r\n            this.data[i] = first++;\r\n        }\r\n        this.data[0] = this.data.length - HEADER_LENGTH;\r\n    }\r\n}\n\nclass UnsharedShapeArray {\r\n    stride;\r\n    array;\r\n    constructor(bufferKey, numBits, maxEntities, buffers) {\r\n        this.stride = Math.ceil(numBits / 32);\r\n        buffers.register(bufferKey, maxEntities * this.stride, Uint32Array, shapes => { this.array = shapes; });\r\n    }\r\n    syncThreads() {\r\n        // no-op\r\n    }\r\n    set(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        const value = binding.shapeValue;\r\n        this.array[index] &= ~mask;\r\n        this.array[index] |= value;\r\n    }\r\n    unset(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        this.array[index] &= ~mask;\r\n    }\r\n    isSet(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        const value = binding.shapeValue;\r\n        return (this.array[index] & mask) === value;\r\n    }\r\n    get(entityId, enumeration) {\r\n        const binding = enumeration.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        return (this.array[index] & mask) >>> binding.shapeShift;\r\n    }\r\n    clear() {\r\n        this.array.fill(0);\r\n    }\r\n    match(entityId, positiveMask, positiveValues) {\r\n        if (positiveMask.length !== positiveValues.length) {\r\n            throw new InternalError(`Mismatched mask and value lengths: ${positiveMask.length} vs ${positiveValues.length}`);\r\n        }\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < positiveMask.length; i++) {\r\n            if ((array[index + i] & positiveMask[i]) !== positiveValues[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    matchNot(entityId, negativeMask) {\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < negativeMask.length; i++) {\r\n            if ((array[index + i] & negativeMask[i]) !== 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    matchAny(entityId, trackingMask) {\r\n        trackingMask.changed = false;\r\n        const mask = trackingMask.mask;\r\n        const lastMatch = trackingMask.lastMatches[entityId] = trackingMask.lastMatches[entityId] || [];\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        let ok = false;\r\n        for (let i = 0; i < mask.length; i++) {\r\n            const masked = array[index + i] & mask[i];\r\n            if (masked !== 0)\r\n                ok = true;\r\n            if (masked !== lastMatch[i])\r\n                trackingMask.changed = true;\r\n            lastMatch[i] = masked;\r\n        }\r\n        if (!ok)\r\n            delete trackingMask.lastMatches[entityId];\r\n        return ok;\r\n    }\r\n}\r\nclass AtomicSharedShapeArray {\r\n    stride;\r\n    array;\r\n    constructor(bufferKey, numBits, maxEntities, buffers) {\r\n        this.stride = Math.ceil(numBits / 32);\r\n        buffers.register(bufferKey, maxEntities * this.stride, Uint32Array, shapes => { this.array = shapes; });\r\n    }\r\n    syncThreads() {\r\n        // We assume that any atomic operation will force a write barrier on the whole array.\r\n        Atomics.load(this.array, 0);\r\n    }\r\n    set(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        const value = binding.shapeValue;\r\n        if (mask !== value)\r\n            Atomics.and(this.array, index, ~mask);\r\n        Atomics.or(this.array, index, value);\r\n    }\r\n    unset(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        Atomics.and(this.array, index, ~mask);\r\n    }\r\n    isSet(entityId, type) {\r\n        const binding = type.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        const value = binding.shapeValue;\r\n        // Entity liveness flag can be written at any time from any thread, so do atomic check.\r\n        if (type.id === 0)\r\n            return (Atomics.load(this.array, index) & mask) === value;\r\n        return (this.array[index] & mask) === value;\r\n    }\r\n    get(entityId, enumeration) {\r\n        const binding = enumeration.__binding;\r\n        const index = entityId * this.stride + binding.shapeOffset;\r\n        const mask = binding.shapeMask;\r\n        return (this.array[index] & mask) >>> binding.shapeShift;\r\n    }\r\n    clear() {\r\n        this.array.fill(0);\r\n    }\r\n    match(entityId, positiveMask, positiveValues) {\r\n        if (positiveMask.length !== positiveValues.length) {\r\n            throw new InternalError(`Mismatched mask and value lengths: ${positiveMask.length} vs ${positiveValues.length}`);\r\n        }\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < positiveMask.length; i++) {\r\n            if ((array[index + i] & positiveMask[i]) !== positiveValues[i])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    matchNot(entityId, negativeMask) {\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < negativeMask.length; i++) {\r\n            if ((array[index + i] & negativeMask[i]) !== 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    matchAny(entityId, trackingMask) {\r\n        trackingMask.changed = false;\r\n        const mask = trackingMask.mask;\r\n        const lastMatch = trackingMask.lastMatches[entityId] = trackingMask.lastMatches[entityId] || [];\r\n        const array = this.array;\r\n        const index = entityId * this.stride;\r\n        for (let i = 0; i < mask.length; i++) {\r\n            const masked = array[index + i] & mask[i];\r\n            if (masked === 0) {\r\n                delete trackingMask.lastMatches[entityId];\r\n                return false;\r\n            }\r\n            if (masked !== lastMatch[i])\r\n                trackingMask.changed = true;\r\n            lastMatch[i] = masked;\r\n        }\r\n        return true;\r\n    }\r\n}\n\nconst SYSTEM_ERROR_TYPES = [\r\n    EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError,\r\n    CheckError, InternalError\r\n];\r\nclass EntityPool {\r\n    registry;\r\n    borrowed; // indexed by id\r\n    borrowCounts; // indexed by id\r\n    spares = [];\r\n    temporarilyBorrowedIds = [];\r\n    constructor(registry, maxEntities) {\r\n        this.registry = registry;\r\n        this.borrowed = Array.from({ length: maxEntities });\r\n        this.borrowCounts = new Int32Array(maxEntities);\r\n    }\r\n    borrow(id) {\r\n        this.borrowCounts[id] += 1;\r\n        let entity = this.borrowed[id];\r\n        if (!entity) {\r\n            entity = this.borrowed[id] = this.spares.pop() ?? new EntityImpl(this.registry);\r\n            entity.__id = id;\r\n        }\r\n        return entity;\r\n    }\r\n    borrowTemporarily(id) {\r\n        const entity = this.borrow(id);\r\n        this.temporarilyBorrowedIds.push(id);\r\n        return entity;\r\n    }\r\n    returnTemporaryBorrows() {\r\n        for (const id of this.temporarilyBorrowedIds)\r\n            this.return(id);\r\n        this.temporarilyBorrowedIds.length = 0;\r\n    }\r\n    return(id) {\r\n        {\r\n            if (!this.borrowCounts[id]) {\r\n                throw new InternalError('Returning entity with no borrows');\r\n            }\r\n        }\r\n        if (--this.borrowCounts[id] <= 0) {\r\n            const entity = this.borrowed[id];\r\n            this.borrowed[id] = undefined;\r\n            {\r\n                entity.__valid = false;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Registry {\r\n    types;\r\n    enums;\r\n    dispatcher;\r\n    allocationItems;\r\n    numShapeBits = 0;\r\n    shapes;\r\n    staleShapes;\r\n    removedShapes;\r\n    entityIdPool;\r\n    pool;\r\n    heldEntities;\r\n    validators;\r\n    reshapedEntityIds = [];\r\n    validateSystem;\r\n    executingSystem;\r\n    includeRecentlyDeleted = false;\r\n    hasNegativeQueries = false;\r\n    nextEntityOrdinal = 0;\r\n    entityOrdinals;\r\n    removalLog;\r\n    prevRemovalPointer;\r\n    oldRemovalPointer;\r\n    Alive = class Alive {\r\n        static __internal = true;\r\n    };\r\n    constructor(maxEntities, maxLimboComponents, types, enums, dispatcher) {\r\n        this.types = types;\r\n        this.enums = enums;\r\n        this.dispatcher = dispatcher;\r\n        this.allocationItems = this.prepareComponentTypesAndEnums();\r\n        for (const item of this.allocationItems)\r\n            this.numShapeBits += item.size;\r\n        const ShapeArrayClass = dispatcher.threaded ? AtomicSharedShapeArray : UnsharedShapeArray;\r\n        this.shapes = new ShapeArrayClass('registry.shapes', this.numShapeBits, maxEntities, dispatcher.buffers);\r\n        this.staleShapes = new ShapeArrayClass('registry.staleShapes', this.numShapeBits, maxEntities, dispatcher.buffers);\r\n        this.removedShapes = new ShapeArrayClass('registry.removedShapes', this.numShapeBits, maxEntities, dispatcher.buffers);\r\n        this.entityIdPool = dispatcher.threaded ?\r\n            new SharedAtomicPool(maxEntities, 'maxEntities', dispatcher.buffers) :\r\n            new UnsharedPool(maxEntities, 'maxEntities');\r\n        this.entityOrdinals = dispatcher.buffers.register('registry.entityOrdinals', maxEntities, Uint32Array, array => { this.entityOrdinals = array; });\r\n        this.entityIdPool.fillWithDescendingIntegers(0);\r\n        this.pool = new EntityPool(this, maxEntities);\r\n        this.heldEntities = [];\r\n        this.validators = [];\r\n        this.removalLog = new Log(maxLimboComponents, 'maxLimboComponents', dispatcher.buffers);\r\n        this.prevRemovalPointer = this.removalLog.createPointer();\r\n        this.oldRemovalPointer = this.removalLog.createPointer();\r\n    }\r\n    initializeComponentTypes() {\r\n        // Two-phase init, so components can have dependencies on each other's fields.\r\n        let bitIndex = 0, typeId = 0;\r\n        while (this.allocationItems.length) {\r\n            const shift = bitIndex % 32;\r\n            const item = this.removeBiggestNoLargerThan(32 - shift);\r\n            if (!item) {\r\n                bitIndex += 32 - shift;\r\n                continue;\r\n            }\r\n            const shapeSpec = {\r\n                offset: bitIndex >>> 5, mask: ((1 << item.size) - 1) << shift, value: 1 << shift\r\n            };\r\n            bitIndex += item.size;\r\n            if (item.typeOrEnum instanceof ComponentEnum) {\r\n                const enumeration = item.typeOrEnum;\r\n                enumeration.__binding = {\r\n                    shapeOffset: shapeSpec.offset, shapeMask: shapeSpec.mask, shapeShift: shift\r\n                };\r\n                for (const type of enumeration.__types) {\r\n                    assimilateComponentType(typeId++, type, shapeSpec, this.dispatcher);\r\n                    if (type.validate)\r\n                        this.validators.push(type);\r\n                    shapeSpec.value += 1 << shift;\r\n                }\r\n            }\r\n            else {\r\n                const type = item.typeOrEnum;\r\n                assimilateComponentType(typeId++, type, shapeSpec, this.dispatcher);\r\n                if (type.validate)\r\n                    this.validators.push(type);\r\n            }\r\n        }\r\n        for (const type of this.types)\r\n            defineAndAllocateComponentType(type);\r\n        {\r\n            const aliveBinding = this.Alive.__binding;\r\n            if (!(aliveBinding.shapeOffset === 0 && aliveBinding.shapeMask === 1 &&\r\n                aliveBinding.shapeValue === 1)) {\r\n                throw new InternalError('Alive component was not assigned first available shape mask');\r\n            }\r\n        }\r\n    }\r\n    prepareComponentTypesAndEnums() {\r\n        const pool = [];\r\n        const enumTypes = new Set();\r\n        const typeNames = new Set();\r\n        let anonymousTypeCounter = 0;\r\n        for (const type of this.types) {\r\n            if (!type.name) {\r\n                Object.defineProperty(type, 'name', { value: `Anonymous_${anonymousTypeCounter++}` });\r\n            }\r\n            if (!type.__internal) {\r\n                if (typeNames.has(type.name)) {\r\n                    throw new CheckError(`Multiple component types named ${type.name}; names must be unique`);\r\n                }\r\n                typeNames.add(type.name);\r\n            }\r\n            if (type.enum) {\r\n                if (!this.enums.includes(type.enum)) {\r\n                    throw new CheckError(`Component type ${type.name} references an enum that's not in the world's defs`);\r\n                }\r\n                if (!type.enum.__types.includes(type))\r\n                    type.enum.__types.push(type);\r\n            }\r\n            this.dispatcher.stats.forComponent(type);\r\n        }\r\n        for (const enumeration of this.enums) {\r\n            if (enumeration.__types.length > 2 ** 31) {\r\n                throw new CheckError(`Too many types in enum: ${enumeration.__types.length}`);\r\n            }\r\n            pool.push({\r\n                // +1 for the implicit null value of every enum\r\n                typeOrEnum: enumeration, size: Math.ceil(Math.log2(enumeration.__types.length + 1))\r\n            });\r\n            for (const type of enumeration.__types) {\r\n                if (enumTypes.has(type)) {\r\n                    throw new CheckError(`Component type ${type.name} is a member of more than one enum`);\r\n                }\r\n                type.enum = enumeration;\r\n                enumTypes.add(type);\r\n            }\r\n        }\r\n        for (const type of this.types) {\r\n            if (!enumTypes.has(type))\r\n                pool.push({ typeOrEnum: type, size: 1 });\r\n        }\r\n        pool.sort((a, b) => b.size - a.size);\r\n        // Ensure that Alive will always be the first type allocated.\r\n        this.types.unshift(this.Alive);\r\n        pool.unshift({ typeOrEnum: this.Alive, size: 1 });\r\n        return pool;\r\n    }\r\n    removeBiggestNoLargerThan(maxSize) {\r\n        const k = this.allocationItems.findIndex(item => item.size <= maxSize);\r\n        if (k === -1)\r\n            return;\r\n        return this.allocationItems.splice(k, 1)[0];\r\n    }\r\n    releaseComponentTypes() {\r\n        for (const type of this.types)\r\n            dissimilateComponentType(type);\r\n        for (const enumeration of this.enums)\r\n            delete enumeration.__binding;\r\n    }\r\n    createEntity(initialComponents) {\r\n        const id = this.entityIdPool.take();\r\n        this.entityOrdinals[id] = this.nextEntityOrdinal++;\r\n        this.setShape(id, this.Alive);\r\n        const entity = this.pool.borrowTemporarily(id);\r\n        this.createComponents(id, initialComponents);\r\n        this.dispatcher.stats.numEntities += 1;\r\n        return entity;\r\n    }\r\n    // Everything is copied over from Entity and inlined here to keep performance from cratering.\r\n    // Just calling checkMask with 'create' kills it...\r\n    createComponents(id, initialComponents) {\r\n        for (let i = 0; i < initialComponents.length; i++) {\r\n            const type = initialComponents[i];\r\n            {\r\n                if (typeof type !== 'function') {\r\n                    throw new CheckError(`Bad arguments to createEntity: expected component type, got: ${type}`);\r\n                }\r\n                checkTypeDefined(type);\r\n                const mask = this.executingSystem?.accessMasks.create;\r\n                if (mask) {\r\n                    const binding = type.__binding;\r\n                    if (((mask[binding.shapeOffset] ?? 0) & binding.shapeMask) === 0) {\r\n                        throw new CheckError(`System ${this.executingSystem?.name} didn't mark component ${type.name} ` +\r\n                            `as createable`);\r\n                    }\r\n                }\r\n                if (type.enum) {\r\n                    if (this.getEnumShape(id, type.enum, false)) {\r\n                        throw new CheckError(`Can't add multiple components from the same enum when creating entity: ` +\r\n                            type.name);\r\n                    }\r\n                }\r\n                else if (this.hasShape(id, type, false)) {\r\n                    throw new CheckError(`Duplicate ${type.name} component when creating entity`);\r\n                }\r\n            }\r\n            let value = initialComponents[i + 1];\r\n            if (typeof value === 'function')\r\n                value = undefined;\r\n            else\r\n                i++;\r\n            this.setShape(id, type);\r\n            this.dispatcher.stats.forComponent(type).numEntities += 1;\r\n            initComponent(type, id, value);\r\n        }\r\n    }\r\n    flush() {\r\n        const lastExecutingSystem = this.executingSystem;\r\n        this.includeRecentlyDeleted = false;\r\n        this.validateShapes(lastExecutingSystem);\r\n        this.executingSystem = undefined;\r\n        this.pool.returnTemporaryBorrows();\r\n        this.removalLog.commit();\r\n    }\r\n    completeCycle() {\r\n        this.processRemovalLog();\r\n        this.invalidateDeletedHeldEntities();\r\n    }\r\n    validateShapes(system) {\r\n        this.executingSystem = this.validateSystem;\r\n        for (const entityId of this.reshapedEntityIds) {\r\n            for (const componentType of this.validators) {\r\n                try {\r\n                    componentType.validate(this.pool.borrowTemporarily(entityId));\r\n                }\r\n                catch (e) {\r\n                    if (!SYSTEM_ERROR_TYPES.includes(e.constructor)) {\r\n                        const systemSuffix = system ? ` after system ${system.name} executed` : '';\r\n                        const componentNames = this.types\r\n                            .filter(type => type !== this.Alive && this.hasShape(entityId, type, false))\r\n                            .map(type => type.name)\r\n                            .join(', ') || 'none';\r\n                        e.message =\r\n                            `An entity failed to satisfy ${componentType.name}.validate${systemSuffix}: ` +\r\n                                `${e.message} (components: ${componentNames})`;\r\n                    }\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        this.reshapedEntityIds.length = 0;\r\n    }\r\n    processRemovalLog() {\r\n        const indexer = this.dispatcher.indexer;\r\n        this.removalLog.commit();\r\n        this.entityIdPool.mark();\r\n        let numDeletedEntities = 0;\r\n        let log, startIndex, endIndex;\r\n        {\r\n            this.dispatcher.stats.maxLimboComponents =\r\n                this.removalLog.countSince(this.removalLog.copyPointer(this.oldRemovalPointer));\r\n        }\r\n        while (true) {\r\n            [log, startIndex, endIndex] =\r\n                this.removalLog.processSince(this.oldRemovalPointer, this.prevRemovalPointer);\r\n            if (!log)\r\n                break;\r\n            for (let i = startIndex; i < endIndex; i++) {\r\n                const entry = log[i];\r\n                const entityId = (entry & ENTITY_ID_MASK);\r\n                const componentId = (entry >>> ENTITY_ID_BITS) & COMPONENT_ID_MASK;\r\n                const type = this.types[componentId];\r\n                if (!this.shapes.isSet(entityId, type) && !this.removedShapes.isSet(entityId, type)) {\r\n                    this.staleShapes.unset(entityId, type);\r\n                    if (type === this.Alive) {\r\n                        indexer.clearAllRefs(entityId, true);\r\n                        this.entityIdPool.return(entityId);\r\n                        numDeletedEntities += 1;\r\n                    }\r\n                    else {\r\n                        this.clearRefs(entityId, type, true);\r\n                    }\r\n                    type.__free?.(entityId);\r\n                    this.removedShapes.set(entityId, type);\r\n                }\r\n            }\r\n        }\r\n        this.dispatcher.stats.numEntities -= numDeletedEntities;\r\n        this.removedShapes.clear();\r\n        this.removalLog.createPointer(this.prevRemovalPointer);\r\n    }\r\n    invalidateDeletedHeldEntities() {\r\n        let index = 0;\r\n        let entityId;\r\n        while ((entityId = this.entityIdPool.peekSinceMark(index++)) !== undefined) {\r\n            const entity = this.heldEntities[entityId];\r\n            if (entity) {\r\n                entity.__valid = false;\r\n                delete this.heldEntities[entityId];\r\n            }\r\n        }\r\n    }\r\n    holdEntity(id) {\r\n        let entity;\r\n        entity = this.heldEntities[id];\r\n        if (!entity) {\r\n            entity = new EntityImpl(this);\r\n            entity.__id = id;\r\n            this.heldEntities[id] = entity;\r\n        }\r\n        return entity;\r\n    }\r\n    hasShape(id, type, allowRecentlyDeleted) {\r\n        if (this.shapes.isSet(id, type))\r\n            return true;\r\n        if (allowRecentlyDeleted && this.includeRecentlyDeleted &&\r\n            this.staleShapes.isSet(id, type))\r\n            return true;\r\n        return false;\r\n    }\r\n    getEnumShape(id, enumeration, allowRecentlyDeleted) {\r\n        let index = this.shapes.get(id, enumeration);\r\n        if (index === 0 && allowRecentlyDeleted && this.includeRecentlyDeleted) {\r\n            index = this.staleShapes.get(id, enumeration);\r\n        }\r\n        if (index > 0)\r\n            return enumeration.__types[index - 1];\r\n    }\r\n    setShape(id, type) {\r\n        if (type.enum) {\r\n            const oldType = this.getEnumShape(id, type.enum, false);\r\n            if (oldType)\r\n                this.clearShape(id, oldType);\r\n        }\r\n        this.shapes.set(id, type);\r\n        this.staleShapes.set(id, type);\r\n        this.reshapedEntityIds.push(id);\r\n        if (type !== this.Alive || this.hasNegativeQueries) {\r\n            this.dispatcher.shapeLog.push(id | (type.id << ENTITY_ID_BITS), type);\r\n        }\r\n    }\r\n    clearShape(id, type) {\r\n        this.clearRefs(id, type, false);\r\n        this.shapes.unset(id, type);\r\n        this.removedShapes.set(id, type);\r\n        this.reshapedEntityIds.push(id);\r\n        const logEntry = id | (type.id << ENTITY_ID_BITS);\r\n        this.removalLog.push(logEntry);\r\n        if (type !== this.Alive || this.hasNegativeQueries) {\r\n            this.dispatcher.shapeLog.push(logEntry, type);\r\n        }\r\n        this.dispatcher.stats.forComponent(type).numEntities -= 1;\r\n    }\r\n    trackWrite(id, type) {\r\n        this.dispatcher.writeLog.push(id | (type.id << ENTITY_ID_BITS), type);\r\n    }\r\n    clearRefs(id, type, final) {\r\n        const hasRefs = !!type.__binding.refFields.length;\r\n        if (hasRefs) {\r\n            type.__bind(id, true);\r\n            for (const field of type.__binding.refFields)\r\n                field.clearRef(final);\r\n        }\r\n    }\r\n    matchShape(id, positiveMask, positiveValues, trackingMasks, negativeMask, negativeTypes) {\r\n        if (positiveMask && positiveValues && !this.shapes.match(id, positiveMask, positiveValues)) {\r\n            return false;\r\n        }\r\n        if (negativeMask && !this.shapes.matchNot(id, negativeMask))\r\n            return false;\r\n        if (negativeTypes) {\r\n            for (const type of negativeTypes)\r\n                if (this.shapes.isSet(id, type))\r\n                    return false;\r\n        }\r\n        if (trackingMasks) {\r\n            for (const trackingMask of trackingMasks) {\r\n                if (trackingMask.lastMatches) {\r\n                    if (!this.shapes.matchAny(id, trackingMask))\r\n                        return false;\r\n                }\r\n                else if (this.shapes.matchNot(id, trackingMask.mask)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\n\nconst ALPHA = 0.05;\r\nfunction computeMovingAverage(average, value) {\r\n    return value * ALPHA + average * (1 - ALPHA);\r\n}\r\nclass ComponentStats {\r\n    type;\r\n    _numEntities = 0;\r\n    maxEntities = 0;\r\n    capacity = 0;\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n    get numEntities() {\r\n        return this._numEntities;\r\n    }\r\n    set numEntities(value) {\r\n        this._numEntities = value;\r\n        if (value > this.maxEntities)\r\n            this.maxEntities = value;\r\n    }\r\n    toString() {\r\n        /* eslint-disable max-len */\r\n        return `${this.numEntities.toLocaleString()} of ${this.maxEntities.toLocaleString()} peak (capacity ${this.capacity.toLocaleString()})`;\r\n        /* eslint-enable max-len */\r\n    }\r\n}\r\nclass SystemStats {\r\n    type;\r\n    worker; // -1 means replicated to all workers\r\n    _lastQueryUpdateDuration = 0;\r\n    averageQueryUpdateDuration = 0;\r\n    _lastExecutionDuration = 0;\r\n    averageExecutionDuration = 0;\r\n    _lastCoroutinesDuration = 0;\r\n    averageCoroutinesDuration = 0;\r\n    constructor(type) {\r\n        this.type = type;\r\n    }\r\n    get lastQueryUpdateDuration() {\r\n        return this._lastQueryUpdateDuration;\r\n    }\r\n    set lastQueryUpdateDuration(value) {\r\n        this._lastQueryUpdateDuration = value;\r\n        this.averageQueryUpdateDuration = computeMovingAverage(this.averageQueryUpdateDuration, value);\r\n    }\r\n    get lastExecutionDuration() {\r\n        return this._lastExecutionDuration;\r\n    }\r\n    set lastExecutionDuration(value) {\r\n        this._lastExecutionDuration = value;\r\n        this.averageExecutionDuration = computeMovingAverage(this.averageExecutionDuration, value);\r\n    }\r\n    get lastCoroutinesDuration() {\r\n        return this._lastCoroutinesDuration;\r\n    }\r\n    set lastCoroutinesDuration(value) {\r\n        this._lastCoroutinesDuration = value;\r\n        this.averageCoroutinesDuration = computeMovingAverage(this.averageCoroutinesDuration, value);\r\n    }\r\n}\r\nclass Stats {\r\n    frames = 0;\r\n    _numEntities = 0;\r\n    _maxEntities = 0;\r\n    _maxLimboComponents = 0;\r\n    _maxRefChangesPerFrame = 0;\r\n    _maxShapeChangesPerFrame = 0;\r\n    _maxWritesPerFrame = 0;\r\n    components = Object.create(null);\r\n    systems = Object.create(null);\r\n    get maxEntities() {\r\n        return this._maxEntities;\r\n    }\r\n    get numEntities() {\r\n        return this._numEntities;\r\n    }\r\n    set numEntities(value) {\r\n        this._numEntities = value;\r\n        if (value > this._maxEntities)\r\n            this._maxEntities = value;\r\n    }\r\n    get maxLimboComponents() {\r\n        return this._maxLimboComponents;\r\n    }\r\n    set maxLimboComponents(value) {\r\n        if (value > this._maxLimboComponents)\r\n            this._maxLimboComponents = value;\r\n    }\r\n    get maxRefChangesPerFrame() {\r\n        return this._maxRefChangesPerFrame;\r\n    }\r\n    set maxRefChangesPerFrame(value) {\r\n        if (value > this._maxRefChangesPerFrame)\r\n            this._maxRefChangesPerFrame = value;\r\n    }\r\n    get maxShapeChangesPerFrame() {\r\n        return this._maxShapeChangesPerFrame;\r\n    }\r\n    set maxShapeChangesPerFrame(value) {\r\n        if (value > this._maxShapeChangesPerFrame)\r\n            this._maxShapeChangesPerFrame = value;\r\n    }\r\n    get maxWritesPerFrame() {\r\n        return this._maxWritesPerFrame;\r\n    }\r\n    set maxWritesPerFrame(value) {\r\n        if (value > this._maxWritesPerFrame)\r\n            this._maxWritesPerFrame = value;\r\n    }\r\n    forComponent(type) {\r\n        const componentStats = this.components[type.name] ?? new ComponentStats(type);\r\n        if (!type.__internal)\r\n            this.components[type.name] = componentStats;\r\n        return componentStats;\r\n    }\r\n    forSystem(type) {\r\n        const systemStats = this.systems[type.name] ?? new SystemStats(type);\r\n        if (!type.__internal)\r\n            this.systems[type.name] = systemStats;\r\n        return systemStats;\r\n    }\r\n    toString() {\r\n        /* eslint-disable max-len */\r\n        return `World stats:\n  frames: ${this.frames.toLocaleString()}\n  entities: ${this.numEntities.toLocaleString()} of ${this.maxEntities.toLocaleString()} max\n  refs: ${this.maxRefChangesPerFrame.toLocaleString()} ref changes/frame max\n  logs: ${this.maxShapeChangesPerFrame.toLocaleString()} shape changes/frame max, ${this.maxWritesPerFrame.toLocaleString()} writes/frame max\n  components: (${this.maxLimboComponents.toLocaleString()} limbo max)\\n` +\r\n            Object.keys(this.components).map(name => {\r\n                const compStats = this.components[name];\r\n                return `    ${name}: ${compStats.numEntities} (max ${compStats.maxEntities})`;\r\n            }).join('\\n');\r\n        /* eslint-enable max-len */\r\n    }\r\n}\n\nvar Action;\r\n(function (Action) {\r\n    Action[Action[\"REFERENCE\"] = 0] = \"REFERENCE\";\r\n    Action[Action[\"UNREFERENCE\"] = 1073741824] = \"UNREFERENCE\";\r\n    Action[Action[\"RELEASE\"] = 2147483648] = \"RELEASE\";\r\n    Action[Action[\"UNREFERENCE_AND_RELEASE\"] = -1073741824] = \"UNREFERENCE_AND_RELEASE\";\r\n})(Action || (Action = {}));\r\nconst ACTION_MASK = Action.UNREFERENCE_AND_RELEASE;\r\nclass Tracker {\r\n    targetEntityId;\r\n    selector;\r\n    trackStale;\r\n    dispatcher;\r\n    entities = [];\r\n    tags;\r\n    entityIndex;\r\n    clearing = false;\r\n    registry;\r\n    constructor(targetEntityId, selector, trackStale, dispatcher) {\r\n        this.targetEntityId = targetEntityId;\r\n        this.selector = selector;\r\n        this.trackStale = trackStale;\r\n        this.dispatcher = dispatcher;\r\n        const binding = selector.sourceType?.__binding;\r\n        const precise = selector.matchType && (selector.matchSeq && !binding.fields[selector.sourceSeq].type.internallyIndexed ||\r\n            binding.refFields.length === 1 && !binding.refFields[0].type.internallyIndexed);\r\n        if (!precise)\r\n            this.tags = [];\r\n        this.registry = dispatcher.registry;\r\n    }\r\n    clearAllRefs(final) {\r\n        if (!this.tags)\r\n            throw new InternalError('Unreferencing an untagged tracker');\r\n        this.clearing = true;\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            const entityId = this.entities[i].__id;\r\n            const set = this.tags[i];\r\n            if (typeof set === 'number') {\r\n                this.clearRef(entityId, set, final);\r\n            }\r\n            else {\r\n                for (const tag of set)\r\n                    this.clearRef(entityId, tag, final);\r\n            }\r\n        }\r\n        this.entities = [];\r\n        if (this.tags)\r\n            this.tags = [];\r\n        this.entityIndex = undefined;\r\n        this.clearing = false;\r\n    }\r\n    clearRef(sourceId, tag, final) {\r\n        const sourceTypeId = tag & COMPONENT_ID_MASK;\r\n        const sourceSeq = (tag >>> COMPONENT_ID_BITS) & FIELD_SEQ_MASK;\r\n        const internalIndex = tag >>> (COMPONENT_ID_BITS + FIELD_SEQ_BITS);\r\n        const sourceType = this.registry.types[sourceTypeId];\r\n        checkMask(sourceType, this.registry.executingSystem, 'write');\r\n        sourceType.__bind(sourceId, true);\r\n        sourceType.__binding.fields[sourceSeq].clearRef(final, this.targetEntityId, internalIndex);\r\n    }\r\n    trackReference(entityId, typeId, fieldSeq, internalIndex, trackChanges) {\r\n        if (this.clearing) {\r\n            throw new InternalError('Cannot track a new reference while clearing tracker');\r\n        }\r\n        if (trackChanges)\r\n            this.checkUpdateMask();\r\n        let index = this.getEntityIndex(entityId);\r\n        if (index === undefined)\r\n            index = this.addEntity(entityId, trackChanges);\r\n        this.addTag(index, this.makeTag(typeId, fieldSeq, internalIndex));\r\n    }\r\n    trackUnreference(entityId, typeId, fieldSeq, internalIndex, trackChanges) {\r\n        if (this.clearing)\r\n            return;\r\n        if (trackChanges)\r\n            this.checkUpdateMask();\r\n        const index = this.getEntityIndex(entityId);\r\n        if (index === undefined)\r\n            throw new InternalError('Entity backref not tracked');\r\n        const empty = this.removeTag(index, this.makeTag(typeId, fieldSeq, internalIndex));\r\n        if (empty)\r\n            this.removeEntity(index, entityId, trackChanges);\r\n    }\r\n    getEntityIndex(entityId) {\r\n        if (this.entityIndex)\r\n            return this.entityIndex[entityId];\r\n        const k = this.entities.findIndex(entity => entity.__id === entityId);\r\n        if (k >= 0)\r\n            return k;\r\n    }\r\n    indexEntities() {\r\n        if (this.entityIndex)\r\n            throw new InternalError('Entities already indexed');\r\n        this.entityIndex = new Array(this.dispatcher.maxEntities);\r\n        for (let i = 0; i < this.entities.length; i++) {\r\n            this.entityIndex[this.entities[i].__id] = i;\r\n        }\r\n    }\r\n    addTag(index, tag) {\r\n        if (!this.tags)\r\n            return;\r\n        const set = this.tags[index];\r\n        if (set === undefined) {\r\n            this.tags[index] = tag;\r\n        }\r\n        else if (typeof set === 'number') {\r\n            if (set === tag)\r\n                throw new InternalError(`Ref ${tag} already tracked (single)`);\r\n            this.tags[index] = [set, tag];\r\n        }\r\n        else if (Array.isArray(set)) {\r\n            if (set.includes(tag))\r\n                throw new InternalError(`Ref ${tag} already tracked (array)`);\r\n            if (set.length >= 1000) {\r\n                const actualSet = this.tags[index] = new Set(set);\r\n                actualSet.add(tag);\r\n            }\r\n            else {\r\n                set.push(tag);\r\n            }\r\n        }\r\n        else {\r\n            if (set.has(tag))\r\n                throw new InternalError(`Ref ${tag} already tracked (set)`);\r\n            set.add(tag);\r\n        }\r\n    }\r\n    removeTag(index, tag) {\r\n        if (!this.tags)\r\n            return true; // precise mode\r\n        const set = this.tags[index];\r\n        if (set === undefined)\r\n            throw new InternalError(`Ref ${tag} not tracked (none)`);\r\n        if (typeof set === 'number') {\r\n            if (set !== tag)\r\n                throw new InternalError(`Ref ${tag} not tracked (single ${set})`);\r\n            delete this.tags[index];\r\n            return true;\r\n        }\r\n        if (Array.isArray(set)) {\r\n            const k = set.indexOf(tag);\r\n            if (k === -1)\r\n                throw new InternalError(`Ref ${tag} not tracked (array ${set})`);\r\n            set.splice(k, 1);\r\n            return !this.tags.length;\r\n        }\r\n        if (!set.has(tag)) {\r\n            throw new InternalError(`Ref ${tag} not tracked (set ${new Array(...set)})`);\r\n        }\r\n        set.delete(tag);\r\n        return !set.size;\r\n    }\r\n    makeTag(typeId, fieldSeq, internalIndex) {\r\n        return typeId | (fieldSeq << COMPONENT_ID_BITS) |\r\n            (internalIndex === undefined ? 0 : (internalIndex << (COMPONENT_ID_BITS + FIELD_SEQ_BITS)));\r\n    }\r\n    addEntity(entityId, trackChanges) {\r\n        const index = this.entities.length;\r\n        this.entities.push(this.registry.pool.borrow(entityId));\r\n        if (this.entityIndex) {\r\n            this.entityIndex[entityId] = index;\r\n        }\r\n        else if (index > 100) {\r\n            this.indexEntities();\r\n        }\r\n        if (trackChanges)\r\n            this.trackBackrefsChange();\r\n        return index;\r\n    }\r\n    removeEntity(index, entityId, trackChanges) {\r\n        this.registry.pool.return(entityId);\r\n        const lastEntity = this.entities.pop();\r\n        if (this.entityIndex)\r\n            delete this.entityIndex[entityId];\r\n        if (this.entities.length > index) {\r\n            this.entities[index] = lastEntity;\r\n            if (this.entityIndex)\r\n                this.entityIndex[lastEntity.__id] = index;\r\n        }\r\n        if (this.tags) {\r\n            const lastTag = this.tags.pop();\r\n            if (this.tags.length > index)\r\n                this.tags[index] = lastTag;\r\n        }\r\n        if (trackChanges)\r\n            this.trackBackrefsChange();\r\n    }\r\n    trackBackrefsChange() {\r\n        for (const targetType of this.selector.targetTypes) {\r\n            if (targetType.__binding.trackedWrites) {\r\n                this.registry.trackWrite(this.targetEntityId, targetType);\r\n            }\r\n        }\r\n    }\r\n    checkUpdateMask() {\r\n        const system = this.registry.executingSystem;\r\n        for (const targetType of this.selector.targetTypes) {\r\n            if (this.registry.hasShape(this.targetEntityId, targetType, this.trackStale)) {\r\n                checkMask(targetType, system, 'update');\r\n            }\r\n        }\r\n    }\r\n}\r\nclass RefIndexer {\r\n    dispatcher;\r\n    maxRefChangesPerFrame;\r\n    refLog;\r\n    refLogPointer;\r\n    refLogStatsPointer;\r\n    selectorIdsBySourceKey = new Map();\r\n    selectors = [];\r\n    trackers = new Map();\r\n    registry;\r\n    constructor(dispatcher, maxRefChangesPerFrame) {\r\n        this.dispatcher = dispatcher;\r\n        this.maxRefChangesPerFrame = maxRefChangesPerFrame;\r\n        this.registry = dispatcher.registry;\r\n    }\r\n    completeCycle() {\r\n        this.flush(); // to handle ref changes coming from registry.processEndOfFrame()\r\n        this.dispatcher.stats.maxRefChangesPerFrame =\r\n            this.refLog?.countSince(this.refLogStatsPointer) ?? 0;\r\n    }\r\n    registerSelector(targetType, sourceType, sourceFieldSeq, trackStale = false) {\r\n        if (targetType)\r\n            checkTypeDefined(targetType);\r\n        if (sourceType)\r\n            checkTypeDefined(sourceType);\r\n        if (!this.refLog) {\r\n            this.refLog = new Log(this.maxRefChangesPerFrame, 'maxRefChangesPerFrame', this.dispatcher.buffers, { localProcessingAllowed: true });\r\n            this.refLogPointer = this.refLog.createPointer();\r\n            this.refLogStatsPointer = this.refLog.createPointer();\r\n        }\r\n        const selectorSourceKey = sourceType ?\r\n            (sourceFieldSeq === undefined ?\r\n                -2 - sourceType.id : sourceType.id | (sourceFieldSeq << COMPONENT_ID_BITS)) : -1;\r\n        let selectorId = this.selectorIdsBySourceKey.get(selectorSourceKey);\r\n        if (selectorId === undefined) {\r\n            // Always track stale refs on the global selector.\r\n            if (!this.selectors.length)\r\n                trackStale = true;\r\n            const selector = {\r\n                id: this.selectors.length, targetTypes: targetType ? [targetType] : [], sourceType,\r\n                matchType: !!sourceType, matchSeq: sourceFieldSeq !== undefined,\r\n                sourceTypeId: sourceType?.id, sourceSeq: sourceFieldSeq, trackStale\r\n            };\r\n            this.selectors.push(selector);\r\n            selectorId = selector.id;\r\n            this.selectorIdsBySourceKey.set(selectorSourceKey, selectorId);\r\n            if (selectorId > MAX_NUM_COMPONENTS) {\r\n                throw new CheckError(`Too many distinct backrefs selectors`);\r\n            }\r\n        }\r\n        else {\r\n            const selector = this.selectors[selectorId];\r\n            selector.trackStale = selector.trackStale || trackStale;\r\n            if (targetType)\r\n                selector.targetTypes.push(targetType);\r\n        }\r\n        return selectorId;\r\n    }\r\n    getBackrefs(entityId, selectorId = 0) {\r\n        const selector = this.selectors[selectorId];\r\n        return this.getOrCreateTracker(selector, entityId, this.registry.includeRecentlyDeleted).entities;\r\n    }\r\n    trackRefChange(sourceId, sourceType, sourceSeq, sourceInternalIndex, oldTargetId, newTargetId, unreference, release) {\r\n        if (!this.refLog)\r\n            throw new InternalError(`Trying to trackRefChange without a refLog`);\r\n        if (oldTargetId === newTargetId && unreference) {\r\n            throw new InternalError('No-op call to trackRefChange');\r\n        }\r\n        if (oldTargetId !== -1) {\r\n            const action = (unreference ? Action.UNREFERENCE : 0) | (release ? Action.RELEASE : 0);\r\n            if (!action) {\r\n                throw new InternalError('Called trackRefChange with neither unreference nor release');\r\n            }\r\n            this.pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, oldTargetId, action);\r\n        }\r\n        if (newTargetId !== -1) {\r\n            this.pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, newTargetId, Action.REFERENCE);\r\n        }\r\n    }\r\n    clearAllRefs(targetId, final) {\r\n        if (!this.selectors.length)\r\n            return;\r\n        this.getTracker(this.selectors[0], targetId, final)?.clearAllRefs(final);\r\n    }\r\n    pushRefLogEntry(sourceId, sourceType, sourceSeq, sourceInternalIndex, targetId, action) {\r\n        const internallyIndexed = typeof sourceInternalIndex !== 'undefined';\r\n        {\r\n            if (internallyIndexed && !sourceType.__binding.fields[sourceSeq].type.internallyIndexed) {\r\n                throw new InternalError('Inconsistent internally indexed flag');\r\n            }\r\n        }\r\n        this.refLog.push(sourceId | (sourceType.id << ENTITY_ID_BITS));\r\n        this.refLog.push(targetId | (sourceSeq << ENTITY_ID_BITS) | action | (internallyIndexed ? 2 ** 29 : 0));\r\n        if (internallyIndexed)\r\n            this.refLog.push(sourceInternalIndex);\r\n        this.processEntry(sourceId, sourceType.id, sourceSeq, sourceInternalIndex, targetId, action, true);\r\n    }\r\n    getOrCreateTracker(selector, targetId, stale) {\r\n        let tracker = this.getTracker(selector, targetId, stale);\r\n        if (tracker)\r\n            return tracker;\r\n        if (stale && !selector.trackStale) {\r\n            throw new InternalError('Selector not configured for stale tracking');\r\n        }\r\n        let staleTracker;\r\n        tracker = new Tracker(targetId, selector, false, this.dispatcher);\r\n        this.trackers.set(targetId | (selector.id << ENTITY_ID_BITS), tracker);\r\n        if (selector.trackStale) {\r\n            staleTracker = new Tracker(targetId, selector, true, this.dispatcher);\r\n            this.trackers.set(targetId | (selector.id << ENTITY_ID_BITS) | 2 ** 31, staleTracker);\r\n        }\r\n        return stale ? staleTracker : tracker;\r\n    }\r\n    getTracker(selector, targetId, stale) {\r\n        return this.trackers.get(targetId | (selector.id << ENTITY_ID_BITS) | (stale ? 2 ** 31 : 0));\r\n    }\r\n    flush() {\r\n        if (!this.refLog)\r\n            return;\r\n        while (true) {\r\n            const [log, startIndex, endIndex, local] = this.refLog.processAndCommitSince(this.refLogPointer);\r\n            if (!log)\r\n                break;\r\n            if (local)\r\n                continue;\r\n            for (let i = startIndex; i < endIndex; i += 2) {\r\n                const entryPart1 = log[i], entryPart2 = log[i + 1];\r\n                const sourceId = (entryPart1 & ENTITY_ID_MASK);\r\n                const sourceTypeId = entryPart1 >>> ENTITY_ID_BITS;\r\n                const targetId = (entryPart2 & ENTITY_ID_MASK);\r\n                const sourceSeq = (entryPart2 >>> ENTITY_ID_BITS) & (MAX_NUM_FIELDS - 1);\r\n                const action = entryPart2 & ACTION_MASK;\r\n                const internallyIndexed = (entryPart2 & 2 ** 29) !== 0;\r\n                const internalIndex = internallyIndexed ? log[i + 2] : undefined;\r\n                if (internallyIndexed)\r\n                    i += 1;\r\n                this.processEntry(sourceId, sourceTypeId, sourceSeq, internalIndex, targetId, action, false);\r\n            }\r\n        }\r\n    }\r\n    processEntry(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, targetId, action, local) {\r\n        for (let j = 0; j < this.selectors.length; j++) {\r\n            const selector = this.selectors[j];\r\n            if ((!selector.matchType || selector.sourceTypeId === sourceTypeId) &&\r\n                (!selector.matchSeq || selector.sourceSeq === sourceSeq)) {\r\n                if (action === Action.REFERENCE || action & Action.UNREFERENCE) {\r\n                    const tracker = this.getOrCreateTracker(selector, targetId, false);\r\n                    if (action === Action.REFERENCE) {\r\n                        tracker.trackReference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);\r\n                    }\r\n                    else {\r\n                        tracker.trackUnreference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);\r\n                    }\r\n                }\r\n                if (selector.trackStale && (action === Action.REFERENCE || action & Action.RELEASE)) {\r\n                    const tracker = this.getOrCreateTracker(selector, targetId, true);\r\n                    if (action === Action.REFERENCE) {\r\n                        tracker.trackReference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);\r\n                    }\r\n                    else {\r\n                        tracker.trackUnreference(sourceId, sourceTypeId, sourceSeq, sourceInternalIndex, local);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\n\nclass Item {\r\n    buffer;\r\n    array;\r\n    update;\r\n}\r\nconst arrayTypeToKind = new Map([\r\n    [Uint8Array, 'u8'], [Int8Array, 'i8'], [Uint16Array, 'u16'], [Int16Array, 'i16'],\r\n    [Uint32Array, 'u32'], [Int32Array, 'i32'], [Float32Array, 'f32'], [Float64Array, 'f64']\r\n]);\r\nconst arrayKindToType = new Map([\r\n    ['u8', Uint8Array], ['i8', Int8Array], ['u16', Uint16Array], ['i16', Int16Array],\r\n    ['u32', Uint32Array], ['i32', Int32Array], ['f32', Float32Array], ['f64', Float64Array]\r\n]);\r\nclass Buffers {\r\n    threaded;\r\n    items = new Map();\r\n    changes;\r\n    constructor(threaded) {\r\n        this.threaded = threaded;\r\n    }\r\n    register(key, length, ArrayType, update, filler) {\r\n        const size = length * ArrayType.BYTES_PER_ELEMENT;\r\n        let item = this.items.get(key);\r\n        const needBiggerBuffer = !item || item.buffer.byteLength < size;\r\n        const needNewArray = needBiggerBuffer || item.array.constructor !== ArrayType;\r\n        if (!item || needBiggerBuffer || needNewArray) {\r\n            const newItem = new Item();\r\n            newItem.buffer = needBiggerBuffer ?\r\n                (this.threaded ? new SharedArrayBuffer(size) : new ArrayBuffer(size)) : item.buffer;\r\n            newItem.array = new ArrayType(newItem.buffer);\r\n            if (item) {\r\n                newItem.array.set(item.array);\r\n                if (filler !== undefined && newItem.array.length > item.array.length) {\r\n                    newItem.array.fill(filler, item.array.length);\r\n                }\r\n            }\r\n            else if (filler !== undefined) {\r\n                newItem.array.fill(filler);\r\n            }\r\n            item = newItem;\r\n            this.items.set(key, item);\r\n            if (this.threaded) {\r\n                if (!this.changes)\r\n                    this.changes = new Map();\r\n                this.changes.set(key, {\r\n                    buffer: item.buffer, arrayKind: arrayTypeToKind.get(ArrayType)\r\n                });\r\n            }\r\n            update?.(item.array);\r\n        }\r\n        item.update = update;\r\n        return item.array;\r\n    }\r\n    makePatch() {\r\n        if (!this.changes)\r\n            return;\r\n        const patch = this.changes;\r\n        this.changes = undefined;\r\n        return patch;\r\n    }\r\n    applyPatch(patch) {\r\n        for (const [key, patchItem] of patch.entries()) {\r\n            const item = new Item();\r\n            item.update = this.items.get(key)?.update;\r\n            item.buffer = patchItem.buffer;\r\n            const ArrayType = arrayKindToType.get(patchItem.arrayKind);\r\n            item.array = new ArrayType(item.buffer);\r\n            this.items.set(key, item);\r\n            item.update?.(item.array);\r\n        }\r\n    }\r\n}\n\nfunction addFieldSchema(options, target, name) {\r\n    if (!target.constructor.schema)\r\n        target.constructor.schema = {};\r\n    target.constructor.schema[name] = options;\r\n}\r\nfunction field(practicalOptions) {\r\n    return function (target, name) {\r\n        const options = 'type' in practicalOptions ? practicalOptions : { type: practicalOptions };\r\n        addFieldSchema(options, target, name);\r\n    };\r\n}\r\nfunction makeVectorDecorator(type) {\r\n    const fn = addFieldSchema.bind(null, { type });\r\n    fn.vector =\r\n        (elements, Class) => (target, name) => {\r\n            addFieldSchema({ type: Type.vector(type, elements, Class) }, target, name);\r\n        };\r\n    return fn;\r\n}\r\nfunction backrefs(...args) {\r\n    if (typeof args[0] === 'function' || args[0] === undefined) {\r\n        return addFieldSchema.bind(null, { type: Type.backrefs(...args) });\r\n    }\r\n    addFieldSchema({ type: Type.backrefs }, args[0], args[1]);\r\n}\r\nfield.boolean = addFieldSchema.bind(null, { type: Type.boolean });\r\nfield.uint8 = makeVectorDecorator(Type.uint8);\r\nfield.int8 = makeVectorDecorator(Type.int8);\r\nfield.uint16 = makeVectorDecorator(Type.uint16);\r\nfield.int16 = makeVectorDecorator(Type.int16);\r\nfield.uint32 = makeVectorDecorator(Type.uint32);\r\nfield.int32 = makeVectorDecorator(Type.int32);\r\nfield.float32 = makeVectorDecorator(Type.float32);\r\nfield.float64 = makeVectorDecorator(Type.float64);\r\nfield.staticString = function (choices) {\r\n    return addFieldSchema.bind(null, { type: Type.staticString(choices) });\r\n};\r\nfield.dynamicString = function (maxUtf8Length) {\r\n    return addFieldSchema.bind(null, { type: Type.dynamicString(maxUtf8Length) });\r\n};\r\nfield.ref = addFieldSchema.bind(null, { type: Type.ref });\r\nfield.backrefs = backrefs;\r\nfield.object = addFieldSchema.bind(null, { type: Type.object });\r\nfield.weakObject = addFieldSchema.bind(null, { type: Type.weakObject });\r\nconst componentTypes = [];\r\nfunction component(arg, options) {\r\n    if (typeof arg === 'function') {\r\n        componentTypes.push(arg);\r\n    }\r\n    else if (arg instanceof ComponentEnum) {\r\n        return (componentClass) => {\r\n            if (!arg.__types.includes(componentClass))\r\n                arg.__types.push(componentClass);\r\n            componentTypes.push(arg); // duplicates will be removed by Dispatcher\r\n            if (options)\r\n                componentClass.options = options;\r\n        };\r\n    }\r\n    else {\r\n        return (componentClass) => {\r\n            componentClass.options = arg;\r\n            componentTypes.push(componentClass);\r\n        };\r\n    }\r\n}\r\nconst systemTypes = [];\r\nfunction system(arg, scheduler) {\r\n    if (typeof arg === 'function' && !arg.__system) {\r\n        scheduler = arg;\r\n        arg = undefined;\r\n    }\r\n    if (typeof arg === 'function') {\r\n        systemTypes.push(arg);\r\n    }\r\n    else {\r\n        if (arg && !systemTypes.includes(arg))\r\n            systemTypes.push(arg);\r\n        return (systemClass) => {\r\n            if (arg)\r\n                arg.__contents.push(systemClass);\r\n            if (scheduler)\r\n                systemClass.__staticScheduler = scheduler;\r\n            systemTypes.push(systemClass);\r\n        };\r\n    }\r\n}\n\n/**\r\n * A directed graph with weighted edges and a few extra constraints:\r\n * 1. Loop edges on a single vertex are not allowed, nor are multiple edges from A to B.\r\n * 2. An edge from A to B with a higher weight will override an edge from B to A.\r\n * 3. A \"denial\" edge from A to B will similarly override lower-weight edges, but not count as an\r\n *    edge itself.  We store these with negative weights.\r\n */\r\nclass Graph {\r\n    vertices;\r\n    numVertices;\r\n    edges;\r\n    paths;\r\n    vertexIndexMap = new Map();\r\n    sealed = false;\r\n    sortedVertices;\r\n    dependencyCounts;\r\n    traversalCounts;\r\n    numTraversedVertices;\r\n    constructor(vertices) {\r\n        this.vertices = vertices;\r\n        this.numVertices = vertices.length;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            this.vertexIndexMap.set(vertices[i], i);\r\n        }\r\n        this.edges = new Array(this.numVertices ** 2).fill(0);\r\n        this.dependencyCounts = new Array(this.numVertices);\r\n        this.traversalCounts = new Array(this.numVertices);\r\n    }\r\n    get topologicallySortedVertices() {\r\n        if (!this.sealed)\r\n            throw new InternalError('Graph not yet sealed');\r\n        if (!this.sortedVertices)\r\n            this.sortedVertices = this.sortTopologically();\r\n        return this.sortedVertices;\r\n    }\r\n    getEdgeIndex(source, target) {\r\n        const sourceId = this.vertexIndexMap.get(source);\r\n        const targetId = this.vertexIndexMap.get(target);\r\n        if (sourceId === undefined)\r\n            throw new InternalError(`Unknown vertex: ${source}`);\r\n        if (targetId === undefined)\r\n            throw new InternalError(`Unknown vertex: ${target}`);\r\n        return sourceId * this.numVertices + targetId;\r\n    }\r\n    setEdge(source, target, weight) {\r\n        if (this.sealed)\r\n            throw new InternalError('Graph already sealed');\r\n        if (source === target)\r\n            return;\r\n        const sourceToTarget = this.getEdgeIndex(source, target);\r\n        const targetToSource = this.getEdgeIndex(target, source);\r\n        const absWeight = Math.abs(weight);\r\n        if (absWeight < Math.abs(this.edges[sourceToTarget]) ||\r\n            absWeight < Math.abs(this.edges[targetToSource]))\r\n            return;\r\n        this.edges[sourceToTarget] = weight;\r\n        if (absWeight > Math.abs(this.edges[targetToSource]))\r\n            this.edges[targetToSource] = 0;\r\n    }\r\n    addEdge(source, target, weight) {\r\n        if (weight <= 0)\r\n            throw new InternalError(`Edge has non-positive weight: ${weight}`);\r\n        this.setEdge(source, target, weight);\r\n    }\r\n    denyEdge(source, target, weight) {\r\n        if (weight <= 0)\r\n            throw new InternalError(`Edge has non-positive weight: ${weight}`);\r\n        this.setEdge(source, target, -weight);\r\n    }\r\n    hasEdge(source, target) {\r\n        return this.edges[this.getEdgeIndex(source, target)] > 0;\r\n    }\r\n    hasPath(source, target) {\r\n        if (!this.sealed)\r\n            throw new InternalError('Graph not yet sealed');\r\n        return this.paths[this.getEdgeIndex(source, target)] > 0;\r\n    }\r\n    hasEdgeBetweenIds(sourceId, targetId) {\r\n        if (sourceId > this.numVertices) {\r\n            throw new InternalError(`Vertex id out of range: ${sourceId} > ${this.numVertices}`);\r\n        }\r\n        if (targetId > this.numVertices) {\r\n            throw new InternalError(`Vertex id out of range: ${targetId} > ${this.numVertices}`);\r\n        }\r\n        return this.edges[sourceId * this.numVertices + targetId] > 0;\r\n    }\r\n    seal() {\r\n        if (this.sealed)\r\n            throw new InternalError('Graph already sealed');\r\n        this.sealed = true;\r\n        this.derivePaths();\r\n        this.checkForCycles();\r\n        this.simplify();\r\n        this.countDependencies();\r\n    }\r\n    checkForCycles() {\r\n        const cycles = this.findCycles();\r\n        if (cycles.length) {\r\n            cycles.sort((x, y) => x.length - y.length);\r\n            throw new CheckError('Precedence cycles detected for the following systems, ' +\r\n                'please resolve by adjusting their schedules: ' +\r\n                cycles.map(cycle => cycle.map(u => u.toString()).join('—')).join(', '));\r\n        }\r\n    }\r\n    findCycles() {\r\n        // This implements Johnson's cycle finding algorithm from\r\n        // https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\r\n        const blocked = new Array(this.numVertices).fill(false), b = [];\r\n        const stack = [], cycles = [];\r\n        let s, vertices;\r\n        for (let i = 0; i < this.numVertices; i++)\r\n            b[i] = new Set();\r\n        const unblock = (u) => {\r\n            blocked[u] = false;\r\n            for (const w of b[u]) {\r\n                b[u].delete(w);\r\n                if (blocked[w])\r\n                    unblock(w);\r\n            }\r\n        };\r\n        const circuit = (v) => {\r\n            let f = false;\r\n            stack.push(v);\r\n            blocked[v] = true;\r\n            for (let w = 0; w < this.numVertices; w++) {\r\n                if (!vertices.has(w) || !this.hasEdgeBetweenIds(v, w))\r\n                    continue;\r\n                if (w === s) {\r\n                    cycles.push(stack.map(u => this.vertices[u]));\r\n                    f = true;\r\n                }\r\n                else if (!blocked[w] && circuit(w)) {\r\n                    f = true;\r\n                }\r\n            }\r\n            if (f) {\r\n                unblock(v);\r\n            }\r\n            else {\r\n                for (let w = 0; w < this.numVertices; w++) {\r\n                    if (!vertices.has(w) || !this.hasEdgeBetweenIds(v, w))\r\n                        continue;\r\n                    b[w].add(v);\r\n                }\r\n            }\r\n            stack.pop();\r\n            return f;\r\n        };\r\n        for (s = 0; s < this.numVertices; s++) {\r\n            const componentVertices = this.findLeastStronglyConnectedComponent(s);\r\n            s = componentVertices[0];\r\n            for (const v of componentVertices) {\r\n                blocked[v] = false;\r\n                b[v].clear();\r\n            }\r\n            vertices = new Set(componentVertices);\r\n            circuit(s);\r\n        }\r\n        return cycles;\r\n    }\r\n    findLeastStronglyConnectedComponent(minId) {\r\n        // Implements the path-based strong component algorithm on the subgraph consisting of vertices\r\n        // minId through numVertices - 1.\r\n        // https://en.wikipedia.org/wiki/Path-based_strong_component_algorithm\r\n        let leastComponent;\r\n        const preorder = [], s = [], p = [];\r\n        const assigned = [];\r\n        let counter = 0;\r\n        const search = (v) => {\r\n            preorder[v] = ++counter;\r\n            s.push(v);\r\n            p.push(v);\r\n            for (let w = minId; w < this.numVertices; w++) {\r\n                if (!this.hasEdgeBetweenIds(v, w))\r\n                    continue;\r\n                if (preorder[w]) {\r\n                    if (!assigned[w]) {\r\n                        while (p.length && preorder[p[p.length - 1]] > preorder[w])\r\n                            p.pop();\r\n                    }\r\n                }\r\n                else {\r\n                    search(w);\r\n                }\r\n            }\r\n            if (p[p.length - 1] === v) {\r\n                const component = [];\r\n                while (true) {\r\n                    const w = s.pop();\r\n                    component.push(w);\r\n                    assigned[w] = true;\r\n                    if (w === v)\r\n                        break;\r\n                }\r\n                p.pop();\r\n                component.sort((a, b) => a - b);\r\n                if (!leastComponent || component[0] < leastComponent[0])\r\n                    leastComponent = component;\r\n            }\r\n        };\r\n        for (let i = minId; i < this.numVertices; i++) {\r\n            if (!preorder[i])\r\n                search(i);\r\n        }\r\n        return leastComponent;\r\n    }\r\n    induceSubgraph(subvertices) {\r\n        const subgraph = new Graph(subvertices);\r\n        for (const vertex of subvertices) {\r\n            if (!this.vertexIndexMap.has(vertex)) {\r\n                throw new InternalError(`Vertex not in graph: ${vertex}`);\r\n            }\r\n            for (const target of subvertices) {\r\n                const edgeIndex = this.getEdgeIndex(vertex, target);\r\n                const weight = this.edges[edgeIndex];\r\n                if (weight > 0) {\r\n                    subgraph.addEdge(vertex, target, weight);\r\n                }\r\n                else if (weight < 0) {\r\n                    subgraph.denyEdge(vertex, target, -weight);\r\n                }\r\n            }\r\n        }\r\n        if (this.sealed)\r\n            subgraph.seal();\r\n        return subgraph;\r\n    }\r\n    sortTopologically() {\r\n        const edgeCounts = new Array(this.numVertices).fill(0);\r\n        for (let i = 0; i < this.numVertices; i++) {\r\n            for (let j = 0; j < this.numVertices; j++) {\r\n                if (this.hasEdgeBetweenIds(i, j))\r\n                    edgeCounts[j] += 1;\r\n            }\r\n        }\r\n        const vertices = [];\r\n        let changed;\r\n        while (vertices.length < this.numVertices) {\r\n            changed = false;\r\n            for (let i = 0; i < edgeCounts.length; i++) {\r\n                if (edgeCounts[i] === 0) {\r\n                    changed = true;\r\n                    edgeCounts[i] = -1;\r\n                    vertices.push(this.vertices[i]);\r\n                    for (let j = 0; j < this.numVertices; j++) {\r\n                        if (this.hasEdgeBetweenIds(i, j))\r\n                            edgeCounts[j] -= 1;\r\n                    }\r\n                }\r\n            }\r\n            if (!changed) {\r\n                throw new InternalError('Graph has a cycle, topological sort not possible');\r\n            }\r\n        }\r\n        return vertices;\r\n    }\r\n    derivePaths() {\r\n        const n = this.numVertices;\r\n        // Remove denial edges, no longer needed\r\n        for (let i = 0; i < this.edges.length; i++) {\r\n            if (this.edges[i] < 0)\r\n                this.edges[i] = 0;\r\n        }\r\n        // console.log(this.printMatrix(this.edges));\r\n        // Derive path matrix using a variant of the Floyd-Warshall algorithm\r\n        const paths = this.edges.slice();\r\n        for (let i = 0; i < n; i++) {\r\n            for (let j = 0; j < n; j++) {\r\n                if (i === j)\r\n                    continue;\r\n                for (let k = 0; k < n; k++) {\r\n                    if (k === i || k === j)\r\n                        continue;\r\n                    const weight1 = paths[i * n + k];\r\n                    const weight2 = paths[k * n + j];\r\n                    if (weight1 && weight2) {\r\n                        const weight = Math.min(weight1, weight2);\r\n                        if (paths[i * n + j] < weight && paths[j * n + i] < weight) {\r\n                            paths[i * n + j] = weight;\r\n                            paths[j * n + i] = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.paths = paths;\r\n        // console.log(this.printMatrix(paths));\r\n        // Overwrite edge weights with stronger paths.\r\n        for (let i = 0; i < n; i++) {\r\n            for (let j = 0; j < n; j++) {\r\n                if (this.edges[i * n + j])\r\n                    this.edges[i * n + j] = paths[i * n + j];\r\n            }\r\n        }\r\n    }\r\n    simplify() {\r\n        const n = this.numVertices;\r\n        const paths = this.paths;\r\n        // Perform a transitive reduction\r\n        for (let i = 0; i < n; i++) {\r\n            for (let j = 0; j < n; j++) {\r\n                if (!this.edges[i * n + j])\r\n                    continue;\r\n                for (let k = 0; k < n; k++) {\r\n                    if (k === i || k === j)\r\n                        continue;\r\n                    if (paths[i * n + k] && paths[k * n + j])\r\n                        this.edges[i * n + j] = 0;\r\n                }\r\n            }\r\n        }\r\n        // console.log(this.printMatrix(this.edges));\r\n    }\r\n    countDependencies() {\r\n        for (let i = 0; i < this.numVertices; i++) {\r\n            let count = 0;\r\n            for (let j = 0; j < this.numVertices; j++) {\r\n                if (this.edges[j * this.numVertices + i])\r\n                    count += 1;\r\n            }\r\n            this.dependencyCounts[i] = count;\r\n        }\r\n    }\r\n    /**\r\n     * Traverses vertices of the graph based on dependency order.  When called without an argument it\r\n     * initializes (or re-initializes) the traversal and returns vertices with no dependencies.  When\r\n     * called with an argument, it marks that vertex as done and returns the vertices whose\r\n     * dependencies are all satisfied (if any).\r\n     * @param completedVertex The vertex to mark done; if missing, initializes the traversal instead.\r\n     * @returns The list of vertices whose dependencies have all been satisfied, or `undefined` if\r\n     *    this was the last vertex and the traversal is done.\r\n     */\r\n    traverse(completedVertex) {\r\n        if (!this.sealed)\r\n            throw new InternalError('Graph not yet sealed');\r\n        const traversedVertices = [];\r\n        if (completedVertex) {\r\n            this.numTraversedVertices += 1;\r\n            const sourceId = this.vertexIndexMap.get(completedVertex);\r\n            if (sourceId === undefined) {\r\n                throw new InternalError(`Unknown vertex: ${completedVertex}`);\r\n            }\r\n            for (let i = 0; i < this.numVertices; i++) {\r\n                if (this.edges[sourceId * this.numVertices + i]) {\r\n                    if (--this.traversalCounts[i] === 0) {\r\n                        traversedVertices.push(this.vertices[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.numTraversedVertices = 0;\r\n            for (let i = 0; i < this.numVertices; i++) {\r\n                const count = this.traversalCounts[i] = this.dependencyCounts[i];\r\n                if (count === 0) {\r\n                    traversedVertices.push(this.vertices[i]);\r\n                }\r\n            }\r\n        }\r\n        if (this.numTraversedVertices === this.numVertices)\r\n            return;\r\n        return traversedVertices;\r\n    }\r\n    printMatrix(matrix) {\r\n        const n = this.numVertices;\r\n        const lines = [];\r\n        for (let i = 0; i < n; i++) {\r\n            const line = [];\r\n            for (let j = 0; j < n; j++)\r\n                line.push(matrix[i * n + j]);\r\n            lines.push(line.join(' '));\r\n        }\r\n        return lines.join('\\n');\r\n    }\r\n}\n\nclass Plan {\r\n    planner;\r\n    group;\r\n    graph;\r\n    constructor(planner, group) {\r\n        this.planner = planner;\r\n        this.group = group;\r\n        this.graph = planner.graph.induceSubgraph(group.__systems);\r\n    }\r\n}\r\nclass SimplePlan extends Plan {\r\n    planner;\r\n    group;\r\n    systems;\r\n    constructor(planner, group) {\r\n        super(planner, group);\r\n        this.planner = planner;\r\n        this.group = group;\r\n        this.systems = this.graph.topologicallySortedVertices;\r\n        if (this.systems.length > 1 && (typeof process === 'undefined' || process.env.NODE_ENV === 'development')) {\r\n            console.log('System execution order:');\r\n            for (const system of this.systems)\r\n                console.log(' ', system.name);\r\n        }\r\n    }\r\n    execute(time, delta) {\r\n        const dispatcher = this.planner.dispatcher;\r\n        const systems = this.systems;\r\n        this.group.__executed = true;\r\n        for (let i = 0; i < systems.length; i++) {\r\n            const system = systems[i];\r\n            system.execute(time, delta);\r\n            dispatcher.flush();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    async initialize() {\r\n        const dispatcher = this.planner.dispatcher;\r\n        this.group.__executed = true;\r\n        return new Promise((resolve, reject) => {\r\n            let rejected = false;\r\n            const initSystem = async (system) => {\r\n                try {\r\n                    await system.prepare();\r\n                    if (rejected)\r\n                        return;\r\n                    system.initialize();\r\n                    dispatcher.flush();\r\n                    const systems = this.graph.traverse(system);\r\n                    if (!systems)\r\n                        return resolve();\r\n                    for (let i = 0; i < systems.length; i++)\r\n                        initSystem(systems[i]);\r\n                }\r\n                catch (e) {\r\n                    rejected = true;\r\n                    reject(e);\r\n                }\r\n            };\r\n            const systems = this.graph.traverse();\r\n            if (!systems)\r\n                return resolve();\r\n            for (let i = 0; i < systems.length; i++)\r\n                initSystem(systems[i]);\r\n        });\r\n    }\r\n    async finalize() {\r\n        const dispatcher = this.planner.dispatcher;\r\n        this.group.__executed = true;\r\n        return new Promise((resolve, reject) => {\r\n            const finalizeSystem = (system) => {\r\n                try {\r\n                    system.finalize();\r\n                    dispatcher.flush();\r\n                    const systems = this.graph.traverse(system);\r\n                    if (!systems)\r\n                        return resolve();\r\n                    for (let i = 0; i < systems.length; i++)\r\n                        finalizeSystem(systems[i]);\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                }\r\n            };\r\n            const systems = this.graph.traverse();\r\n            if (!systems)\r\n                return resolve();\r\n            for (let i = 0; i < systems.length; i++)\r\n                finalizeSystem(systems[i]);\r\n        });\r\n    }\r\n}\r\nclass ThreadedPlan extends Plan {\r\n    execute(time, delta) {\r\n        return Promise.resolve();\r\n    }\r\n    initialize() {\r\n        return Promise.resolve();\r\n    }\r\n    finalize() {\r\n        return Promise.resolve();\r\n    }\r\n}\r\nclass Lane {\r\n    id;\r\n    systems = [];\r\n    constructor(id) {\r\n        this.id = id;\r\n    }\r\n    add(...systems) {\r\n        for (const system of systems)\r\n            system.lane = this;\r\n        this.systems.push(...systems);\r\n    }\r\n    merge(other) {\r\n        if (this === other)\r\n            return this;\r\n        if (this.id === -1 || (other.id !== -1 && other.id < this.id))\r\n            return other.merge(this);\r\n        this.add(...other.systems);\r\n        other.systems.length = 0;\r\n        return this;\r\n    }\r\n}\r\nclass Planner {\r\n    dispatcher;\r\n    systems;\r\n    groups;\r\n    graph;\r\n    readers = new Map();\r\n    writers = new Map();\r\n    lanes = [];\r\n    replicatedLane;\r\n    laneCount = 0;\r\n    constructor(dispatcher, systems, groups) {\r\n        this.dispatcher = dispatcher;\r\n        this.systems = systems;\r\n        this.groups = groups;\r\n        this.graph = new Graph(systems);\r\n        for (const componentType of dispatcher.registry.types) {\r\n            this.readers.set(componentType, new Set());\r\n            this.writers.set(componentType, new Set());\r\n        }\r\n        if (dispatcher.threaded) {\r\n            this.createLane();\r\n            // special lane id, and don't keep this in the lanes array\r\n            this.replicatedLane = new Lane(-1);\r\n        }\r\n    }\r\n    get mainLane() {\r\n        return this.lanes[0];\r\n    }\r\n    createLane() {\r\n        const lane = new Lane(this.laneCount++);\r\n        this.lanes.push(lane);\r\n        return lane;\r\n    }\r\n    organize() {\r\n        for (const group of this.groups)\r\n            group.__collectSystems(this.dispatcher);\r\n        for (const system of this.systems)\r\n            system.buildQueries();\r\n        for (const system of this.systems)\r\n            system.buildSchedule();\r\n        for (const group of this.groups)\r\n            group.__buildSchedule();\r\n        this.addComponentEntitlementDependencies();\r\n        this.graph.seal();\r\n        if (this.dispatcher.threaded)\r\n            this.assignSystemsToLanes();\r\n        for (const system of this.systems)\r\n            system.stats.worker = system.lane?.id ?? 0;\r\n        delete this.readers;\r\n        delete this.writers;\r\n        for (const group of this.groups) {\r\n            group.__plan =\r\n                this.dispatcher.threaded ? new ThreadedPlan(this, group) : new SimplePlan(this, group);\r\n        }\r\n    }\r\n    addComponentEntitlementDependencies() {\r\n        for (const [componentType, systems] of this.readers.entries()) {\r\n            for (const reader of systems) {\r\n                for (const writer of this.writers.get(componentType)) {\r\n                    this.graph.addEdge(writer, reader, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    assignSystemsToLanes() {\r\n        this.initSystemLanes();\r\n        this.mergeAccessorsOfUnsharedComponentTypes();\r\n        this.mergeAttachedSystems();\r\n        this.pruneEmptyLanes();\r\n        this.reduceLanes(this.dispatcher.threads + 1);\r\n        this.pruneEmptyLanes();\r\n    }\r\n    initSystemLanes() {\r\n        for (const system of this.systems) {\r\n            if (!system.lane)\r\n                this.createLane().add(system);\r\n        }\r\n    }\r\n    mergeAccessorsOfUnsharedComponentTypes() {\r\n        for (const componentType of this.dispatcher.registry.types) {\r\n            if (componentType.__binding.fields.every(field => field.type.shared))\r\n                continue;\r\n            const readers = this.readers.get(componentType);\r\n            const writers = this.writers.get(componentType);\r\n            if (!readers && !writers)\r\n                continue;\r\n            let lane = componentType.options?.restrictedToMainThread ? this.mainLane : this.createLane();\r\n            readers?.forEach(system => {\r\n                lane = lane.merge(system.lane);\r\n            });\r\n            writers?.forEach(system => {\r\n                lane = lane.merge(system.lane);\r\n            });\r\n        }\r\n    }\r\n    mergeAttachedSystems() {\r\n        for (const system of this.systems) {\r\n            for (const attachedSystem of system.attachedSystems) {\r\n                if (!attachedSystem)\r\n                    continue;\r\n                system.lane.merge(attachedSystem.lane);\r\n            }\r\n        }\r\n    }\r\n    reduceLanes(maxNumLanes) {\r\n        if (this.lanes.length <= maxNumLanes)\r\n            return;\r\n        let pairs = [];\r\n        for (let i = 1; i < this.lanes.length - 1; i++) { // don't merge into lane 0 unless necessary\r\n            const laneA = this.lanes[i];\r\n            for (let j = i + 1; j < this.lanes.length; j++) {\r\n                const laneB = this.lanes[j];\r\n                pairs.push({ laneA, laneB, independence: this.computeIndependence(laneA, laneB) });\r\n            }\r\n        }\r\n        let numLanes = this.lanes.length;\r\n        while (numLanes > maxNumLanes) {\r\n            pairs.sort((pair1, pair2) => pair2.independence - pair1.independence);\r\n            const tangledPair = pairs.pop();\r\n            const combinedLane = tangledPair.laneA.merge(tangledPair.laneB);\r\n            const discardedLane = combinedLane === tangledPair.laneA ? tangledPair.laneB : tangledPair.laneA;\r\n            numLanes -= 1;\r\n            if (numLanes > maxNumLanes) {\r\n                pairs = pairs.filter(pair => {\r\n                    if (pair.laneA === discardedLane || pair.laneB === discardedLane)\r\n                        return false;\r\n                    if (pair.laneA === combinedLane || pair.laneB === combinedLane) {\r\n                        pair.independence = this.computeIndependence(pair.laneA, pair.laneB);\r\n                    }\r\n                    return true;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    computeIndependence(laneA, laneB) {\r\n        return Math.min(this.computeIndependentWeight(laneA, laneB), this.computeIndependentWeight(laneB, laneA));\r\n    }\r\n    computeIndependentWeight(lane, otherLane) {\r\n        let independentWeight = 0;\r\n        for (const system of lane.systems) {\r\n            let otherWeight = 0;\r\n            for (const otherSystem of otherLane.systems) {\r\n                if (!this.graph.hasPath(system, otherSystem) && !this.graph.hasPath(otherSystem, system)) {\r\n                    otherWeight += otherSystem.weight;\r\n                }\r\n            }\r\n            independentWeight += Math.min(system.weight, otherWeight);\r\n        }\r\n        return independentWeight;\r\n    }\r\n    pruneEmptyLanes() {\r\n        this.lanes = this.lanes.filter(lane => lane.id === 0 || lane.systems.length);\r\n        // Never prune the main thread lane.\r\n        for (let i = 1; i < this.lanes.length; i++) {\r\n            this.lanes[i].id = i;\r\n        }\r\n    }\r\n}\n\nclass Build extends System {\r\n    static __internal = true;\r\n    __callback;\r\n    start(coroutineFn, ...args) {\r\n        throw new CheckError('The build system cannot run coroutines');\r\n    }\r\n    execute() {\r\n        this.__callback(this);\r\n    }\r\n}\r\nclass Validate extends System {\r\n    static __internal = true;\r\n}\r\nvar State;\r\n(function (State) {\r\n    State[State[\"init\"] = 0] = \"init\";\r\n    State[State[\"setup\"] = 1] = \"setup\";\r\n    State[State[\"run\"] = 2] = \"run\";\r\n    State[State[\"finish\"] = 3] = \"finish\";\r\n    State[State[\"done\"] = 4] = \"done\";\r\n})(State || (State = {}));\r\nclass Dispatcher {\r\n    maxEntities;\r\n    defaultComponentStorage;\r\n    registry;\r\n    systems;\r\n    systemsByClass = new Map();\r\n    systemGroups;\r\n    default;\r\n    lastTime;\r\n    executing;\r\n    executingSyncFrame;\r\n    state = State.init;\r\n    shapeLog;\r\n    writeLog;\r\n    shapeLogFramePointer;\r\n    writeLogFramePointer;\r\n    stats;\r\n    indexer;\r\n    planner;\r\n    threads;\r\n    buffers;\r\n    singleton;\r\n    buildSystem;\r\n    deferredControls = new Map();\r\n    constructor({ defs, threads = 1, maxEntities = 10000, maxLimboComponents = Math.ceil(maxEntities / 5), maxShapeChangesPerFrame = maxEntities * 2, maxWritesPerFrame = maxEntities * 4, maxRefChangesPerFrame = maxEntities, defaultComponentStorage = 'packed' }) {\r\n        if (threads < 1)\r\n            throw new CheckError('Minimum of one thread');\r\n        if (threads > 1)\r\n            throw new CheckError('Multithreading not yet implemented');\r\n        if (maxEntities > MAX_NUM_ENTITIES) {\r\n            throw new CheckError(`maxEntities too high, the limit is ${MAX_NUM_ENTITIES}`);\r\n        }\r\n        const { componentTypes: componentTypes$1, componentEnums, systemTypes: systemTypes$1, systemGroups } = this.splitDefs([defs ?? [], componentTypes, systemTypes]);\r\n        if (componentTypes$1.length > MAX_NUM_COMPONENTS) {\r\n            throw new CheckError(`Too many component types, the limit is ${MAX_NUM_COMPONENTS}`);\r\n        }\r\n        this.stats = new Stats();\r\n        this.threads = threads;\r\n        this.buffers = new Buffers(threads > 1);\r\n        this.maxEntities = maxEntities;\r\n        this.defaultComponentStorage = defaultComponentStorage;\r\n        this.registry =\r\n            new Registry(maxEntities, maxLimboComponents, componentTypes$1, componentEnums, this);\r\n        this.indexer = new RefIndexer(this, maxRefChangesPerFrame);\r\n        this.shapeLog = new Log(maxShapeChangesPerFrame, 'maxShapeChangesPerFrame', this.buffers, { sortedByComponentType: true, numComponentTypes: this.registry.types.length });\r\n        this.shapeLogFramePointer = this.shapeLog.createPointer();\r\n        this.systemGroups = systemGroups;\r\n        this.systems = this.createSystems(systemTypes$1);\r\n        this.createBuildSystem();\r\n        this.registry.initializeComponentTypes();\r\n        this.registry.validateSystem = this.createValidateSystem(componentTypes$1);\r\n        this.singleton = this.createSingletons();\r\n        for (const box of this.systems)\r\n            box.replacePlaceholders();\r\n        this.planner = new Planner(this, this.systems, this.systemGroups);\r\n        this.planner.organize();\r\n        this.registry.hasNegativeQueries = this.systems.some(system => system.hasNegativeQueries);\r\n        if (this.systems.some(system => system.hasWriteQueries)) {\r\n            this.writeLog = new Log(maxWritesPerFrame, 'maxWritesPerFrame', this.buffers, { sortedByComponentType: true, numComponentTypes: this.registry.types.length });\r\n            this.writeLogFramePointer = this.writeLog.createPointer();\r\n        }\r\n        for (const box of this.systems)\r\n            box.finishConstructing();\r\n        this.state = State.setup;\r\n    }\r\n    get threaded() { return this.threads > 1; }\r\n    get defaultGroup() { return this.default.group; }\r\n    createSystems(systemTypes) {\r\n        const systems = [];\r\n        const systemClasses = [];\r\n        const typeNames = new Set();\r\n        let anonymousTypeCounter = 0;\r\n        for (let i = 0; i < systemTypes.length; i++) {\r\n            const SystemClass = systemTypes[i];\r\n            let box = this.systemsByClass.get(SystemClass);\r\n            if (!box) {\r\n                if (!SystemClass.name) {\r\n                    Object.defineProperty(SystemClass, 'name', { value: `Anonymous_${anonymousTypeCounter++}` });\r\n                }\r\n                if (!SystemClass.__internal) {\r\n                    if (typeNames.has(SystemClass.name)) {\r\n                        throw new CheckError(`Multiple component types named ${SystemClass.name}; names must be unique`);\r\n                    }\r\n                    typeNames.add(SystemClass.name);\r\n                }\r\n                this.stats.forSystem(SystemClass);\r\n                systemClasses.push(SystemClass);\r\n                const system = new SystemClass();\r\n                system.id = (i + 2); // 0 and 1 are reserved for internal systems\r\n                box = new SystemBox(system, this);\r\n                systems.push(box);\r\n                this.systemsByClass.set(SystemClass, box);\r\n            }\r\n            const props = systemTypes[i + 1];\r\n            if (props && typeof props !== 'function') {\r\n                box.assignProps(props);\r\n                i++;\r\n            }\r\n        }\r\n        this.default = this.createSingleGroupFrame(systemClasses);\r\n        return systems;\r\n    }\r\n    createBuildSystem() {\r\n        this.buildSystem = new Build();\r\n        this.buildSystem.id = 0;\r\n        const box = new SystemBox(this.buildSystem, this);\r\n        box.accessMasks.read = undefined;\r\n        box.accessMasks.update = undefined;\r\n        box.accessMasks.create = undefined;\r\n        box.accessMasks.write = undefined;\r\n        box.accessMasks.check = undefined;\r\n        this.systems.push(box);\r\n        this.systemsByClass.set(Build, box);\r\n    }\r\n    createValidateSystem(componentTypes) {\r\n        const system = new Validate();\r\n        system.id = 1;\r\n        const box = new SystemBox(system, this);\r\n        for (const type of componentTypes)\r\n            extendMaskAndSetFlag(box.accessMasks.check, type);\r\n        this.systems.push(box);\r\n        this.systemsByClass.set(Validate, box);\r\n        return box;\r\n    }\r\n    createSingleGroupFrame(systemTypes) {\r\n        const group = new SystemGroupImpl(systemTypes);\r\n        this.systemGroups.push(group);\r\n        const frame = new FrameImpl(this, [group]);\r\n        return { group, frame };\r\n    }\r\n    createSingletons() {\r\n        const types = new Set();\r\n        const singletonComponentDefs = this.systems.flatMap(box => {\r\n            return box.singletonComponentDefs.filter((item, i) => {\r\n                let accepted = true;\r\n                if (typeof item === 'function') {\r\n                    accepted = i < box.singletonComponentDefs.length - 1 &&\r\n                        typeof box.singletonComponentDefs[i + 1] !== 'function';\r\n                    if (accepted)\r\n                        types.add(item);\r\n                }\r\n                return accepted;\r\n            });\r\n        }).concat(this.systems.flatMap(box => {\r\n            return box.singletonComponentDefs.filter(item => {\r\n                if (typeof item === 'function' && !types.has(item)) {\r\n                    types.add(item);\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n        }));\r\n        if (!singletonComponentDefs.length)\r\n            return;\r\n        this.executing = true;\r\n        const singleton = this.createEntity(singletonComponentDefs).hold();\r\n        this.executing = false;\r\n        this.flush();\r\n        return singleton;\r\n    }\r\n    splitDefs(defs) {\r\n        const componentTypes = [];\r\n        const componentTypesSet = new Set();\r\n        const componentEnums = new Set();\r\n        const systemTypes = [];\r\n        const systemGroups = [];\r\n        let lastDefWasSystem = false;\r\n        for (const def of defs.flat(Infinity)) {\r\n            if (def instanceof SystemGroupImpl) {\r\n                systemGroups.push(def);\r\n                const { componentTypes: nestedComponentTypes, systemTypes: nestedSystemTypes, systemGroups: nestedSystemGroups } = this.splitDefs(def.__contents);\r\n                for (const type of nestedComponentTypes)\r\n                    addUniqueComponentType(type);\r\n                systemTypes.push(...nestedSystemTypes);\r\n                systemGroups.push(...nestedSystemGroups);\r\n            }\r\n            else if (typeof def === 'function') {\r\n                lastDefWasSystem = !!def.__system;\r\n                if (lastDefWasSystem) {\r\n                    systemTypes.push(def);\r\n                }\r\n                else {\r\n                    addUniqueComponentType(def);\r\n                }\r\n            }\r\n            else if (def instanceof ComponentEnum) {\r\n                componentEnums.add(def);\r\n                for (const type of def.__types)\r\n                    addUniqueComponentType(type);\r\n            }\r\n            else {\r\n                {\r\n                    if (!lastDefWasSystem)\r\n                        throw new CheckError('Unexpected value in world defs: ' + def);\r\n                }\r\n                systemTypes.push(def);\r\n                lastDefWasSystem = false;\r\n            }\r\n        }\r\n        return { componentTypes, componentEnums: Array.from(componentEnums), systemTypes, systemGroups };\r\n        function addUniqueComponentType(type) {\r\n            if (type.enum && !componentEnums.has(type.enum)) {\r\n                componentEnums.add(type.enum);\r\n                for (const enumType of type.enum.__types)\r\n                    addUniqueComponentType(enumType);\r\n            }\r\n            else if (!componentTypesSet.has(type)) {\r\n                componentTypes.push(type);\r\n                componentTypesSet.add(type);\r\n            }\r\n        }\r\n    }\r\n    getSystems(designator) {\r\n        if (designator instanceof SystemGroupImpl)\r\n            return designator.__systems;\r\n        const system = this.systemsByClass.get(designator);\r\n        if (!system)\r\n            throw new CheckError(`System ${designator.name} not registered in world`);\r\n        return [system];\r\n    }\r\n    async initialize() {\r\n        await this.default.frame.begin();\r\n        this.state = State.setup;\r\n        await this.default.group.__plan.initialize();\r\n        await this.default.frame.end();\r\n        this.stats.frames -= 1;\r\n    }\r\n    async finalize() {\r\n        await this.default.frame.begin();\r\n        this.state = State.done;\r\n        await this.default.group.__plan.finalize();\r\n        await this.default.frame.end();\r\n        this.stats.frames -= 1;\r\n        this.registry.releaseComponentTypes();\r\n    }\r\n    async execute(time, delta) {\r\n        await this.default.frame.begin();\r\n        await this.default.frame.execute(this.default.group, time, delta);\r\n        await this.default.frame.end();\r\n    }\r\n    executeFunction(fn) {\r\n        // This inlines the code for Frame begin/execute/end to make it synchronous.\r\n        this.startFrame(this.lastTime);\r\n        this.executingSyncFrame = true;\r\n        this.buildSystem.__callback = fn;\r\n        this.systemsByClass.get(Build).execute(this.lastTime, 0);\r\n        this.flush();\r\n        this.completeCycle();\r\n        this.completeFrame(); // async only if termination pending, but it's forbidden in this context\r\n        this.executingSyncFrame = false;\r\n        // This is not really a frame, so back out the count.\r\n        this.stats.frames -= 1;\r\n    }\r\n    completeCycle() {\r\n        this.registry.completeCycle(); // may update writeLog\r\n        this.indexer.completeCycle();\r\n        this.writeLog?.commit();\r\n    }\r\n    startFrame(time) {\r\n        if (this.executing)\r\n            throw new CheckError('Another frame already executing');\r\n        this.executing = true;\r\n        {\r\n            if (this.state !== State.setup && this.state !== State.run && this.state !== State.finish) {\r\n                throw new CheckError('World terminated');\r\n            }\r\n        }\r\n        this.state = State.run;\r\n        this.lastTime = time;\r\n    }\r\n    completeFrame() {\r\n        if (!this.executing)\r\n            throw new InternalError('No frame executing');\r\n        this.executing = false;\r\n        this.gatherFrameStats();\r\n        this.processDeferredControls();\r\n        if (this.state === State.finish)\r\n            return this.finalize();\r\n        return Promise.resolve();\r\n    }\r\n    gatherFrameStats() {\r\n        this.stats.frames += 1;\r\n        this.stats.maxShapeChangesPerFrame = this.shapeLog.countSince(this.shapeLogFramePointer);\r\n        this.stats.maxWritesPerFrame = this.writeLog?.countSince(this.writeLogFramePointer) ?? 0;\r\n    }\r\n    flush() {\r\n        this.indexer.flush(); // may update writeLog\r\n        this.registry.flush();\r\n        this.shapeLog.commit();\r\n        this.writeLog?.commit();\r\n    }\r\n    async terminate() {\r\n        {\r\n            if (this.state !== State.setup && this.state !== State.run) {\r\n                throw new CheckError('World terminated');\r\n            }\r\n            if (this.executingSyncFrame) {\r\n                throw new CheckError('Cannot terminate world from within build callback');\r\n            }\r\n        }\r\n        this.state = State.finish;\r\n        if (!this.executing)\r\n            await this.finalize();\r\n    }\r\n    createEntity(initialComponents) {\r\n        const entity = this.registry.createEntity(initialComponents);\r\n        if (!this.executing)\r\n            this.flush();\r\n        return entity;\r\n    }\r\n    control(options) {\r\n        this.checkControlOverlap(options);\r\n        this.deferRequestedRunState(options.stop, RunState.STOPPED);\r\n        this.deferRequestedRunState(options.restart, RunState.RUNNING);\r\n        if (!this.executing)\r\n            this.processDeferredControls();\r\n    }\r\n    deferRequestedRunState(defs, state) {\r\n        for (const def of this.splitDefs(defs).systemTypes) {\r\n            if (!def.__system)\r\n                continue;\r\n            const system = this.systemsByClass.get(def);\r\n            if (!system)\r\n                throw new CheckError(`System ${def.name} not defined for this world`);\r\n            this.deferredControls.set(system, state);\r\n        }\r\n    }\r\n    checkControlOverlap(options) {\r\n        const stopSet = new Set();\r\n        for (const def of this.splitDefs(options.stop).systemTypes) {\r\n            if (def.__system)\r\n                stopSet.add(def);\r\n        }\r\n        for (const def of this.splitDefs(options.restart).systemTypes) {\r\n            if (!def.__system)\r\n                continue;\r\n            if (stopSet.has(def)) {\r\n                throw new CheckError(`Request to both stop and restart system ${def.name}`);\r\n            }\r\n        }\r\n    }\r\n    processDeferredControls() {\r\n        if (!this.deferredControls.size)\r\n            return;\r\n        for (const [system, state] of this.deferredControls.entries()) {\r\n            switch (state) {\r\n                case RunState.STOPPED:\r\n                    system.stop();\r\n                    break;\r\n                case RunState.RUNNING:\r\n                    system.restart();\r\n                    break;\r\n            }\r\n        }\r\n        this.deferredControls.clear();\r\n    }\r\n}\n\nconst MAGIC_COOKIE = {};\r\n/**\r\n * A container for entities, components, and systems, and the sole entry point to all functionality.\r\n * Normally you'll create just one world for your game or app.\r\n */\r\nclass World {\r\n    __dispatcher;\r\n    /**\r\n     * Creates a world that contains entities, components and systems.  All systems will be\r\n     * instantiated and initialized before the returned promise resolves.\r\n     *\r\n     * You cannot add more component or system types once the world has been created. You can create\r\n     * multiple worlds but they will not share entities, and must not share component types.  (They\r\n     * can share system types, but each will have its own instances of them.)\r\n     *\r\n     * @param options The options with which to initialize the world.\r\n     *\r\n     * @returns A promise of a new world to do with as you please.\r\n     */\r\n    static async create(options = {}) {\r\n        const world = new World(options, MAGIC_COOKIE);\r\n        await world.__dispatcher.initialize();\r\n        return world;\r\n    }\r\n    static defineEnum(name, ...componentTypes) {\r\n        if (typeof name === 'function') {\r\n            componentTypes.unshift(name);\r\n            name = '';\r\n        }\r\n        name = name || '<anonymous>';\r\n        return new ComponentEnum(name, componentTypes);\r\n    }\r\n    /**\r\n     * This is a private constructor, please use the World.create() method instead.\r\n     */\r\n    constructor(options, magicCookie) {\r\n        {\r\n            if (magicCookie !== MAGIC_COOKIE) {\r\n                throw new CheckError(`Don't call World constructor directly; use World.create instead`);\r\n            }\r\n        }\r\n        this.__dispatcher = new Dispatcher(options);\r\n    }\r\n    /**\r\n     * Executes a function that creates and updates entities.  The function gets executed in the\r\n     * context of a no-op system so it can access all its convenience methods.  You can only invoke\r\n     * this method when the world is not executing, e.g. during initial setup or between frames.\r\n     *\r\n     * @param callback The function to execute.  It receives a system as the sole argument, which it\r\n     * can use to create new entities.  You can retain references to these entities within the\r\n     * function but you must be careful not to let them leak out, as the entity objects are merely\r\n     * handles that will be reassigned without warning.  (The entities themselves will persist, of\r\n     * course.)\r\n     */\r\n    build(callback) {\r\n        {\r\n            if (this.__dispatcher.state !== State.setup &&\r\n                (typeof process === 'undefined' || process.env.NODE_ENV !== 'test')) {\r\n                throw new CheckError('This method cannot be called after the world has started executing');\r\n            }\r\n        }\r\n        this.__dispatcher.executeFunction(callback);\r\n    }\r\n    /**\r\n     * Creates a new entity and add it to the world.  The entity is not returned -- if you need that,\r\n     * use `build` instead.\r\n     *\r\n     * @param initialComponents The types of the components to add to the new entity, optionally\r\n     * interleaved with their initial properties.\r\n     */\r\n    createEntity(...initialComponents) {\r\n        {\r\n            if (this.__dispatcher.state !== State.setup &&\r\n                (typeof process === 'undefined' || process.env.NODE_ENV !== 'test')) {\r\n                throw new CheckError('This method cannot be called after the world has started executing');\r\n            }\r\n        }\r\n        this.__dispatcher.createEntity(initialComponents);\r\n    }\r\n    /**\r\n     * Executes all the systems defined during the world's creation.  The systems will be executed as\r\n     * ordered by their constraints, *not* in the order they were defined.  See\r\n     * {@link System.schedule} for details.\r\n     *\r\n     * @param time The time of this frame's execution.  This will be set on every system's `time`\r\n     * property and defaults to the time when `execute` was called.  It's not used internally so you\r\n     * can pass in any numeric value that's expected by your systems.\r\n     *\r\n     * @param delta The duration since the last frame's execution.  This will be set on every system's\r\n     * `delta` property and default to the duration since the previous call to `execute`. It's not\r\n     * used internally so you can pass in any numeric value that's expected by your systems.\r\n     */\r\n    execute(time, delta) {\r\n        return this.__dispatcher.execute(time, delta);\r\n    }\r\n    /**\r\n     * Controls the running state of systems by stopping or restarting them.  Stopped systems won't\r\n     * update their queries and generally won't consume resources.  Restarting a system is a\r\n     * potentially expensive operation so you should only use this facility for major state changes,\r\n     * e.g. between scenes.  Restarted systems will not backfill any reactive queries with events that\r\n     * happened while they were stopped.\r\n     *\r\n     * You can call this method at any time but the control instructions will only be applied between\r\n     * frames.\r\n     *\r\n     * @param options The control instructions.\r\n     */\r\n    control(options) {\r\n        this.__dispatcher.control(options);\r\n    }\r\n    /**\r\n     * Creates an executor that allows you to run a subset of all defined systems in a frame, or run\r\n     * some of them multiple times.  You can switch which executor you use between frames or even\r\n     * interleave running becsy's default execution strategy with your own executors.  However, if\r\n     * there are systems that won't be running for a while (because they're not in any of your\r\n     * executor's groups) you must still stop them explicitly or you'll run out of reserved buffer\r\n     * space.\r\n     *\r\n     * Creating an executor is a potentially expensive operation so you should create them all up\r\n     * front for the various combinations of system groups you might want to run.\r\n     *\r\n     * @param groups All the possible groups of systems that this executor might want to run.  The\r\n     * groups must be a subset of the world's defined groups.  Every group must be executed regularly\r\n     * at least once every few frames, otherwise you'll likely overflow reserved buffer space.  (This\r\n     * is true even if the groups overlap, as execution is tracked at a group level, not for\r\n     * individual systems.)\r\n     *\r\n     * @returns A frame executor that lets you manually run system groups within a frame.\r\n     */\r\n    createCustomExecutor(...groups) {\r\n        return new FrameImpl(this.__dispatcher, groups);\r\n    }\r\n    /**\r\n     * Terminates this world once the current frame (if any) completes.  All workers will be\r\n     * terminated and no further executions will be allowed.\r\n     */\r\n    async terminate() {\r\n        await this.__dispatcher.terminate();\r\n    }\r\n    get stats() {\r\n        return this.__dispatcher.stats;\r\n    }\r\n    /**\r\n     * Returns whether this world is alive and capable of execution (true), or has been terminated\r\n     * (false).\r\n     */\r\n    get alive() {\r\n        return this.__dispatcher.state !== State.done;\r\n    }\r\n}\n\nexport { CanceledError, Query, System, Type, World, co, component, field, system };\n//# sourceMappingURL=index.js.map\n"],"names":[],"sourceRoot":""}